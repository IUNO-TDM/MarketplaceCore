<database server="localhost" currentTime="16.01.2018 16:46:06" version="PostgreSQL 9.6.2, compiled by Visual C++ build 1800, 64-bit" short_version="9.6.2" name="MarketplaceCore">
  <dependency objName="public.transactions" xtype="U" dependentObjectName="public.transactions_pk" dependentObjectType="INDEX" />
  <dependency objName="public.technologydatatags" xtype="U" dependentObjectName="public.technologydatatag_pk" dependentObjectType="INDEX" />
  <dependency objName="public.technologydatacomponents" xtype="U" dependentObjectName="public.technologydatacomponents_pk" dependentObjectType="INDEX" />
  <dependency objName="public.technologydata" xtype="U" dependentObjectName="public.technologydata_pk" dependentObjectType="INDEX" />
  <dependency objName="public.technologies" xtype="U" dependentObjectName="public.technologies_pk" dependentObjectType="INDEX" />
  <dependency objName="public.technologies" xtype="U" dependentObjectName="public.technologies__un" dependentObjectType="INDEX" />
  <dependency objName="public.tags" xtype="U" dependentObjectName="public.tags_pk" dependentObjectType="INDEX" />
  <dependency objName="public.rolespermissions" xtype="U" dependentObjectName="public.rolespermissions_pk" dependentObjectType="INDEX" />
  <dependency objName="public.roles" xtype="U" dependentObjectName="public.roles_pk" dependentObjectType="INDEX" />
  <dependency objName="public.paymentinvoice" xtype="U" dependentObjectName="public.paymentinvoice_pk" dependentObjectType="INDEX" />
  <dependency objName="public.payment" xtype="U" dependentObjectName="public.payment_pk" dependentObjectType="INDEX" />
  <dependency objName="public.offerrequestitems" xtype="U" dependentObjectName="public.offerrequestitems_pk" dependentObjectType="INDEX" />
  <dependency objName="public.offerrequest" xtype="U" dependentObjectName="public.offerrequest_pk" dependentObjectType="INDEX" />
  <dependency objName="public.offer" xtype="U" dependentObjectName="public.offer_pk" dependentObjectType="INDEX" />
  <dependency objName="public.logtable" xtype="U" dependentObjectName="public.logtable_pk" dependentObjectType="INDEX" />
  <dependency objName="public.logstatus" xtype="U" dependentObjectName="public.logstatus_pk" dependentObjectType="INDEX" />
  <dependency objName="public.licenseorder" xtype="U" dependentObjectName="public.licenseorder_pk" dependentObjectType="INDEX" />
  <dependency objName="public.functions" xtype="U" dependentObjectName="public.functions_pk" dependentObjectType="INDEX" />
  <dependency objName="public.componentstechnologies" xtype="U" dependentObjectName="public.componentstechnologies_pk" dependentObjectType="INDEX" />
  <dependency objName="public.componentsattribute" xtype="U" dependentObjectName="public.componentsattribute_pk" dependentObjectType="INDEX" />
  <dependency objName="public.components" xtype="U" dependentObjectName="public.components_pk" dependentObjectType="INDEX" />
  <dependency objName="public.components" xtype="U" dependentObjectName="public.components__un" dependentObjectType="INDEX" />
  <dependency objName="public.attributes" xtype="U" dependentObjectName="public.attributes__un" dependentObjectType="INDEX" />
  <dependency objName="public.attributes" xtype="U" dependentObjectName="public.attribubes_pk" dependentObjectType="INDEX" />
  <serverOption name="allow_system_table_mods" setting="off" category="Developer Options" short_desc="Allows modifications of the structure of system tables." context="postmaster" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="application_name" setting="" category="Reporting and Logging / What to Log" short_desc="Sets the application name to be reported in statistics and logs." context="user" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="archive_command" setting="(disabled)" category="Write-Ahead Log / Archiving" short_desc="Sets the shell command that will be called to archive a WAL file." context="sighup" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="archive_mode" setting="off" category="Write-Ahead Log / Archiving" short_desc="Allows archiving of WAL files using archive_command." context="postmaster" vartype="enum" source="pg_settings" enumvals="{always,on,off}" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="archive_timeout" setting="0" unit="s" category="Write-Ahead Log / Archiving" short_desc="Forces a switch to the next xlog file if a new file has not been started within N seconds." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="1073741823" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="array_nulls" setting="on" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Enable input of NULL elements in arrays." extra_desc="When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="authentication_timeout" setting="60" unit="s" category="Connections and Authentication / Security and Authentication" short_desc="Sets the maximum allowed time to complete client authentication." context="sighup" vartype="integer" source="pg_settings" min_val="1" max_val="600" boot_val="60" reset_val="60" pending_restart="0" />
  <serverOption name="autovacuum" setting="on" category="Autovacuum" short_desc="Starts the autovacuum subprocess." context="sighup" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="autovacuum_analyze_scale_factor" setting="0.1" category="Autovacuum" short_desc="Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples." context="sighup" vartype="real" source="pg_settings" min_val="0" max_val="100" boot_val="0.1" reset_val="0.1" pending_restart="0" />
  <serverOption name="autovacuum_analyze_threshold" setting="50" category="Autovacuum" short_desc="Minimum number of tuple inserts, updates, or deletes prior to analyze." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="50" reset_val="50" pending_restart="0" />
  <serverOption name="autovacuum_freeze_max_age" setting="200000000" category="Autovacuum" short_desc="Age at which to autovacuum a table to prevent transaction ID wraparound." context="postmaster" vartype="integer" source="pg_settings" min_val="100000" max_val="2000000000" boot_val="200000000" reset_val="200000000" pending_restart="0" />
  <serverOption name="autovacuum_max_workers" setting="3" category="Autovacuum" short_desc="Sets the maximum number of simultaneously running autovacuum worker processes." context="postmaster" vartype="integer" source="pg_settings" min_val="1" max_val="262143" boot_val="3" reset_val="3" pending_restart="0" />
  <serverOption name="autovacuum_multixact_freeze_max_age" setting="400000000" category="Autovacuum" short_desc="Multixact age at which to autovacuum a table to prevent multixact wraparound." context="postmaster" vartype="integer" source="pg_settings" min_val="10000" max_val="2000000000" boot_val="400000000" reset_val="400000000" pending_restart="0" />
  <serverOption name="autovacuum_naptime" setting="60" unit="s" category="Autovacuum" short_desc="Time to sleep between autovacuum runs." context="sighup" vartype="integer" source="pg_settings" min_val="1" max_val="2147483" boot_val="60" reset_val="60" pending_restart="0" />
  <serverOption name="autovacuum_vacuum_cost_delay" setting="20" unit="ms" category="Autovacuum" short_desc="Vacuum cost delay in milliseconds, for autovacuum." context="sighup" vartype="integer" source="pg_settings" min_val="-1" max_val="100" boot_val="20" reset_val="20" pending_restart="0" />
  <serverOption name="autovacuum_vacuum_cost_limit" setting="-1" category="Autovacuum" short_desc="Vacuum cost amount available before napping, for autovacuum." context="sighup" vartype="integer" source="pg_settings" min_val="-1" max_val="10000" boot_val="-1" reset_val="-1" pending_restart="0" />
  <serverOption name="autovacuum_vacuum_scale_factor" setting="0.2" category="Autovacuum" short_desc="Number of tuple updates or deletes prior to vacuum as a fraction of reltuples." context="sighup" vartype="real" source="pg_settings" min_val="0" max_val="100" boot_val="0.2" reset_val="0.2" pending_restart="0" />
  <serverOption name="autovacuum_vacuum_threshold" setting="50" category="Autovacuum" short_desc="Minimum number of tuple updates or deletes prior to vacuum." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="50" reset_val="50" pending_restart="0" />
  <serverOption name="autovacuum_work_mem" setting="-1" unit="kB" category="Resource Usage / Memory" short_desc="Sets the maximum memory to be used by each autovacuum worker process." context="sighup" vartype="integer" source="pg_settings" min_val="-1" max_val="2097151" boot_val="-1" reset_val="-1" pending_restart="0" />
  <serverOption name="backend_flush_after" setting="0" unit="8kB" category="Resource Usage / Asynchronous Behavior" short_desc="Number of pages after which previously performed writes are flushed to disk." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="256" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="backslash_quote" setting="safe_encoding" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Sets whether &quot;\'&quot; is allowed in string literals." context="user" vartype="enum" source="pg_settings" enumvals="{safe_encoding,on,off}" boot_val="safe_encoding" reset_val="safe_encoding" pending_restart="0" />
  <serverOption name="bgwriter_delay" setting="200" unit="ms" category="Resource Usage / Background Writer" short_desc="Background writer sleep time between rounds." context="sighup" vartype="integer" source="pg_settings" min_val="10" max_val="10000" boot_val="200" reset_val="200" pending_restart="0" />
  <serverOption name="bgwriter_flush_after" setting="0" unit="8kB" category="Resource Usage / Background Writer" short_desc="Number of pages after which previously performed writes are flushed to disk." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="256" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="bgwriter_lru_maxpages" setting="100" category="Resource Usage / Background Writer" short_desc="Background writer maximum number of LRU pages to flush per round." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="1000" boot_val="100" reset_val="100" pending_restart="0" />
  <serverOption name="bgwriter_lru_multiplier" setting="2" category="Resource Usage / Background Writer" short_desc="Multiple of the average buffer usage to free per round." context="sighup" vartype="real" source="pg_settings" min_val="0" max_val="10" boot_val="2" reset_val="2" pending_restart="0" />
  <serverOption name="block_size" setting="8192" category="Preset Options" short_desc="Shows the size of a disk block." context="internal" vartype="integer" source="pg_settings" min_val="8192" max_val="8192" boot_val="8192" reset_val="8192" pending_restart="0" />
  <serverOption name="bonjour" setting="off" category="Connections and Authentication / Connection Settings" short_desc="Enables advertising the server via Bonjour." context="postmaster" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="bonjour_name" setting="" category="Connections and Authentication / Connection Settings" short_desc="Sets the Bonjour service name." context="postmaster" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="bytea_output" setting="hex" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the output format for bytea." context="user" vartype="enum" source="pg_settings" enumvals="{escape,hex}" boot_val="hex" reset_val="hex" pending_restart="0" />
  <serverOption name="check_function_bodies" setting="on" category="Client Connection Defaults / Statement Behavior" short_desc="Check function bodies during CREATE FUNCTION." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="checkpoint_completion_target" setting="0.5" category="Write-Ahead Log / Checkpoints" short_desc="Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval." context="sighup" vartype="real" source="pg_settings" min_val="0" max_val="1" boot_val="0.5" reset_val="0.5" pending_restart="0" />
  <serverOption name="checkpoint_flush_after" setting="0" unit="8kB" category="Write-Ahead Log / Checkpoints" short_desc="Number of pages after which previously performed writes are flushed to disk." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="256" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="checkpoint_timeout" setting="300" unit="s" category="Write-Ahead Log / Checkpoints" short_desc="Sets the maximum time between automatic WAL checkpoints." context="sighup" vartype="integer" source="pg_settings" min_val="30" max_val="86400" boot_val="300" reset_val="300" pending_restart="0" />
  <serverOption name="checkpoint_warning" setting="30" unit="s" category="Write-Ahead Log / Checkpoints" short_desc="Enables warnings if checkpoint segments are filled more frequently than this." extra_desc="Write a message to the server log if checkpoints caused by the filling of checkpoint segment files happens more frequently than this number of seconds. Zero turns off the warning." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="30" reset_val="30" pending_restart="0" />
  <serverOption name="client_encoding" setting="WIN1252" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the client's character set encoding." context="user" vartype="string" source="pg_settings" boot_val="SQL_ASCII" reset_val="UTF8" pending_restart="0" />
  <serverOption name="client_min_messages" setting="notice" category="Reporting and Logging / When to Log" short_desc="Sets the message levels that are sent to the client." extra_desc="Each level includes all the levels that follow it. The later the level, the fewer messages are sent." context="user" vartype="enum" source="pg_settings" enumvals="{debug5,debug4,debug3,debug2,debug1,log,notice,warning,error}" boot_val="notice" reset_val="notice" pending_restart="0" />
  <serverOption name="cluster_name" setting="" category="Process Title" short_desc="Sets the name of the cluster, which is included in the process title." context="postmaster" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="commit_delay" setting="0" category="Write-Ahead Log / Settings" short_desc="Sets the delay in microseconds between transaction commit and flushing WAL to disk." context="superuser" vartype="integer" source="pg_settings" min_val="0" max_val="100000" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="commit_siblings" setting="5" category="Write-Ahead Log / Settings" short_desc="Sets the minimum concurrent open transactions before performing commit_delay." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="1000" boot_val="5" reset_val="5" pending_restart="0" />
  <serverOption name="config_file" setting="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" category="File Locations" short_desc="Sets the server's main configuration file." context="postmaster" vartype="string" source="pg_settings" reset_val="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" pending_restart="0" />
  <serverOption name="constraint_exclusion" setting="partition" category="Query Tuning / Other Planner Options" short_desc="Enables the planner to use constraints to optimize queries." extra_desc="Table scans will be skipped if their constraints guarantee that no rows match the query." context="user" vartype="enum" source="pg_settings" enumvals="{partition,on,off}" boot_val="partition" reset_val="partition" pending_restart="0" />
  <serverOption name="cpu_index_tuple_cost" setting="0.005" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's estimate of the cost of processing each index entry during an index scan." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1.79769e+308" boot_val="0.005" reset_val="0.005" pending_restart="0" />
  <serverOption name="cpu_operator_cost" setting="0.0025" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's estimate of the cost of processing each operator or function call." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1.79769e+308" boot_val="0.0025" reset_val="0.0025" pending_restart="0" />
  <serverOption name="cpu_tuple_cost" setting="0.01" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's estimate of the cost of processing each tuple (row)." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1.79769e+308" boot_val="0.01" reset_val="0.01" pending_restart="0" />
  <serverOption name="cursor_tuple_fraction" setting="0.1" category="Query Tuning / Other Planner Options" short_desc="Sets the planner's estimate of the fraction of a cursor's rows that will be retrieved." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1" boot_val="0.1" reset_val="0.1" pending_restart="0" />
  <serverOption name="data_checksums" setting="off" category="Preset Options" short_desc="Shows whether data checksums are turned on for this cluster." context="internal" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="data_directory" setting="C:/Program Files/PostgreSQL/9.6/data" category="File Locations" short_desc="Sets the server's data directory." context="postmaster" vartype="string" source="pg_settings" reset_val="C:/Program Files/PostgreSQL/9.6/data" pending_restart="0" />
  <serverOption name="DateStyle" setting="ISO, DMY" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the display format for date and time values." extra_desc="Also controls interpretation of ambiguous date inputs." context="user" vartype="string" source="pg_settings" boot_val="ISO, MDY" reset_val="ISO, DMY" pending_restart="0" />
  <serverOption name="db_user_namespace" setting="off" category="Connections and Authentication / Security and Authentication" short_desc="Enables per-database user names." context="sighup" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="deadlock_timeout" setting="1000" unit="ms" category="Lock Management" short_desc="Sets the time to wait on a lock before checking for deadlock." context="superuser" vartype="integer" source="pg_settings" min_val="1" max_val="2147483647" boot_val="1000" reset_val="1000" pending_restart="0" />
  <serverOption name="debug_assertions" setting="off" category="Preset Options" short_desc="Shows whether the running server has assertion checks enabled." context="internal" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="debug_pretty_print" setting="on" category="Reporting and Logging / What to Log" short_desc="Indents parse and plan tree displays." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="debug_print_parse" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs each query's parse tree." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="debug_print_plan" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs each query's execution plan." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="debug_print_rewritten" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs each query's rewritten parse tree." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="default_statistics_target" setting="100" category="Query Tuning / Other Planner Options" short_desc="Sets the default statistics target." extra_desc="This applies to table columns that have not had a column-specific target set via ALTER TABLE SET STATISTICS." context="user" vartype="integer" source="pg_settings" min_val="1" max_val="10000" boot_val="100" reset_val="100" pending_restart="0" />
  <serverOption name="default_tablespace" setting="" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the default tablespace to create tables and indexes in." extra_desc="An empty string selects the database's default tablespace." context="user" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="default_text_search_config" setting="pg_catalog.german" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets default text search configuration." context="user" vartype="string" source="pg_settings" boot_val="pg_catalog.simple" reset_val="pg_catalog.german" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="576" pending_restart="0" />
  <serverOption name="default_transaction_deferrable" setting="off" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the default deferrable status of new transactions." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="default_transaction_isolation" setting="read committed" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the transaction isolation level of each new transaction." context="user" vartype="enum" source="pg_settings" enumvals="{serializable,&quot;repeatable read&quot;,&quot;read committed&quot;,&quot;read uncommitted&quot;}" boot_val="read committed" reset_val="read committed" pending_restart="0" />
  <serverOption name="default_transaction_read_only" setting="off" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the default read-only status of new transactions." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="default_with_oids" setting="off" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Create new tables with OIDs by default." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="dynamic_library_path" setting="$libdir" category="Client Connection Defaults / Other Defaults" short_desc="Sets the path for dynamically loadable modules." extra_desc="If a dynamically loadable module needs to be opened and the specified name does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the specified file." context="superuser" vartype="string" source="pg_settings" boot_val="$libdir" reset_val="$libdir" pending_restart="0" />
  <serverOption name="dynamic_shared_memory_type" setting="windows" category="Resource Usage / Memory" short_desc="Selects the dynamic shared memory implementation used." context="postmaster" vartype="enum" source="pg_settings" enumvals="{windows,none}" boot_val="windows" reset_val="windows" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="127" pending_restart="0" />
  <serverOption name="effective_cache_size" setting="524288" unit="8kB" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's assumption about the size of the disk cache." extra_desc="That is, the portion of the kernel's disk cache that will be used for PostgreSQL data files. This is measured in disk pages, which are normally 8 kB each." context="user" vartype="integer" source="pg_settings" min_val="1" max_val="2147483647" boot_val="524288" reset_val="524288" pending_restart="0" />
  <serverOption name="effective_io_concurrency" setting="0" category="Resource Usage / Asynchronous Behavior" short_desc="Number of simultaneous requests that can be handled efficiently by the disk subsystem." extra_desc="For RAID arrays, this should be approximately the number of drive spindles in the array." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="0" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="enable_bitmapscan" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of bitmap-scan plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_hashagg" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of hashed aggregation plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_hashjoin" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of hash join plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_indexonlyscan" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of index-only-scan plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_indexscan" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of index-scan plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_material" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of materialization." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_mergejoin" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of merge join plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_nestloop" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of nested-loop join plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_seqscan" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of sequential-scan plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_sort" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of explicit sort steps." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="enable_tidscan" setting="on" category="Query Tuning / Planner Method Configuration" short_desc="Enables the planner's use of TID scan plans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="escape_string_warning" setting="on" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Warn about backslash escapes in ordinary string literals." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="event_source" setting="PostgreSQL" category="Reporting and Logging / Where to Log" short_desc="Sets the application name used to identify PostgreSQL messages in the event log." context="postmaster" vartype="string" source="pg_settings" boot_val="PostgreSQL" reset_val="PostgreSQL" pending_restart="0" />
  <serverOption name="exit_on_error" setting="off" category="Error Handling" short_desc="Terminate session on any error." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="external_pid_file" setting="" category="File Locations" short_desc="Writes the postmaster PID to the specified file." context="postmaster" vartype="string" source="pg_settings" pending_restart="0" />
  <serverOption name="extra_float_digits" setting="2" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the number of digits displayed for floating-point values." extra_desc="This affects real, double precision, and geometric data types. The parameter value is added to the standard number of digits (FLT_DIG or DBL_DIG as appropriate)." context="user" vartype="integer" source="pg_settings" min_val="-15" max_val="3" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="force_parallel_mode" setting="off" category="Query Tuning / Other Planner Options" short_desc="Forces use of parallel query facilities." extra_desc="If possible, run query using a parallel worker and with parallel restrictions." context="user" vartype="enum" source="pg_settings" enumvals="{off,on,regress}" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="from_collapse_limit" setting="8" category="Query Tuning / Other Planner Options" short_desc="Sets the FROM-list size beyond which subqueries are not collapsed." extra_desc="The planner will merge subqueries into upper queries if the resulting FROM list would have no more than this many items." context="user" vartype="integer" source="pg_settings" min_val="1" max_val="2147483647" boot_val="8" reset_val="8" pending_restart="0" />
  <serverOption name="fsync" setting="on" category="Write-Ahead Log / Settings" short_desc="Forces synchronization of updates to disk." extra_desc="The server will use the fsync() system call in several places to make sure that updates are physically written to disk. This insures that a database cluster will recover to a consistent state after an operating system or hardware crash." context="sighup" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="full_page_writes" setting="on" category="Write-Ahead Log / Settings" short_desc="Writes full pages to WAL when first modified after a checkpoint." extra_desc="A page write in process during an operating system crash might be only partially written to disk.  During recovery, the row changes stored in WAL are not enough to recover.  This option writes pages when first modified after a checkpoint to WAL so full recovery is possible." context="sighup" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="geqo" setting="on" category="Query Tuning / Genetic Query Optimizer" short_desc="Enables genetic query optimization." extra_desc="This algorithm attempts to do planning without exhaustive searching." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="geqo_effort" setting="5" category="Query Tuning / Genetic Query Optimizer" short_desc="GEQO: effort is used to set the default for other GEQO parameters." context="user" vartype="integer" source="pg_settings" min_val="1" max_val="10" boot_val="5" reset_val="5" pending_restart="0" />
  <serverOption name="geqo_generations" setting="0" category="Query Tuning / Genetic Query Optimizer" short_desc="GEQO: number of iterations of the algorithm." extra_desc="Zero selects a suitable default value." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="geqo_pool_size" setting="0" category="Query Tuning / Genetic Query Optimizer" short_desc="GEQO: number of individuals in the population." extra_desc="Zero selects a suitable default value." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="geqo_seed" setting="0" category="Query Tuning / Genetic Query Optimizer" short_desc="GEQO: seed for random path selection." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="geqo_selection_bias" setting="2" category="Query Tuning / Genetic Query Optimizer" short_desc="GEQO: selective pressure within the population." context="user" vartype="real" source="pg_settings" min_val="1.5" max_val="2" boot_val="2" reset_val="2" pending_restart="0" />
  <serverOption name="geqo_threshold" setting="12" category="Query Tuning / Genetic Query Optimizer" short_desc="Sets the threshold of FROM items beyond which GEQO is used." context="user" vartype="integer" source="pg_settings" min_val="2" max_val="2147483647" boot_val="12" reset_val="12" pending_restart="0" />
  <serverOption name="gin_fuzzy_search_limit" setting="0" category="Client Connection Defaults / Other Defaults" short_desc="Sets the maximum allowed result for exact search by GIN." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="gin_pending_list_limit" setting="4096" unit="kB" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the maximum size of the pending list for GIN index." context="user" vartype="integer" source="pg_settings" min_val="64" max_val="2097151" boot_val="4096" reset_val="4096" pending_restart="0" />
  <serverOption name="hba_file" setting="C:/Program Files/PostgreSQL/9.6/data/pg_hba.conf" category="File Locations" short_desc="Sets the server's &quot;hba&quot; configuration file." context="postmaster" vartype="string" source="pg_settings" reset_val="C:/Program Files/PostgreSQL/9.6/data/pg_hba.conf" pending_restart="0" />
  <serverOption name="hot_standby" setting="off" category="Replication / Standby Servers" short_desc="Allows connections and queries during recovery." context="postmaster" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="hot_standby_feedback" setting="off" category="Replication / Standby Servers" short_desc="Allows feedback from a hot standby to the primary that will avoid query conflicts." context="sighup" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="huge_pages" setting="try" category="Resource Usage / Memory" short_desc="Use of huge pages on Linux." context="postmaster" vartype="enum" source="pg_settings" enumvals="{off,on,try}" boot_val="try" reset_val="try" pending_restart="0" />
  <serverOption name="ident_file" setting="C:/Program Files/PostgreSQL/9.6/data/pg_ident.conf" category="File Locations" short_desc="Sets the server's &quot;ident&quot; configuration file." context="postmaster" vartype="string" source="pg_settings" reset_val="C:/Program Files/PostgreSQL/9.6/data/pg_ident.conf" pending_restart="0" />
  <serverOption name="idle_in_transaction_session_timeout" setting="0" unit="ms" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the maximum allowed duration of any idling transaction." extra_desc="A value of 0 turns off the timeout." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="ignore_checksum_failure" setting="off" category="Developer Options" short_desc="Continues processing after a checksum failure." extra_desc="Detection of a checksum failure normally causes PostgreSQL to report an error, aborting the current transaction. Setting ignore_checksum_failure to true causes the system to ignore the failure (but still report a warning), and continue processing. This behavior could cause crashes or other serious problems. Only has an effect if checksums are enabled." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="ignore_system_indexes" setting="off" category="Developer Options" short_desc="Disables reading from system indexes." extra_desc="It does not prevent updating the indexes, so it is safe to use.  The worst consequence is slowness." context="backend" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="integer_datetimes" setting="on" category="Preset Options" short_desc="Datetimes are integer based." context="internal" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="IntervalStyle" setting="postgres" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the display format for interval values." context="user" vartype="enum" source="pg_settings" enumvals="{postgres,postgres_verbose,sql_standard,iso_8601}" boot_val="postgres" reset_val="postgres" pending_restart="0" />
  <serverOption name="join_collapse_limit" setting="8" category="Query Tuning / Other Planner Options" short_desc="Sets the FROM-list size beyond which JOIN constructs are not flattened." extra_desc="The planner will flatten explicit JOIN constructs into lists of FROM items whenever a list of no more than this many items would result." context="user" vartype="integer" source="pg_settings" min_val="1" max_val="2147483647" boot_val="8" reset_val="8" pending_restart="0" />
  <serverOption name="krb_caseins_users" setting="off" category="Connections and Authentication / Security and Authentication" short_desc="Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive." context="sighup" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="krb_server_keyfile" setting="" category="Connections and Authentication / Security and Authentication" short_desc="Sets the location of the Kerberos server key file." context="sighup" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="lc_collate" setting="German_Germany.1252" category="Client Connection Defaults / Locale and Formatting" short_desc="Shows the collation order locale." context="internal" vartype="string" source="pg_settings" boot_val="C" reset_val="German_Germany.1252" pending_restart="0" />
  <serverOption name="lc_ctype" setting="German_Germany.1252" category="Client Connection Defaults / Locale and Formatting" short_desc="Shows the character classification and case conversion locale." context="internal" vartype="string" source="pg_settings" boot_val="C" reset_val="German_Germany.1252" pending_restart="0" />
  <serverOption name="lc_messages" setting="German_Germany.1252" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the language in which messages are displayed." context="superuser" vartype="string" source="pg_settings" boot_val="" reset_val="German_Germany.1252" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="569" pending_restart="0" />
  <serverOption name="lc_monetary" setting="German_Germany.1252" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the locale for formatting monetary amounts." context="user" vartype="string" source="pg_settings" boot_val="C" reset_val="German_Germany.1252" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="571" pending_restart="0" />
  <serverOption name="lc_numeric" setting="German_Germany.1252" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the locale for formatting numbers." context="user" vartype="string" source="pg_settings" boot_val="C" reset_val="German_Germany.1252" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="572" pending_restart="0" />
  <serverOption name="lc_time" setting="German_Germany.1252" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the locale for formatting date and time values." context="user" vartype="string" source="pg_settings" boot_val="C" reset_val="German_Germany.1252" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="573" pending_restart="0" />
  <serverOption name="listen_addresses" setting="*" category="Connections and Authentication / Connection Settings" short_desc="Sets the host name or IP address(es) to listen to." context="postmaster" vartype="string" source="pg_settings" boot_val="localhost" reset_val="*" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="59" pending_restart="0" />
  <serverOption name="lo_compat_privileges" setting="off" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Enables backward compatibility mode for privilege checks on large objects." extra_desc="Skips privilege checks when reading or modifying large objects, for compatibility with PostgreSQL releases prior to 9.0." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="local_preload_libraries" setting="" category="Client Connection Defaults / Shared Library Preloading" short_desc="Lists unprivileged shared libraries to preload into each backend." context="user" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="lock_timeout" setting="0" unit="ms" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the maximum allowed duration of any wait for a lock." extra_desc="A value of 0 turns off the timeout." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="log_autovacuum_min_duration" setting="-1" unit="ms" category="Reporting and Logging / What to Log" short_desc="Sets the minimum execution time above which autovacuum actions will be logged." extra_desc="Zero prints all actions. -1 turns autovacuum logging off." context="sighup" vartype="integer" source="pg_settings" min_val="-1" max_val="2147483647" boot_val="-1" reset_val="-1" pending_restart="0" />
  <serverOption name="log_checkpoints" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs each checkpoint." context="sighup" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_connections" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs each successful connection." context="superuser-backend" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_destination" setting="stderr" category="Reporting and Logging / Where to Log" short_desc="Sets the destination for server log output." extra_desc="Valid values are combinations of &quot;stderr&quot;, &quot;syslog&quot;, &quot;csvlog&quot;, and &quot;eventlog&quot;, depending on the platform." context="sighup" vartype="string" source="pg_settings" boot_val="stderr" reset_val="stderr" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="333" pending_restart="0" />
  <serverOption name="log_directory" setting="pg_log" category="Reporting and Logging / Where to Log" short_desc="Sets the destination directory for log files." extra_desc="Can be specified as relative to the data directory or as absolute path." context="sighup" vartype="string" source="pg_settings" boot_val="pg_log" reset_val="pg_log" pending_restart="0" />
  <serverOption name="log_disconnections" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs end of a session, including duration." context="superuser-backend" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_duration" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs the duration of each completed SQL statement." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_error_verbosity" setting="default" category="Reporting and Logging / What to Log" short_desc="Sets the verbosity of logged messages." context="superuser" vartype="enum" source="pg_settings" enumvals="{terse,default,verbose}" boot_val="default" reset_val="default" pending_restart="0" />
  <serverOption name="log_executor_stats" setting="off" category="Statistics / Monitoring" short_desc="Writes executor performance statistics to the server log." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_file_mode" setting="0600" category="Reporting and Logging / Where to Log" short_desc="Sets the file permissions for log files." extra_desc="The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format the number must start with a 0 (zero).)" context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="511" boot_val="384" reset_val="384" pending_restart="0" />
  <serverOption name="log_filename" setting="postgresql-%Y-%m-%d_%H%M%S.log" category="Reporting and Logging / Where to Log" short_desc="Sets the file name pattern for log files." context="sighup" vartype="string" source="pg_settings" boot_val="postgresql-%Y-%m-%d_%H%M%S.log" reset_val="postgresql-%Y-%m-%d_%H%M%S.log" pending_restart="0" />
  <serverOption name="log_hostname" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs the host name in the connection logs." extra_desc="By default, connection logs only show the IP address of the connecting host. If you want them to show the host name you can turn this on, but depending on your host name resolution setup it might impose a non-negligible performance penalty." context="sighup" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_line_prefix" setting="%t" category="Reporting and Logging / What to Log" short_desc="Controls information prefixed to each log line." extra_desc="If blank, no prefix is used." context="sighup" vartype="string" source="pg_settings" boot_val="" reset_val="%t" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="433" pending_restart="0" />
  <serverOption name="log_lock_waits" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs long lock waits." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_min_duration_statement" setting="-1" unit="ms" category="Reporting and Logging / When to Log" short_desc="Sets the minimum execution time above which statements will be logged." extra_desc="Zero prints all queries. -1 turns this feature off." context="superuser" vartype="integer" source="pg_settings" min_val="-1" max_val="2147483647" boot_val="-1" reset_val="-1" pending_restart="0" />
  <serverOption name="log_min_error_statement" setting="error" category="Reporting and Logging / When to Log" short_desc="Causes all statements generating error at or above this level to be logged." extra_desc="Each level includes all the levels that follow it. The later the level, the fewer messages are sent." context="superuser" vartype="enum" source="pg_settings" enumvals="{debug5,debug4,debug3,debug2,debug1,info,notice,warning,error,log,fatal,panic}" boot_val="error" reset_val="error" pending_restart="0" />
  <serverOption name="log_min_messages" setting="warning" category="Reporting and Logging / When to Log" short_desc="Sets the message levels that are logged." extra_desc="Each level includes all the levels that follow it. The later the level, the fewer messages are sent." context="superuser" vartype="enum" source="pg_settings" enumvals="{debug5,debug4,debug3,debug2,debug1,info,notice,warning,error,log,fatal,panic}" boot_val="warning" reset_val="warning" pending_restart="0" />
  <serverOption name="log_parser_stats" setting="off" category="Statistics / Monitoring" short_desc="Writes parser performance statistics to the server log." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_planner_stats" setting="off" category="Statistics / Monitoring" short_desc="Writes planner performance statistics to the server log." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_replication_commands" setting="off" category="Reporting and Logging / What to Log" short_desc="Logs each replication command." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_rotation_age" setting="1440" unit="min" category="Reporting and Logging / Where to Log" short_desc="Automatic log file rotation will occur after N minutes." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="35791394" boot_val="1440" reset_val="1440" pending_restart="0" />
  <serverOption name="log_rotation_size" setting="10240" unit="kB" category="Reporting and Logging / Where to Log" short_desc="Automatic log file rotation will occur after N kilobytes." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2097151" boot_val="10240" reset_val="10240" pending_restart="0" />
  <serverOption name="log_statement" setting="none" category="Reporting and Logging / What to Log" short_desc="Sets the type of statements logged." context="superuser" vartype="enum" source="pg_settings" enumvals="{none,ddl,mod,all}" boot_val="none" reset_val="none" pending_restart="0" />
  <serverOption name="log_statement_stats" setting="off" category="Statistics / Monitoring" short_desc="Writes cumulative performance statistics to the server log." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="log_temp_files" setting="-1" unit="kB" category="Reporting and Logging / What to Log" short_desc="Log the use of temporary files larger than this number of kilobytes." extra_desc="Zero logs all files. The default is -1 (turning this feature off)." context="superuser" vartype="integer" source="pg_settings" min_val="-1" max_val="2147483647" boot_val="-1" reset_val="-1" pending_restart="0" />
  <serverOption name="log_timezone" setting="CET" category="Reporting and Logging / What to Log" short_desc="Sets the time zone to use in log messages." context="sighup" vartype="string" source="pg_settings" boot_val="GMT" reset_val="CET" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="460" pending_restart="0" />
  <serverOption name="log_truncate_on_rotation" setting="off" category="Reporting and Logging / Where to Log" short_desc="Truncate existing log files of same name during log rotation." context="sighup" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="logging_collector" setting="on" category="Reporting and Logging / Where to Log" short_desc="Start a subprocess to capture stderr output and/or csvlogs into log files." context="postmaster" vartype="bool" source="pg_settings" boot_val="off" reset_val="on" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="339" pending_restart="0" />
  <serverOption name="maintenance_work_mem" setting="65536" unit="kB" category="Resource Usage / Memory" short_desc="Sets the maximum memory to be used for maintenance operations." extra_desc="This includes operations such as VACUUM and CREATE INDEX." context="user" vartype="integer" source="pg_settings" min_val="1024" max_val="2097151" boot_val="65536" reset_val="65536" pending_restart="0" />
  <serverOption name="max_connections" setting="100" category="Connections and Authentication / Connection Settings" short_desc="Sets the maximum number of concurrent connections." context="postmaster" vartype="integer" source="pg_settings" min_val="1" max_val="262143" boot_val="100" reset_val="100" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="64" pending_restart="0" />
  <serverOption name="max_files_per_process" setting="1000" category="Resource Usage / Kernel Resources" short_desc="Sets the maximum number of simultaneously open files for each server process." context="postmaster" vartype="integer" source="pg_settings" min_val="25" max_val="2147483647" boot_val="1000" reset_val="1000" pending_restart="0" />
  <serverOption name="max_function_args" setting="100" category="Preset Options" short_desc="Shows the maximum number of function arguments." context="internal" vartype="integer" source="pg_settings" min_val="100" max_val="100" boot_val="100" reset_val="100" pending_restart="0" />
  <serverOption name="max_identifier_length" setting="63" category="Preset Options" short_desc="Shows the maximum identifier length." context="internal" vartype="integer" source="pg_settings" min_val="63" max_val="63" boot_val="63" reset_val="63" pending_restart="0" />
  <serverOption name="max_index_keys" setting="32" category="Preset Options" short_desc="Shows the maximum number of index keys." context="internal" vartype="integer" source="pg_settings" min_val="32" max_val="32" boot_val="32" reset_val="32" pending_restart="0" />
  <serverOption name="max_locks_per_transaction" setting="64" category="Lock Management" short_desc="Sets the maximum number of locks per transaction." extra_desc="The shared lock table is sized on the assumption that at most max_locks_per_transaction * max_connections distinct objects will need to be locked at any one time." context="postmaster" vartype="integer" source="pg_settings" min_val="10" max_val="2147483647" boot_val="64" reset_val="64" pending_restart="0" />
  <serverOption name="max_parallel_workers_per_gather" setting="0" category="Resource Usage / Asynchronous Behavior" short_desc="Sets the maximum number of parallel processes per executor node." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="1024" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="max_pred_locks_per_transaction" setting="64" category="Lock Management" short_desc="Sets the maximum number of predicate locks per transaction." extra_desc="The shared predicate lock table is sized on the assumption that at most max_pred_locks_per_transaction * max_connections distinct objects will need to be locked at any one time." context="postmaster" vartype="integer" source="pg_settings" min_val="10" max_val="2147483647" boot_val="64" reset_val="64" pending_restart="0" />
  <serverOption name="max_prepared_transactions" setting="0" category="Resource Usage / Memory" short_desc="Sets the maximum number of simultaneously prepared transactions." context="postmaster" vartype="integer" source="pg_settings" min_val="0" max_val="262143" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="max_replication_slots" setting="0" category="Replication / Sending Servers" short_desc="Sets the maximum number of simultaneously defined replication slots." context="postmaster" vartype="integer" source="pg_settings" min_val="0" max_val="262143" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="max_stack_depth" setting="2048" unit="kB" category="Resource Usage / Memory" short_desc="Sets the maximum stack depth, in kilobytes." context="superuser" vartype="integer" source="pg_settings" min_val="100" max_val="2097151" boot_val="100" reset_val="2048" pending_restart="0" />
  <serverOption name="max_standby_archive_delay" setting="30000" unit="ms" category="Replication / Standby Servers" short_desc="Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data." context="sighup" vartype="integer" source="pg_settings" min_val="-1" max_val="2147483647" boot_val="30000" reset_val="30000" pending_restart="0" />
  <serverOption name="max_standby_streaming_delay" setting="30000" unit="ms" category="Replication / Standby Servers" short_desc="Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data." context="sighup" vartype="integer" source="pg_settings" min_val="-1" max_val="2147483647" boot_val="30000" reset_val="30000" pending_restart="0" />
  <serverOption name="max_wal_senders" setting="0" category="Replication / Sending Servers" short_desc="Sets the maximum number of simultaneously running WAL sender processes." context="postmaster" vartype="integer" source="pg_settings" min_val="0" max_val="262143" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="max_wal_size" setting="64" unit="16MB" category="Write-Ahead Log / Checkpoints" short_desc="Sets the WAL size that triggers a checkpoint." context="sighup" vartype="integer" source="pg_settings" min_val="2" max_val="2147483647" boot_val="64" reset_val="64" pending_restart="0" />
  <serverOption name="max_worker_processes" setting="8" category="Resource Usage / Asynchronous Behavior" short_desc="Maximum number of concurrent worker processes." context="postmaster" vartype="integer" source="pg_settings" min_val="0" max_val="262143" boot_val="8" reset_val="8" pending_restart="0" />
  <serverOption name="min_parallel_relation_size" setting="1024" unit="8kB" category="Query Tuning / Planner Cost Constants" short_desc="Sets the minimum size of relations to be considered for parallel scan." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="715827882" boot_val="1024" reset_val="1024" pending_restart="0" />
  <serverOption name="min_wal_size" setting="5" unit="16MB" category="Write-Ahead Log / Checkpoints" short_desc="Sets the minimum size to shrink the WAL to." context="sighup" vartype="integer" source="pg_settings" min_val="2" max_val="2147483647" boot_val="5" reset_val="5" pending_restart="0" />
  <serverOption name="old_snapshot_threshold" setting="-1" unit="min" category="Resource Usage / Asynchronous Behavior" short_desc="Time before a snapshot is too old to read pages changed after the snapshot was taken." extra_desc="A value of -1 disables this feature." context="postmaster" vartype="integer" source="pg_settings" min_val="-1" max_val="86400" boot_val="-1" reset_val="-1" pending_restart="0" />
  <serverOption name="operator_precedence_warning" setting="off" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Emit a warning for constructs that changed meaning since PostgreSQL 9.4." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="parallel_setup_cost" setting="1000" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's estimate of the cost of starting up worker processes for parallel query." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1.79769e+308" boot_val="1000" reset_val="1000" pending_restart="0" />
  <serverOption name="parallel_tuple_cost" setting="0.1" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's estimate of the cost of passing each tuple (row) from worker to master backend." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1.79769e+308" boot_val="0.1" reset_val="0.1" pending_restart="0" />
  <serverOption name="password_encryption" setting="on" category="Connections and Authentication / Security and Authentication" short_desc="Encrypt passwords." extra_desc="When a password is specified in CREATE USER or ALTER USER without writing either ENCRYPTED or UNENCRYPTED, this parameter determines whether the password is to be encrypted." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="port" setting="5432" category="Connections and Authentication / Connection Settings" short_desc="Sets the TCP port the server listens on." context="postmaster" vartype="integer" source="pg_settings" min_val="1" max_val="65535" boot_val="5432" reset_val="5432" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="63" pending_restart="0" />
  <serverOption name="post_auth_delay" setting="0" unit="s" category="Developer Options" short_desc="Waits N seconds on connection startup after authentication." extra_desc="This allows attaching a debugger to the process." context="backend" vartype="integer" source="pg_settings" min_val="0" max_val="2147" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="pre_auth_delay" setting="0" unit="s" category="Developer Options" short_desc="Waits N seconds on connection startup before authentication." extra_desc="This allows attaching a debugger to the process." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="60" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="quote_all_identifiers" setting="off" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="When generating SQL fragments, quote all identifiers." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="random_page_cost" setting="4" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's estimate of the cost of a nonsequentially fetched disk page." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1.79769e+308" boot_val="4" reset_val="4" pending_restart="0" />
  <serverOption name="replacement_sort_tuples" setting="150000" category="Resource Usage / Memory" short_desc="Sets the maximum number of tuples to be sorted using replacement selection." extra_desc="When more tuples than this are present, quicksort will be used." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="150000" reset_val="150000" pending_restart="0" />
  <serverOption name="restart_after_crash" setting="on" category="Error Handling" short_desc="Reinitialize server after backend crash." context="sighup" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="row_security" setting="on" category="Connections and Authentication / Security and Authentication" short_desc="Enable row security." extra_desc="When enabled, row security will be applied to all users." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="search_path" setting="&quot;$user&quot;, public" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the schema search order for names that are not schema-qualified." context="user" vartype="string" source="pg_settings" boot_val="&quot;$user&quot;, public" reset_val="&quot;$user&quot;, public" pending_restart="0" />
  <serverOption name="segment_size" setting="131072" unit="8kB" category="Preset Options" short_desc="Shows the number of pages per disk file." context="internal" vartype="integer" source="pg_settings" min_val="131072" max_val="131072" boot_val="131072" reset_val="131072" pending_restart="0" />
  <serverOption name="seq_page_cost" setting="1" category="Query Tuning / Planner Cost Constants" short_desc="Sets the planner's estimate of the cost of a sequentially fetched disk page." context="user" vartype="real" source="pg_settings" min_val="0" max_val="1.79769e+308" boot_val="1" reset_val="1" pending_restart="0" />
  <serverOption name="server_encoding" setting="UTF8" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the server (database) character set encoding." context="internal" vartype="string" source="pg_settings" boot_val="SQL_ASCII" reset_val="UTF8" pending_restart="0" />
  <serverOption name="server_version" setting="9.6.2" category="Preset Options" short_desc="Shows the server version." context="internal" vartype="string" source="pg_settings" boot_val="9.6.2" reset_val="9.6.2" pending_restart="0" />
  <serverOption name="server_version_num" setting="90602" category="Preset Options" short_desc="Shows the server version as an integer." context="internal" vartype="integer" source="pg_settings" min_val="90602" max_val="90602" boot_val="90602" reset_val="90602" pending_restart="0" />
  <serverOption name="session_preload_libraries" setting="" category="Client Connection Defaults / Shared Library Preloading" short_desc="Lists shared libraries to preload into each backend." context="superuser" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="session_replication_role" setting="origin" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the session's behavior for triggers and rewrite rules." context="superuser" vartype="enum" source="pg_settings" enumvals="{origin,replica,local}" boot_val="origin" reset_val="origin" pending_restart="0" />
  <serverOption name="shared_buffers" setting="16384" unit="8kB" category="Resource Usage / Memory" short_desc="Sets the number of shared memory buffers used by the server." context="postmaster" vartype="integer" source="pg_settings" min_val="16" max_val="1073741823" boot_val="1024" reset_val="16384" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="113" pending_restart="0" />
  <serverOption name="shared_preload_libraries" setting="" category="Client Connection Defaults / Shared Library Preloading" short_desc="Lists shared libraries to preload into server." context="postmaster" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="sql_inheritance" setting="on" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Causes subtables to be included by default in various commands." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="ssl" setting="off" category="Connections and Authentication / Security and Authentication" short_desc="Enables SSL connections." context="postmaster" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="ssl_ca_file" setting="" category="Connections and Authentication / Security and Authentication" short_desc="Location of the SSL certificate authority file." context="postmaster" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="ssl_cert_file" setting="server.crt" category="Connections and Authentication / Security and Authentication" short_desc="Location of the SSL server certificate file." context="postmaster" vartype="string" source="pg_settings" boot_val="server.crt" reset_val="server.crt" pending_restart="0" />
  <serverOption name="ssl_ciphers" setting="HIGH:MEDIUM:+3DES:!aNULL" category="Connections and Authentication / Security and Authentication" short_desc="Sets the list of allowed SSL ciphers." context="postmaster" vartype="string" source="pg_settings" boot_val="HIGH:MEDIUM:+3DES:!aNULL" reset_val="HIGH:MEDIUM:+3DES:!aNULL" pending_restart="0" />
  <serverOption name="ssl_crl_file" setting="" category="Connections and Authentication / Security and Authentication" short_desc="Location of the SSL certificate revocation list file." context="postmaster" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="ssl_ecdh_curve" setting="prime256v1" category="Connections and Authentication / Security and Authentication" short_desc="Sets the curve to use for ECDH." context="postmaster" vartype="string" source="pg_settings" boot_val="prime256v1" reset_val="prime256v1" pending_restart="0" />
  <serverOption name="ssl_key_file" setting="server.key" category="Connections and Authentication / Security and Authentication" short_desc="Location of the SSL server private key file." context="postmaster" vartype="string" source="pg_settings" boot_val="server.key" reset_val="server.key" pending_restart="0" />
  <serverOption name="ssl_prefer_server_ciphers" setting="on" category="Connections and Authentication / Security and Authentication" short_desc="Give priority to server ciphersuite order." context="postmaster" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="standard_conforming_strings" setting="on" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Causes '...' strings to treat backslashes literally." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="statement_timeout" setting="60000" unit="ms" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the maximum allowed duration of any statement." extra_desc="A value of 0 turns off the timeout." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="stats_temp_directory" setting="pg_stat_tmp" category="Statistics / Query and Index Statistics Collector" short_desc="Writes temporary statistics files to the specified directory." context="sighup" vartype="string" source="pg_settings" boot_val="pg_stat_tmp" reset_val="pg_stat_tmp" pending_restart="0" />
  <serverOption name="superuser_reserved_connections" setting="3" category="Connections and Authentication / Connection Settings" short_desc="Sets the number of connection slots reserved for superusers." context="postmaster" vartype="integer" source="pg_settings" min_val="0" max_val="262143" boot_val="3" reset_val="3" pending_restart="0" />
  <serverOption name="synchronize_seqscans" setting="on" category="Version and Platform Compatibility / Previous PostgreSQL Versions" short_desc="Enable synchronized sequential scans." context="user" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="synchronous_commit" setting="on" category="Write-Ahead Log / Settings" short_desc="Sets the current transaction's synchronization level." context="user" vartype="enum" source="pg_settings" enumvals="{local,remote_write,remote_apply,on,off}" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="synchronous_standby_names" setting="" category="Replication / Master Server" short_desc="Number of synchronous standbys and list of names of potential synchronous ones." context="sighup" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="syslog_facility" setting="none" category="Reporting and Logging / Where to Log" short_desc="Sets the syslog &quot;facility&quot; to be used when syslog enabled." context="sighup" vartype="enum" source="pg_settings" enumvals="{none}" boot_val="none" reset_val="none" pending_restart="0" />
  <serverOption name="syslog_ident" setting="postgres" category="Reporting and Logging / Where to Log" short_desc="Sets the program name used to identify PostgreSQL messages in syslog." context="sighup" vartype="string" source="pg_settings" boot_val="postgres" reset_val="postgres" pending_restart="0" />
  <serverOption name="syslog_sequence_numbers" setting="on" category="Reporting and Logging / Where to Log" short_desc="Add sequence number to syslog messages to avoid duplicate suppression." context="sighup" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="syslog_split_messages" setting="on" category="Reporting and Logging / Where to Log" short_desc="Split messages sent to syslog by lines and to fit into 1024 bytes." context="sighup" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="tcp_keepalives_count" setting="0" category="Client Connection Defaults / Other Defaults" short_desc="Maximum number of TCP keepalive retransmits." extra_desc="This controls the number of consecutive keepalive retransmits that can be lost before a connection is considered dead. A value of 0 uses the system default." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="tcp_keepalives_idle" setting="-1" unit="s" category="Client Connection Defaults / Other Defaults" short_desc="Time between issuing TCP keepalives." extra_desc="A value of 0 uses the system default." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="tcp_keepalives_interval" setting="-1" unit="s" category="Client Connection Defaults / Other Defaults" short_desc="Time between TCP keepalive retransmits." extra_desc="A value of 0 uses the system default." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="temp_buffers" setting="1024" unit="8kB" category="Resource Usage / Memory" short_desc="Sets the maximum number of temporary buffers used by each session." context="user" vartype="integer" source="pg_settings" min_val="100" max_val="1073741823" boot_val="1024" reset_val="1024" pending_restart="0" />
  <serverOption name="temp_file_limit" setting="-1" unit="kB" category="Resource Usage / Disk" short_desc="Limits the total size of all temporary files used by each process." extra_desc="-1 means no limit." context="superuser" vartype="integer" source="pg_settings" min_val="-1" max_val="2147483647" boot_val="-1" reset_val="-1" pending_restart="0" />
  <serverOption name="temp_tablespaces" setting="" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the tablespace(s) to use for temporary tables and sort files." context="user" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="TimeZone" setting="CET" category="Client Connection Defaults / Locale and Formatting" short_desc="Sets the time zone for displaying and interpreting time stamps." context="user" vartype="string" source="pg_settings" boot_val="GMT" reset_val="CET" sourcefile="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" sourceline="556" pending_restart="0" />
  <serverOption name="timezone_abbreviations" setting="Default" category="Client Connection Defaults / Locale and Formatting" short_desc="Selects a file of time zone abbreviations." context="user" vartype="string" source="pg_settings" reset_val="Default" pending_restart="0" />
  <serverOption name="trace_notify" setting="off" category="Developer Options" short_desc="Generates debugging output for LISTEN and NOTIFY." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="trace_recovery_messages" setting="log" category="Developer Options" short_desc="Enables logging of recovery-related debugging information." extra_desc="Each level includes all the levels that follow it. The later the level, the fewer messages are sent." context="sighup" vartype="enum" source="pg_settings" enumvals="{debug5,debug4,debug3,debug2,debug1,log,notice,warning,error}" boot_val="log" reset_val="log" pending_restart="0" />
  <serverOption name="trace_sort" setting="off" category="Developer Options" short_desc="Emit information about resource usage in sorting." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="track_activities" setting="on" category="Statistics / Query and Index Statistics Collector" short_desc="Collects information about executing commands." extra_desc="Enables the collection of information on the currently executing command of each session, along with the time at which that command began execution." context="superuser" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="track_activity_query_size" setting="1024" category="Resource Usage / Memory" short_desc="Sets the size reserved for pg_stat_activity.query, in bytes." context="postmaster" vartype="integer" source="pg_settings" min_val="100" max_val="102400" boot_val="1024" reset_val="1024" pending_restart="0" />
  <serverOption name="track_commit_timestamp" setting="off" category="Replication" short_desc="Collects transaction commit time." context="postmaster" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="track_counts" setting="on" category="Statistics / Query and Index Statistics Collector" short_desc="Collects statistics on database activity." context="superuser" vartype="bool" source="pg_settings" boot_val="on" reset_val="on" pending_restart="0" />
  <serverOption name="track_functions" setting="none" category="Statistics / Query and Index Statistics Collector" short_desc="Collects function-level statistics on database activity." context="superuser" vartype="enum" source="pg_settings" enumvals="{none,pl,all}" boot_val="none" reset_val="none" pending_restart="0" />
  <serverOption name="track_io_timing" setting="off" category="Statistics / Query and Index Statistics Collector" short_desc="Collects timing statistics for database I/O activity." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="transaction_deferrable" setting="off" category="Client Connection Defaults / Statement Behavior" short_desc="Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="transaction_isolation" setting="read committed" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the current transaction's isolation level." context="user" vartype="string" source="pg_settings" boot_val="default" reset_val="default" pending_restart="0" />
  <serverOption name="transaction_read_only" setting="off" category="Client Connection Defaults / Statement Behavior" short_desc="Sets the current transaction's read-only status." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="transform_null_equals" setting="off" category="Version and Platform Compatibility / Other Platforms and Clients" short_desc="Treats &quot;expr=NULL&quot; as &quot;expr IS NULL&quot;." extra_desc="When turned on, expressions of the form expr = NULL (or NULL = expr) are treated as expr IS NULL, that is, they return true if expr evaluates to the null value, and false otherwise. The correct behavior of expr = NULL is to always return null (unknown)." context="user" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="unix_socket_directories" setting="" category="Connections and Authentication / Connection Settings" short_desc="Sets the directories where Unix-domain sockets will be created." context="postmaster" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="unix_socket_group" setting="" category="Connections and Authentication / Connection Settings" short_desc="Sets the owning group of the Unix-domain socket." extra_desc="The owning user of the socket is always the user that starts the server." context="postmaster" vartype="string" source="pg_settings" boot_val="" reset_val="" pending_restart="0" />
  <serverOption name="unix_socket_permissions" setting="0777" category="Connections and Authentication / Connection Settings" short_desc="Sets the access permissions of the Unix-domain socket." extra_desc="Unix-domain sockets use the usual Unix file system permission set. The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format the number must start with a 0 (zero).)" context="postmaster" vartype="integer" source="pg_settings" min_val="0" max_val="511" boot_val="511" reset_val="511" pending_restart="0" />
  <serverOption name="update_process_title" setting="off" category="Process Title" short_desc="Updates the process title to show the active SQL command." extra_desc="Enables updating of the process title every time a new SQL command is received by the server." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="vacuum_cost_delay" setting="0" unit="ms" category="Resource Usage / Cost-Based Vacuum Delay" short_desc="Vacuum cost delay in milliseconds." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="100" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="vacuum_cost_limit" setting="200" category="Resource Usage / Cost-Based Vacuum Delay" short_desc="Vacuum cost amount available before napping." context="user" vartype="integer" source="pg_settings" min_val="1" max_val="10000" boot_val="200" reset_val="200" pending_restart="0" />
  <serverOption name="vacuum_cost_page_dirty" setting="20" category="Resource Usage / Cost-Based Vacuum Delay" short_desc="Vacuum cost for a page dirtied by vacuum." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="10000" boot_val="20" reset_val="20" pending_restart="0" />
  <serverOption name="vacuum_cost_page_hit" setting="1" category="Resource Usage / Cost-Based Vacuum Delay" short_desc="Vacuum cost for a page found in the buffer cache." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="10000" boot_val="1" reset_val="1" pending_restart="0" />
  <serverOption name="vacuum_cost_page_miss" setting="10" category="Resource Usage / Cost-Based Vacuum Delay" short_desc="Vacuum cost for a page not found in the buffer cache." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="10000" boot_val="10" reset_val="10" pending_restart="0" />
  <serverOption name="vacuum_defer_cleanup_age" setting="0" category="Replication / Master Server" short_desc="Number of transactions by which VACUUM and HOT cleanup should be deferred, if any." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="1000000" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="vacuum_freeze_min_age" setting="50000000" category="Client Connection Defaults / Statement Behavior" short_desc="Minimum age at which VACUUM should freeze a table row." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="1000000000" boot_val="50000000" reset_val="50000000" pending_restart="0" />
  <serverOption name="vacuum_freeze_table_age" setting="150000000" category="Client Connection Defaults / Statement Behavior" short_desc="Age at which VACUUM should scan whole table to freeze tuples." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2000000000" boot_val="150000000" reset_val="150000000" pending_restart="0" />
  <serverOption name="vacuum_multixact_freeze_min_age" setting="5000000" category="Client Connection Defaults / Statement Behavior" short_desc="Minimum age at which VACUUM should freeze a MultiXactId in a table row." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="1000000000" boot_val="5000000" reset_val="5000000" pending_restart="0" />
  <serverOption name="vacuum_multixact_freeze_table_age" setting="150000000" category="Client Connection Defaults / Statement Behavior" short_desc="Multixact age at which VACUUM should scan whole table to freeze tuples." context="user" vartype="integer" source="pg_settings" min_val="0" max_val="2000000000" boot_val="150000000" reset_val="150000000" pending_restart="0" />
  <serverOption name="wal_block_size" setting="8192" category="Preset Options" short_desc="Shows the block size in the write ahead log." context="internal" vartype="integer" source="pg_settings" min_val="8192" max_val="8192" boot_val="8192" reset_val="8192" pending_restart="0" />
  <serverOption name="wal_buffers" setting="512" unit="8kB" category="Write-Ahead Log / Settings" short_desc="Sets the number of disk-page buffers in shared memory for WAL." context="postmaster" vartype="integer" source="pg_settings" min_val="-1" max_val="262143" boot_val="-1" reset_val="512" pending_restart="0" />
  <serverOption name="wal_compression" setting="off" category="Write-Ahead Log / Settings" short_desc="Compresses full-page writes written in WAL file." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="wal_keep_segments" setting="0" category="Replication / Sending Servers" short_desc="Sets the number of WAL files held for standby servers." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="0" reset_val="0" pending_restart="0" />
  <serverOption name="wal_level" setting="minimal" category="Write-Ahead Log / Settings" short_desc="Set the level of information written to the WAL." context="postmaster" vartype="enum" source="pg_settings" enumvals="{minimal,replica,logical}" boot_val="minimal" reset_val="minimal" pending_restart="0" />
  <serverOption name="wal_log_hints" setting="off" category="Write-Ahead Log / Settings" short_desc="Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications." context="postmaster" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="wal_receiver_status_interval" setting="10" unit="s" category="Replication / Standby Servers" short_desc="Sets the maximum interval between WAL receiver status reports to the primary." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483" boot_val="10" reset_val="10" pending_restart="0" />
  <serverOption name="wal_receiver_timeout" setting="60000" unit="ms" category="Replication / Standby Servers" short_desc="Sets the maximum wait time to receive data from the primary." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="60000" reset_val="60000" pending_restart="0" />
  <serverOption name="wal_retrieve_retry_interval" setting="5000" unit="ms" category="Replication / Standby Servers" short_desc="Sets the time to wait before retrying to retrieve WAL after a failed attempt." context="sighup" vartype="integer" source="pg_settings" min_val="1" max_val="2147483647" boot_val="5000" reset_val="5000" pending_restart="0" />
  <serverOption name="wal_segment_size" setting="2048" unit="8kB" category="Preset Options" short_desc="Shows the number of pages per write ahead log segment." context="internal" vartype="integer" source="pg_settings" min_val="2048" max_val="2048" boot_val="2048" reset_val="2048" pending_restart="0" />
  <serverOption name="wal_sender_timeout" setting="60000" unit="ms" category="Replication / Sending Servers" short_desc="Sets the maximum time to wait for WAL replication." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="60000" reset_val="60000" pending_restart="0" />
  <serverOption name="wal_sync_method" setting="open_datasync" category="Write-Ahead Log / Settings" short_desc="Selects the method used for forcing WAL updates to disk." context="sighup" vartype="enum" source="pg_settings" enumvals="{fsync,fsync_writethrough,open_datasync}" boot_val="open_datasync" reset_val="open_datasync" pending_restart="0" />
  <serverOption name="wal_writer_delay" setting="200" unit="ms" category="Write-Ahead Log / Settings" short_desc="Time between WAL flushes performed in the WAL writer." context="sighup" vartype="integer" source="pg_settings" min_val="1" max_val="10000" boot_val="200" reset_val="200" pending_restart="0" />
  <serverOption name="wal_writer_flush_after" setting="128" unit="8kB" category="Write-Ahead Log / Settings" short_desc="Amount of WAL written out by WAL writer that triggers a flush." context="sighup" vartype="integer" source="pg_settings" min_val="0" max_val="2147483647" boot_val="128" reset_val="128" pending_restart="0" />
  <serverOption name="work_mem" setting="4096" unit="kB" category="Resource Usage / Memory" short_desc="Sets the maximum memory to be used for query workspaces." extra_desc="This much memory can be used by each internal sort operation and hash table before switching to temporary disk files." context="user" vartype="integer" source="pg_settings" min_val="64" max_val="2097151" boot_val="4096" reset_val="4096" pending_restart="0" />
  <serverOption name="xmlbinary" setting="base64" category="Client Connection Defaults / Statement Behavior" short_desc="Sets how binary values are to be encoded in XML." context="user" vartype="enum" source="pg_settings" enumvals="{base64,hex}" boot_val="base64" reset_val="base64" pending_restart="0" />
  <serverOption name="xmloption" setting="content" category="Client Connection Defaults / Statement Behavior" short_desc="Sets whether XML data in implicit parsing and serialization operations is to be considered as documents or content fragments." context="user" vartype="enum" source="pg_settings" enumvals="{content,document}" boot_val="content" reset_val="content" pending_restart="0" />
  <serverOption name="zero_damaged_pages" setting="off" category="Developer Options" short_desc="Continues processing past damaged page headers." extra_desc="Detection of a damaged page header normally causes PostgreSQL to report an error, aborting the current transaction. Setting zero_damaged_pages to true causes the system to instead report a warning, zero out the damaged page, and continue processing. This behavior will destroy data, namely all the rows on the damaged page." context="superuser" vartype="bool" source="pg_settings" boot_val="off" reset_val="off" pending_restart="0" />
  <serverOption name="allow_system_table_mods" setting="off" description="Allows modifications of the structure of system tables." source="show all" />
  <serverOption name="application_name" setting="" description="Sets the application name to be reported in statistics and logs." source="show all" />
  <serverOption name="archive_command" setting="(disabled)" description="Sets the shell command that will be called to archive a WAL file." source="show all" />
  <serverOption name="archive_mode" setting="off" description="Allows archiving of WAL files using archive_command." source="show all" />
  <serverOption name="archive_timeout" setting="0" description="Forces a switch to the next xlog file if a new file has not been started within N seconds." source="show all" />
  <serverOption name="array_nulls" setting="on" description="Enable input of NULL elements in arrays." source="show all" />
  <serverOption name="authentication_timeout" setting="1min" description="Sets the maximum allowed time to complete client authentication." source="show all" />
  <serverOption name="autovacuum" setting="on" description="Starts the autovacuum subprocess." source="show all" />
  <serverOption name="autovacuum_analyze_scale_factor" setting="0.1" description="Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples." source="show all" />
  <serverOption name="autovacuum_analyze_threshold" setting="50" description="Minimum number of tuple inserts, updates, or deletes prior to analyze." source="show all" />
  <serverOption name="autovacuum_freeze_max_age" setting="200000000" description="Age at which to autovacuum a table to prevent transaction ID wraparound." source="show all" />
  <serverOption name="autovacuum_max_workers" setting="3" description="Sets the maximum number of simultaneously running autovacuum worker processes." source="show all" />
  <serverOption name="autovacuum_multixact_freeze_max_age" setting="400000000" description="Multixact age at which to autovacuum a table to prevent multixact wraparound." source="show all" />
  <serverOption name="autovacuum_naptime" setting="1min" description="Time to sleep between autovacuum runs." source="show all" />
  <serverOption name="autovacuum_vacuum_cost_delay" setting="20ms" description="Vacuum cost delay in milliseconds, for autovacuum." source="show all" />
  <serverOption name="autovacuum_vacuum_cost_limit" setting="-1" description="Vacuum cost amount available before napping, for autovacuum." source="show all" />
  <serverOption name="autovacuum_vacuum_scale_factor" setting="0.2" description="Number of tuple updates or deletes prior to vacuum as a fraction of reltuples." source="show all" />
  <serverOption name="autovacuum_vacuum_threshold" setting="50" description="Minimum number of tuple updates or deletes prior to vacuum." source="show all" />
  <serverOption name="autovacuum_work_mem" setting="-1" description="Sets the maximum memory to be used by each autovacuum worker process." source="show all" />
  <serverOption name="backend_flush_after" setting="0" description="Number of pages after which previously performed writes are flushed to disk." source="show all" />
  <serverOption name="backslash_quote" setting="safe_encoding" description="Sets whether &quot;\'&quot; is allowed in string literals." source="show all" />
  <serverOption name="bgwriter_delay" setting="200ms" description="Background writer sleep time between rounds." source="show all" />
  <serverOption name="bgwriter_flush_after" setting="0" description="Number of pages after which previously performed writes are flushed to disk." source="show all" />
  <serverOption name="bgwriter_lru_maxpages" setting="100" description="Background writer maximum number of LRU pages to flush per round." source="show all" />
  <serverOption name="bgwriter_lru_multiplier" setting="2" description="Multiple of the average buffer usage to free per round." source="show all" />
  <serverOption name="block_size" setting="8192" description="Shows the size of a disk block." source="show all" />
  <serverOption name="bonjour" setting="off" description="Enables advertising the server via Bonjour." source="show all" />
  <serverOption name="bonjour_name" setting="" description="Sets the Bonjour service name." source="show all" />
  <serverOption name="bytea_output" setting="hex" description="Sets the output format for bytea." source="show all" />
  <serverOption name="check_function_bodies" setting="on" description="Check function bodies during CREATE FUNCTION." source="show all" />
  <serverOption name="checkpoint_completion_target" setting="0.5" description="Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval." source="show all" />
  <serverOption name="checkpoint_flush_after" setting="0" description="Number of pages after which previously performed writes are flushed to disk." source="show all" />
  <serverOption name="checkpoint_timeout" setting="5min" description="Sets the maximum time between automatic WAL checkpoints." source="show all" />
  <serverOption name="checkpoint_warning" setting="30s" description="Enables warnings if checkpoint segments are filled more frequently than this." source="show all" />
  <serverOption name="client_encoding" setting="WIN1252" description="Sets the client's character set encoding." source="show all" />
  <serverOption name="client_min_messages" setting="notice" description="Sets the message levels that are sent to the client." source="show all" />
  <serverOption name="cluster_name" setting="" description="Sets the name of the cluster, which is included in the process title." source="show all" />
  <serverOption name="commit_delay" setting="0" description="Sets the delay in microseconds between transaction commit and flushing WAL to disk." source="show all" />
  <serverOption name="commit_siblings" setting="5" description="Sets the minimum concurrent open transactions before performing commit_delay." source="show all" />
  <serverOption name="config_file" setting="C:/Program Files/PostgreSQL/9.6/data/postgresql.conf" description="Sets the server's main configuration file." source="show all" />
  <serverOption name="constraint_exclusion" setting="partition" description="Enables the planner to use constraints to optimize queries." source="show all" />
  <serverOption name="cpu_index_tuple_cost" setting="0.005" description="Sets the planner's estimate of the cost of processing each index entry during an index scan." source="show all" />
  <serverOption name="cpu_operator_cost" setting="0.0025" description="Sets the planner's estimate of the cost of processing each operator or function call." source="show all" />
  <serverOption name="cpu_tuple_cost" setting="0.01" description="Sets the planner's estimate of the cost of processing each tuple (row)." source="show all" />
  <serverOption name="cursor_tuple_fraction" setting="0.1" description="Sets the planner's estimate of the fraction of a cursor's rows that will be retrieved." source="show all" />
  <serverOption name="data_checksums" setting="off" description="Shows whether data checksums are turned on for this cluster." source="show all" />
  <serverOption name="data_directory" setting="C:/Program Files/PostgreSQL/9.6/data" description="Sets the server's data directory." source="show all" />
  <serverOption name="DateStyle" setting="ISO, DMY" description="Sets the display format for date and time values." source="show all" />
  <serverOption name="db_user_namespace" setting="off" description="Enables per-database user names." source="show all" />
  <serverOption name="deadlock_timeout" setting="1s" description="Sets the time to wait on a lock before checking for deadlock." source="show all" />
  <serverOption name="debug_assertions" setting="off" description="Shows whether the running server has assertion checks enabled." source="show all" />
  <serverOption name="debug_pretty_print" setting="on" description="Indents parse and plan tree displays." source="show all" />
  <serverOption name="debug_print_parse" setting="off" description="Logs each query's parse tree." source="show all" />
  <serverOption name="debug_print_plan" setting="off" description="Logs each query's execution plan." source="show all" />
  <serverOption name="debug_print_rewritten" setting="off" description="Logs each query's rewritten parse tree." source="show all" />
  <serverOption name="default_statistics_target" setting="100" description="Sets the default statistics target." source="show all" />
  <serverOption name="default_tablespace" setting="" description="Sets the default tablespace to create tables and indexes in." source="show all" />
  <serverOption name="default_text_search_config" setting="pg_catalog.german" description="Sets default text search configuration." source="show all" />
  <serverOption name="default_transaction_deferrable" setting="off" description="Sets the default deferrable status of new transactions." source="show all" />
  <serverOption name="default_transaction_isolation" setting="read committed" description="Sets the transaction isolation level of each new transaction." source="show all" />
  <serverOption name="default_transaction_read_only" setting="off" description="Sets the default read-only status of new transactions." source="show all" />
  <serverOption name="default_with_oids" setting="off" description="Create new tables with OIDs by default." source="show all" />
  <serverOption name="dynamic_library_path" setting="$libdir" description="Sets the path for dynamically loadable modules." source="show all" />
  <serverOption name="dynamic_shared_memory_type" setting="windows" description="Selects the dynamic shared memory implementation used." source="show all" />
  <serverOption name="effective_cache_size" setting="4GB" description="Sets the planner's assumption about the size of the disk cache." source="show all" />
  <serverOption name="effective_io_concurrency" setting="0" description="Number of simultaneous requests that can be handled efficiently by the disk subsystem." source="show all" />
  <serverOption name="enable_bitmapscan" setting="on" description="Enables the planner's use of bitmap-scan plans." source="show all" />
  <serverOption name="enable_hashagg" setting="on" description="Enables the planner's use of hashed aggregation plans." source="show all" />
  <serverOption name="enable_hashjoin" setting="on" description="Enables the planner's use of hash join plans." source="show all" />
  <serverOption name="enable_indexonlyscan" setting="on" description="Enables the planner's use of index-only-scan plans." source="show all" />
  <serverOption name="enable_indexscan" setting="on" description="Enables the planner's use of index-scan plans." source="show all" />
  <serverOption name="enable_material" setting="on" description="Enables the planner's use of materialization." source="show all" />
  <serverOption name="enable_mergejoin" setting="on" description="Enables the planner's use of merge join plans." source="show all" />
  <serverOption name="enable_nestloop" setting="on" description="Enables the planner's use of nested-loop join plans." source="show all" />
  <serverOption name="enable_seqscan" setting="on" description="Enables the planner's use of sequential-scan plans." source="show all" />
  <serverOption name="enable_sort" setting="on" description="Enables the planner's use of explicit sort steps." source="show all" />
  <serverOption name="enable_tidscan" setting="on" description="Enables the planner's use of TID scan plans." source="show all" />
  <serverOption name="escape_string_warning" setting="on" description="Warn about backslash escapes in ordinary string literals." source="show all" />
  <serverOption name="event_source" setting="PostgreSQL" description="Sets the application name used to identify PostgreSQL messages in the event log." source="show all" />
  <serverOption name="exit_on_error" setting="off" description="Terminate session on any error." source="show all" />
  <serverOption name="external_pid_file" setting="" description="Writes the postmaster PID to the specified file." source="show all" />
  <serverOption name="extra_float_digits" setting="2" description="Sets the number of digits displayed for floating-point values." source="show all" />
  <serverOption name="force_parallel_mode" setting="off" description="Forces use of parallel query facilities." source="show all" />
  <serverOption name="from_collapse_limit" setting="8" description="Sets the FROM-list size beyond which subqueries are not collapsed." source="show all" />
  <serverOption name="fsync" setting="on" description="Forces synchronization of updates to disk." source="show all" />
  <serverOption name="full_page_writes" setting="on" description="Writes full pages to WAL when first modified after a checkpoint." source="show all" />
  <serverOption name="geqo" setting="on" description="Enables genetic query optimization." source="show all" />
  <serverOption name="geqo_effort" setting="5" description="GEQO: effort is used to set the default for other GEQO parameters." source="show all" />
  <serverOption name="geqo_generations" setting="0" description="GEQO: number of iterations of the algorithm." source="show all" />
  <serverOption name="geqo_pool_size" setting="0" description="GEQO: number of individuals in the population." source="show all" />
  <serverOption name="geqo_seed" setting="0" description="GEQO: seed for random path selection." source="show all" />
  <serverOption name="geqo_selection_bias" setting="2" description="GEQO: selective pressure within the population." source="show all" />
  <serverOption name="geqo_threshold" setting="12" description="Sets the threshold of FROM items beyond which GEQO is used." source="show all" />
  <serverOption name="gin_fuzzy_search_limit" setting="0" description="Sets the maximum allowed result for exact search by GIN." source="show all" />
  <serverOption name="gin_pending_list_limit" setting="4MB" description="Sets the maximum size of the pending list for GIN index." source="show all" />
  <serverOption name="hba_file" setting="C:/Program Files/PostgreSQL/9.6/data/pg_hba.conf" description="Sets the server's &quot;hba&quot; configuration file." source="show all" />
  <serverOption name="hot_standby" setting="off" description="Allows connections and queries during recovery." source="show all" />
  <serverOption name="hot_standby_feedback" setting="off" description="Allows feedback from a hot standby to the primary that will avoid query conflicts." source="show all" />
  <serverOption name="huge_pages" setting="try" description="Use of huge pages on Linux." source="show all" />
  <serverOption name="ident_file" setting="C:/Program Files/PostgreSQL/9.6/data/pg_ident.conf" description="Sets the server's &quot;ident&quot; configuration file." source="show all" />
  <serverOption name="idle_in_transaction_session_timeout" setting="0" description="Sets the maximum allowed duration of any idling transaction." source="show all" />
  <serverOption name="ignore_checksum_failure" setting="off" description="Continues processing after a checksum failure." source="show all" />
  <serverOption name="ignore_system_indexes" setting="off" description="Disables reading from system indexes." source="show all" />
  <serverOption name="integer_datetimes" setting="on" description="Datetimes are integer based." source="show all" />
  <serverOption name="IntervalStyle" setting="postgres" description="Sets the display format for interval values." source="show all" />
  <serverOption name="join_collapse_limit" setting="8" description="Sets the FROM-list size beyond which JOIN constructs are not flattened." source="show all" />
  <serverOption name="krb_caseins_users" setting="off" description="Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive." source="show all" />
  <serverOption name="krb_server_keyfile" setting="" description="Sets the location of the Kerberos server key file." source="show all" />
  <serverOption name="lc_collate" setting="German_Germany.1252" description="Shows the collation order locale." source="show all" />
  <serverOption name="lc_ctype" setting="German_Germany.1252" description="Shows the character classification and case conversion locale." source="show all" />
  <serverOption name="lc_messages" setting="German_Germany.1252" description="Sets the language in which messages are displayed." source="show all" />
  <serverOption name="lc_monetary" setting="German_Germany.1252" description="Sets the locale for formatting monetary amounts." source="show all" />
  <serverOption name="lc_numeric" setting="German_Germany.1252" description="Sets the locale for formatting numbers." source="show all" />
  <serverOption name="lc_time" setting="German_Germany.1252" description="Sets the locale for formatting date and time values." source="show all" />
  <serverOption name="listen_addresses" setting="*" description="Sets the host name or IP address(es) to listen to." source="show all" />
  <serverOption name="lo_compat_privileges" setting="off" description="Enables backward compatibility mode for privilege checks on large objects." source="show all" />
  <serverOption name="local_preload_libraries" setting="" description="Lists unprivileged shared libraries to preload into each backend." source="show all" />
  <serverOption name="lock_timeout" setting="0" description="Sets the maximum allowed duration of any wait for a lock." source="show all" />
  <serverOption name="log_autovacuum_min_duration" setting="-1" description="Sets the minimum execution time above which autovacuum actions will be logged." source="show all" />
  <serverOption name="log_checkpoints" setting="off" description="Logs each checkpoint." source="show all" />
  <serverOption name="log_connections" setting="off" description="Logs each successful connection." source="show all" />
  <serverOption name="log_destination" setting="stderr" description="Sets the destination for server log output." source="show all" />
  <serverOption name="log_directory" setting="pg_log" description="Sets the destination directory for log files." source="show all" />
  <serverOption name="log_disconnections" setting="off" description="Logs end of a session, including duration." source="show all" />
  <serverOption name="log_duration" setting="off" description="Logs the duration of each completed SQL statement." source="show all" />
  <serverOption name="log_error_verbosity" setting="default" description="Sets the verbosity of logged messages." source="show all" />
  <serverOption name="log_executor_stats" setting="off" description="Writes executor performance statistics to the server log." source="show all" />
  <serverOption name="log_file_mode" setting="0600" description="Sets the file permissions for log files." source="show all" />
  <serverOption name="log_filename" setting="postgresql-%Y-%m-%d_%H%M%S.log" description="Sets the file name pattern for log files." source="show all" />
  <serverOption name="log_hostname" setting="off" description="Logs the host name in the connection logs." source="show all" />
  <serverOption name="log_line_prefix" setting="%t" description="Controls information prefixed to each log line." source="show all" />
  <serverOption name="log_lock_waits" setting="off" description="Logs long lock waits." source="show all" />
  <serverOption name="log_min_duration_statement" setting="-1" description="Sets the minimum execution time above which statements will be logged." source="show all" />
  <serverOption name="log_min_error_statement" setting="error" description="Causes all statements generating error at or above this level to be logged." source="show all" />
  <serverOption name="log_min_messages" setting="warning" description="Sets the message levels that are logged." source="show all" />
  <serverOption name="log_parser_stats" setting="off" description="Writes parser performance statistics to the server log." source="show all" />
  <serverOption name="log_planner_stats" setting="off" description="Writes planner performance statistics to the server log." source="show all" />
  <serverOption name="log_replication_commands" setting="off" description="Logs each replication command." source="show all" />
  <serverOption name="log_rotation_age" setting="1d" description="Automatic log file rotation will occur after N minutes." source="show all" />
  <serverOption name="log_rotation_size" setting="10MB" description="Automatic log file rotation will occur after N kilobytes." source="show all" />
  <serverOption name="log_statement" setting="none" description="Sets the type of statements logged." source="show all" />
  <serverOption name="log_statement_stats" setting="off" description="Writes cumulative performance statistics to the server log." source="show all" />
  <serverOption name="log_temp_files" setting="-1" description="Log the use of temporary files larger than this number of kilobytes." source="show all" />
  <serverOption name="log_timezone" setting="CET" description="Sets the time zone to use in log messages." source="show all" />
  <serverOption name="log_truncate_on_rotation" setting="off" description="Truncate existing log files of same name during log rotation." source="show all" />
  <serverOption name="logging_collector" setting="on" description="Start a subprocess to capture stderr output and/or csvlogs into log files." source="show all" />
  <serverOption name="maintenance_work_mem" setting="64MB" description="Sets the maximum memory to be used for maintenance operations." source="show all" />
  <serverOption name="max_connections" setting="100" description="Sets the maximum number of concurrent connections." source="show all" />
  <serverOption name="max_files_per_process" setting="1000" description="Sets the maximum number of simultaneously open files for each server process." source="show all" />
  <serverOption name="max_function_args" setting="100" description="Shows the maximum number of function arguments." source="show all" />
  <serverOption name="max_identifier_length" setting="63" description="Shows the maximum identifier length." source="show all" />
  <serverOption name="max_index_keys" setting="32" description="Shows the maximum number of index keys." source="show all" />
  <serverOption name="max_locks_per_transaction" setting="64" description="Sets the maximum number of locks per transaction." source="show all" />
  <serverOption name="max_parallel_workers_per_gather" setting="0" description="Sets the maximum number of parallel processes per executor node." source="show all" />
  <serverOption name="max_pred_locks_per_transaction" setting="64" description="Sets the maximum number of predicate locks per transaction." source="show all" />
  <serverOption name="max_prepared_transactions" setting="0" description="Sets the maximum number of simultaneously prepared transactions." source="show all" />
  <serverOption name="max_replication_slots" setting="0" description="Sets the maximum number of simultaneously defined replication slots." source="show all" />
  <serverOption name="max_stack_depth" setting="2MB" description="Sets the maximum stack depth, in kilobytes." source="show all" />
  <serverOption name="max_standby_archive_delay" setting="30s" description="Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data." source="show all" />
  <serverOption name="max_standby_streaming_delay" setting="30s" description="Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data." source="show all" />
  <serverOption name="max_wal_senders" setting="0" description="Sets the maximum number of simultaneously running WAL sender processes." source="show all" />
  <serverOption name="max_wal_size" setting="1GB" description="Sets the WAL size that triggers a checkpoint." source="show all" />
  <serverOption name="max_worker_processes" setting="8" description="Maximum number of concurrent worker processes." source="show all" />
  <serverOption name="min_parallel_relation_size" setting="8MB" description="Sets the minimum size of relations to be considered for parallel scan." source="show all" />
  <serverOption name="min_wal_size" setting="80MB" description="Sets the minimum size to shrink the WAL to." source="show all" />
  <serverOption name="old_snapshot_threshold" setting="-1" description="Time before a snapshot is too old to read pages changed after the snapshot was taken." source="show all" />
  <serverOption name="operator_precedence_warning" setting="off" description="Emit a warning for constructs that changed meaning since PostgreSQL 9.4." source="show all" />
  <serverOption name="parallel_setup_cost" setting="1000" description="Sets the planner's estimate of the cost of starting up worker processes for parallel query." source="show all" />
  <serverOption name="parallel_tuple_cost" setting="0.1" description="Sets the planner's estimate of the cost of passing each tuple (row) from worker to master backend." source="show all" />
  <serverOption name="password_encryption" setting="on" description="Encrypt passwords." source="show all" />
  <serverOption name="port" setting="5432" description="Sets the TCP port the server listens on." source="show all" />
  <serverOption name="post_auth_delay" setting="0" description="Waits N seconds on connection startup after authentication." source="show all" />
  <serverOption name="pre_auth_delay" setting="0" description="Waits N seconds on connection startup before authentication." source="show all" />
  <serverOption name="quote_all_identifiers" setting="off" description="When generating SQL fragments, quote all identifiers." source="show all" />
  <serverOption name="random_page_cost" setting="4" description="Sets the planner's estimate of the cost of a nonsequentially fetched disk page." source="show all" />
  <serverOption name="replacement_sort_tuples" setting="150000" description="Sets the maximum number of tuples to be sorted using replacement selection." source="show all" />
  <serverOption name="restart_after_crash" setting="on" description="Reinitialize server after backend crash." source="show all" />
  <serverOption name="row_security" setting="on" description="Enable row security." source="show all" />
  <serverOption name="search_path" setting="&quot;$user&quot;, public" description="Sets the schema search order for names that are not schema-qualified." source="show all" />
  <serverOption name="segment_size" setting="1GB" description="Shows the number of pages per disk file." source="show all" />
  <serverOption name="seq_page_cost" setting="1" description="Sets the planner's estimate of the cost of a sequentially fetched disk page." source="show all" />
  <serverOption name="server_encoding" setting="UTF8" description="Sets the server (database) character set encoding." source="show all" />
  <serverOption name="server_version" setting="9.6.2" description="Shows the server version." source="show all" />
  <serverOption name="server_version_num" setting="90602" description="Shows the server version as an integer." source="show all" />
  <serverOption name="session_preload_libraries" setting="" description="Lists shared libraries to preload into each backend." source="show all" />
  <serverOption name="session_replication_role" setting="origin" description="Sets the session's behavior for triggers and rewrite rules." source="show all" />
  <serverOption name="shared_buffers" setting="128MB" description="Sets the number of shared memory buffers used by the server." source="show all" />
  <serverOption name="shared_preload_libraries" setting="" description="Lists shared libraries to preload into server." source="show all" />
  <serverOption name="sql_inheritance" setting="on" description="Causes subtables to be included by default in various commands." source="show all" />
  <serverOption name="ssl" setting="off" description="Enables SSL connections." source="show all" />
  <serverOption name="ssl_ca_file" setting="" description="Location of the SSL certificate authority file." source="show all" />
  <serverOption name="ssl_cert_file" setting="server.crt" description="Location of the SSL server certificate file." source="show all" />
  <serverOption name="ssl_ciphers" setting="HIGH:MEDIUM:+3DES:!aNULL" description="Sets the list of allowed SSL ciphers." source="show all" />
  <serverOption name="ssl_crl_file" setting="" description="Location of the SSL certificate revocation list file." source="show all" />
  <serverOption name="ssl_ecdh_curve" setting="prime256v1" description="Sets the curve to use for ECDH." source="show all" />
  <serverOption name="ssl_key_file" setting="server.key" description="Location of the SSL server private key file." source="show all" />
  <serverOption name="ssl_prefer_server_ciphers" setting="on" description="Give priority to server ciphersuite order." source="show all" />
  <serverOption name="standard_conforming_strings" setting="on" description="Causes '...' strings to treat backslashes literally." source="show all" />
  <serverOption name="statement_timeout" setting="1min" description="Sets the maximum allowed duration of any statement." source="show all" />
  <serverOption name="stats_temp_directory" setting="pg_stat_tmp" description="Writes temporary statistics files to the specified directory." source="show all" />
  <serverOption name="superuser_reserved_connections" setting="3" description="Sets the number of connection slots reserved for superusers." source="show all" />
  <serverOption name="synchronize_seqscans" setting="on" description="Enable synchronized sequential scans." source="show all" />
  <serverOption name="synchronous_commit" setting="on" description="Sets the current transaction's synchronization level." source="show all" />
  <serverOption name="synchronous_standby_names" setting="" description="Number of synchronous standbys and list of names of potential synchronous ones." source="show all" />
  <serverOption name="syslog_facility" setting="none" description="Sets the syslog &quot;facility&quot; to be used when syslog enabled." source="show all" />
  <serverOption name="syslog_ident" setting="postgres" description="Sets the program name used to identify PostgreSQL messages in syslog." source="show all" />
  <serverOption name="syslog_sequence_numbers" setting="on" description="Add sequence number to syslog messages to avoid duplicate suppression." source="show all" />
  <serverOption name="syslog_split_messages" setting="on" description="Split messages sent to syslog by lines and to fit into 1024 bytes." source="show all" />
  <serverOption name="tcp_keepalives_count" setting="0" description="Maximum number of TCP keepalive retransmits." source="show all" />
  <serverOption name="tcp_keepalives_idle" setting="-1" description="Time between issuing TCP keepalives." source="show all" />
  <serverOption name="tcp_keepalives_interval" setting="-1" description="Time between TCP keepalive retransmits." source="show all" />
  <serverOption name="temp_buffers" setting="8MB" description="Sets the maximum number of temporary buffers used by each session." source="show all" />
  <serverOption name="temp_file_limit" setting="-1" description="Limits the total size of all temporary files used by each process." source="show all" />
  <serverOption name="temp_tablespaces" setting="" description="Sets the tablespace(s) to use for temporary tables and sort files." source="show all" />
  <serverOption name="TimeZone" setting="CET" description="Sets the time zone for displaying and interpreting time stamps." source="show all" />
  <serverOption name="timezone_abbreviations" setting="Default" description="Selects a file of time zone abbreviations." source="show all" />
  <serverOption name="trace_notify" setting="off" description="Generates debugging output for LISTEN and NOTIFY." source="show all" />
  <serverOption name="trace_recovery_messages" setting="log" description="Enables logging of recovery-related debugging information." source="show all" />
  <serverOption name="trace_sort" setting="off" description="Emit information about resource usage in sorting." source="show all" />
  <serverOption name="track_activities" setting="on" description="Collects information about executing commands." source="show all" />
  <serverOption name="track_activity_query_size" setting="1024" description="Sets the size reserved for pg_stat_activity.query, in bytes." source="show all" />
  <serverOption name="track_commit_timestamp" setting="off" description="Collects transaction commit time." source="show all" />
  <serverOption name="track_counts" setting="on" description="Collects statistics on database activity." source="show all" />
  <serverOption name="track_functions" setting="none" description="Collects function-level statistics on database activity." source="show all" />
  <serverOption name="track_io_timing" setting="off" description="Collects timing statistics for database I/O activity." source="show all" />
  <serverOption name="transaction_deferrable" setting="off" description="Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures." source="show all" />
  <serverOption name="transaction_isolation" setting="read committed" description="Sets the current transaction's isolation level." source="show all" />
  <serverOption name="transaction_read_only" setting="off" description="Sets the current transaction's read-only status." source="show all" />
  <serverOption name="transform_null_equals" setting="off" description="Treats &quot;expr=NULL&quot; as &quot;expr IS NULL&quot;." source="show all" />
  <serverOption name="unix_socket_directories" setting="" description="Sets the directories where Unix-domain sockets will be created." source="show all" />
  <serverOption name="unix_socket_group" setting="" description="Sets the owning group of the Unix-domain socket." source="show all" />
  <serverOption name="unix_socket_permissions" setting="0777" description="Sets the access permissions of the Unix-domain socket." source="show all" />
  <serverOption name="update_process_title" setting="off" description="Updates the process title to show the active SQL command." source="show all" />
  <serverOption name="vacuum_cost_delay" setting="0" description="Vacuum cost delay in milliseconds." source="show all" />
  <serverOption name="vacuum_cost_limit" setting="200" description="Vacuum cost amount available before napping." source="show all" />
  <serverOption name="vacuum_cost_page_dirty" setting="20" description="Vacuum cost for a page dirtied by vacuum." source="show all" />
  <serverOption name="vacuum_cost_page_hit" setting="1" description="Vacuum cost for a page found in the buffer cache." source="show all" />
  <serverOption name="vacuum_cost_page_miss" setting="10" description="Vacuum cost for a page not found in the buffer cache." source="show all" />
  <serverOption name="vacuum_defer_cleanup_age" setting="0" description="Number of transactions by which VACUUM and HOT cleanup should be deferred, if any." source="show all" />
  <serverOption name="vacuum_freeze_min_age" setting="50000000" description="Minimum age at which VACUUM should freeze a table row." source="show all" />
  <serverOption name="vacuum_freeze_table_age" setting="150000000" description="Age at which VACUUM should scan whole table to freeze tuples." source="show all" />
  <serverOption name="vacuum_multixact_freeze_min_age" setting="5000000" description="Minimum age at which VACUUM should freeze a MultiXactId in a table row." source="show all" />
  <serverOption name="vacuum_multixact_freeze_table_age" setting="150000000" description="Multixact age at which VACUUM should scan whole table to freeze tuples." source="show all" />
  <serverOption name="wal_block_size" setting="8192" description="Shows the block size in the write ahead log." source="show all" />
  <serverOption name="wal_buffers" setting="4MB" description="Sets the number of disk-page buffers in shared memory for WAL." source="show all" />
  <serverOption name="wal_compression" setting="off" description="Compresses full-page writes written in WAL file." source="show all" />
  <serverOption name="wal_keep_segments" setting="0" description="Sets the number of WAL files held for standby servers." source="show all" />
  <serverOption name="wal_level" setting="minimal" description="Set the level of information written to the WAL." source="show all" />
  <serverOption name="wal_log_hints" setting="off" description="Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications." source="show all" />
  <serverOption name="wal_receiver_status_interval" setting="10s" description="Sets the maximum interval between WAL receiver status reports to the primary." source="show all" />
  <serverOption name="wal_receiver_timeout" setting="1min" description="Sets the maximum wait time to receive data from the primary." source="show all" />
  <serverOption name="wal_retrieve_retry_interval" setting="5s" description="Sets the time to wait before retrying to retrieve WAL after a failed attempt." source="show all" />
  <serverOption name="wal_segment_size" setting="16MB" description="Shows the number of pages per write ahead log segment." source="show all" />
  <serverOption name="wal_sender_timeout" setting="1min" description="Sets the maximum time to wait for WAL replication." source="show all" />
  <serverOption name="wal_sync_method" setting="open_datasync" description="Selects the method used for forcing WAL updates to disk." source="show all" />
  <serverOption name="wal_writer_delay" setting="200ms" description="Time between WAL flushes performed in the WAL writer." source="show all" />
  <serverOption name="wal_writer_flush_after" setting="1MB" description="Amount of WAL written out by WAL writer that triggers a flush." source="show all" />
  <serverOption name="work_mem" setting="4MB" description="Sets the maximum memory to be used for query workspaces." source="show all" />
  <serverOption name="xmlbinary" setting="base64" description="Sets how binary values are to be encoded in XML." source="show all" />
  <serverOption name="xmloption" setting="content" description="Sets whether XML data in implicit parsing and serialization operations is to be considered as documents or content fragments." source="show all" />
  <serverOption name="zero_damaged_pages" setting="off" description="Continues processing past damaged page headers." source="show all" />
  <package feature_id="PKG000" feature_name="Core" is_supported="NO" comments="" />
  <package feature_id="PKG001" feature_name="Enhanced datetime facilities" is_supported="YES" comments="" />
  <package feature_id="PKG002" feature_name="Enhanced integrity management" is_supported="NO" comments="" />
  <package feature_id="PKG003" feature_name="OLAP facilities" is_supported="NO" comments="" />
  <package feature_id="PKG004" feature_name="PSM" is_supported="NO" comments="PL/pgSQL is similar." />
  <package feature_id="PKG005" feature_name="CLI" is_supported="NO" comments="ODBC is similar." />
  <package feature_id="PKG006" feature_name="Basic object support" is_supported="NO" comments="" />
  <package feature_id="PKG007" feature_name="Enhanced object support" is_supported="NO" comments="" />
  <package feature_id="PKG008" feature_name="Active database" is_supported="NO" comments="" />
  <package feature_id="PKG010" feature_name="OLAP" is_supported="NO" comments="NO" />
  <sizing sizing_id="97" sizing_name="MAXIMUM COLUMNS IN GROUP BY" supported_value="0" />
  <sizing sizing_id="99" sizing_name="MAXIMUM COLUMNS IN ORDER BY" supported_value="0" />
  <sizing sizing_id="100" sizing_name="MAXIMUM COLUMNS IN SELECT" supported_value="1664" />
  <sizing sizing_id="101" sizing_name="MAXIMUM COLUMNS IN TABLE" supported_value="1600" />
  <sizing sizing_id="1" sizing_name="MAXIMUM CONCURRENT ACTIVITIES" supported_value="0" />
  <sizing sizing_id="0" sizing_name="MAXIMUM DRIVER CONNECTIONS" />
  <sizing sizing_id="20000" sizing_name="MAXIMUM STATEMENT OCTETS" supported_value="0" />
  <sizing sizing_id="20001" sizing_name="MAXIMUM STATEMENT OCTETS DATA" supported_value="0" />
  <sizing sizing_id="20002" sizing_name="MAXIMUM STATEMENT OCTETS SCHEMA" supported_value="0" />
  <sizing sizing_id="106" sizing_name="MAXIMUM TABLES IN SELECT" supported_value="0" />
  <sizing sizing_id="25000" sizing_name="MAXIMUM CURRENT DEFAULT TRANSFORM GROUP LENGTH" />
  <sizing sizing_id="25001" sizing_name="MAXIMUM CURRENT TRANSFORM GROUP LENGTH" />
  <sizing sizing_id="25002" sizing_name="MAXIMUM CURRENT PATH LENGTH" supported_value="0" />
  <sizing sizing_id="25003" sizing_name="MAXIMUM CURRENT ROLE LENGTH" />
  <sizing sizing_id="34" sizing_name="MAXIMUM CATALOG NAME LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="30" sizing_name="MAXIMUM COLUMN NAME LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="31" sizing_name="MAXIMUM CURSOR NAME LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="10005" sizing_name="MAXIMUM IDENTIFIER LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="32" sizing_name="MAXIMUM SCHEMA NAME LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="35" sizing_name="MAXIMUM TABLE NAME LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="107" sizing_name="MAXIMUM USER NAME LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="25004" sizing_name="MAXIMUM SESSION USER LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <sizing sizing_id="25005" sizing_name="MAXIMUM SYSTEM USER LENGTH" supported_value="63" comments="Might be less, depending on character set." />
  <implementation implementation_info_id="10003" implementation_info_name="CATALOG NAME" character_value="Y" />
  <implementation implementation_info_id="10004" implementation_info_name="COLLATING SEQUENCE" />
  <implementation implementation_info_id="23" implementation_info_name="CURSOR COMMIT BEHAVIOR" integer_value="1" comments="close cursors and retain prepared statements" />
  <implementation implementation_info_id="2" implementation_info_name="DATA SOURCE NAME" character_value="" />
  <implementation implementation_info_id="17" implementation_info_name="DBMS NAME" character_value="PostgreSQL" />
  <implementation implementation_info_id="26" implementation_info_name="DEFAULT TRANSACTION ISOLATION" integer_value="2" comments="READ COMMITTED; user-settable" />
  <implementation implementation_info_id="28" implementation_info_name="IDENTIFIER CASE" integer_value="3" comments="stored in mixed case - case sensitive" />
  <implementation implementation_info_id="85" implementation_info_name="NULL COLLATION" integer_value="0" comments="nulls higher than non-nulls" />
  <implementation implementation_info_id="13" implementation_info_name="SERVER NAME" character_value="" />
  <implementation implementation_info_id="94" implementation_info_name="SPECIAL CHARACTERS" character_value="" comments="all non-ASCII characters allowed" />
  <implementation implementation_info_id="46" implementation_info_name="TRANSACTION CAPABLE" integer_value="2" comments="both DML and DDL" />
  <implementation implementation_info_id="18" implementation_info_name="DBMS VERSION" character_value="09.06.0001" />
  <feature feature_id="B011" feature_name="Embedded Ada" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B012" feature_name="Embedded C" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="B013" feature_name="Embedded COBOL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B014" feature_name="Embedded Fortran" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B015" feature_name="Embedded MUMPS" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B016" feature_name="Embedded Pascal" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B017" feature_name="Embedded PL/I" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B021" feature_name="Direct SQL" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="B031" feature_name="Basic dynamic SQL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B032" feature_name="Extended dynamic SQL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B032" feature_name="Extended dynamic SQL" sub_feature_id="01" sub_feature_name="&lt;describe input statement&gt;" is_supported="NO" comments="" />
  <feature feature_id="B033" feature_name="Untyped SQL-invoked function arguments" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B034" feature_name="Dynamic specification of cursor attributes" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B035" feature_name="Non-extended descriptor names" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B041" feature_name="Extensions to embedded SQL exception declarations" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B051" feature_name="Enhanced execution rights" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B111" feature_name="Module language Ada" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B112" feature_name="Module language C" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B113" feature_name="Module language COBOL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B114" feature_name="Module language Fortran" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B115" feature_name="Module language MUMPS" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B116" feature_name="Module language Pascal" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B117" feature_name="Module language PL/I" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B121" feature_name="Routine language Ada" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B122" feature_name="Routine language C" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B123" feature_name="Routine language COBOL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B124" feature_name="Routine language Fortran" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B125" feature_name="Routine language MUMPS" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B126" feature_name="Routine language Pascal" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B127" feature_name="Routine language PL/I" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B128" feature_name="Routine language SQL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B211" feature_name="Module language Ada: VARCHAR and NUMERIC support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="B221" feature_name="Routine language Ada: VARCHAR and NUMERIC support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="E011" feature_name="Numeric data types" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E011" feature_name="Numeric data types" sub_feature_id="01" sub_feature_name="INTEGER and SMALLINT data types" is_supported="YES" comments="" />
  <feature feature_id="E011" feature_name="Numeric data types" sub_feature_id="02" sub_feature_name="REAL, DOUBLE PRECISION, and FLOAT data types" is_supported="YES" comments="" />
  <feature feature_id="E011" feature_name="Numeric data types" sub_feature_id="03" sub_feature_name="DECIMAL and NUMERIC data types" is_supported="YES" comments="" />
  <feature feature_id="E011" feature_name="Numeric data types" sub_feature_id="04" sub_feature_name="Arithmetic operators" is_supported="YES" comments="" />
  <feature feature_id="E011" feature_name="Numeric data types" sub_feature_id="05" sub_feature_name="Numeric comparison" is_supported="YES" comments="" />
  <feature feature_id="E011" feature_name="Numeric data types" sub_feature_id="06" sub_feature_name="Implicit casting among the numeric data types" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character data types" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="01" sub_feature_name="CHARACTER data type" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="02" sub_feature_name="CHARACTER VARYING data type" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="03" sub_feature_name="Character literals" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="04" sub_feature_name="CHARACTER_LENGTH function" is_supported="YES" comments="trims trailing spaces from CHARACTER values before counting" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="05" sub_feature_name="OCTET_LENGTH function" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="06" sub_feature_name="SUBSTRING function" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="07" sub_feature_name="Character concatenation" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="08" sub_feature_name="UPPER and LOWER functions" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="09" sub_feature_name="TRIM function" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="10" sub_feature_name="Implicit casting among the character string types" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="11" sub_feature_name="POSITION function" is_supported="YES" comments="" />
  <feature feature_id="E021" feature_name="Character string types" sub_feature_id="12" sub_feature_name="Character comparison" is_supported="YES" comments="" />
  <feature feature_id="E031" feature_name="Identifiers" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E031" feature_name="Identifiers" sub_feature_id="01" sub_feature_name="Delimited identifiers" is_supported="YES" comments="" />
  <feature feature_id="E031" feature_name="Identifiers" sub_feature_id="02" sub_feature_name="Lower case identifiers" is_supported="YES" comments="" />
  <feature feature_id="E031" feature_name="Identifiers" sub_feature_id="03" sub_feature_name="Trailing underscore" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="01" sub_feature_name="SELECT DISTINCT" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="02" sub_feature_name="GROUP BY clause" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="04" sub_feature_name="GROUP BY can contain columns not in &lt;select list&gt;" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="05" sub_feature_name="Select list items can be renamed" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="06" sub_feature_name="HAVING clause" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="07" sub_feature_name="Qualified * in select list" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="08" sub_feature_name="Correlation names in the FROM clause" is_supported="YES" comments="" />
  <feature feature_id="E051" feature_name="Basic query specification" sub_feature_id="09" sub_feature_name="Rename columns in the FROM clause" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="01" sub_feature_name="Comparison predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="02" sub_feature_name="BETWEEN predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="03" sub_feature_name="IN predicate with list of values" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="04" sub_feature_name="LIKE predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="05" sub_feature_name="LIKE predicate ESCAPE clause" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="06" sub_feature_name="NULL predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="07" sub_feature_name="Quantified comparison predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="08" sub_feature_name="EXISTS predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="09" sub_feature_name="Subqueries in comparison predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="11" sub_feature_name="Subqueries in IN predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="12" sub_feature_name="Subqueries in quantified comparison predicate" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="13" sub_feature_name="Correlated subqueries" is_supported="YES" comments="" />
  <feature feature_id="E061" feature_name="Basic predicates and search conditions" sub_feature_id="14" sub_feature_name="Search condition" is_supported="YES" comments="" />
  <feature feature_id="E071" feature_name="Basic query expressions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E071" feature_name="Basic query expressions" sub_feature_id="01" sub_feature_name="UNION DISTINCT table operator" is_supported="YES" comments="" />
  <feature feature_id="E071" feature_name="Basic query expressions" sub_feature_id="02" sub_feature_name="UNION ALL table operator" is_supported="YES" comments="" />
  <feature feature_id="E071" feature_name="Basic query expressions" sub_feature_id="03" sub_feature_name="EXCEPT DISTINCT table operator" is_supported="YES" comments="" />
  <feature feature_id="E071" feature_name="Basic query expressions" sub_feature_id="05" sub_feature_name="Columns combined via table operators need not have exactly the same data type" is_supported="YES" comments="" />
  <feature feature_id="E071" feature_name="Basic query expressions" sub_feature_id="06" sub_feature_name="Table operators in subqueries" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="01" sub_feature_name="SELECT privilege" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="02" sub_feature_name="DELETE privilege" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="03" sub_feature_name="INSERT privilege at the table level" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="04" sub_feature_name="UPDATE privilege at the table level" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="05" sub_feature_name="UPDATE privilege at the column level" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="06" sub_feature_name="REFERENCES privilege at the table level" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="07" sub_feature_name="REFERENCES privilege at the column level" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="08" sub_feature_name="WITH GRANT OPTION" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="09" sub_feature_name="USAGE privilege" is_supported="YES" comments="" />
  <feature feature_id="E081" feature_name="Basic Privileges" sub_feature_id="10" sub_feature_name="EXECUTE privilege" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="01" sub_feature_name="AVG" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="02" sub_feature_name="COUNT" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="03" sub_feature_name="MAX" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="04" sub_feature_name="MIN" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="05" sub_feature_name="SUM" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="06" sub_feature_name="ALL quantifier" is_supported="YES" comments="" />
  <feature feature_id="E091" feature_name="Set functions" sub_feature_id="07" sub_feature_name="DISTINCT quantifier" is_supported="YES" comments="" />
  <feature feature_id="E101" feature_name="Basic data manipulation" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E101" feature_name="Basic data manipulation" sub_feature_id="01" sub_feature_name="INSERT statement" is_supported="YES" comments="" />
  <feature feature_id="E101" feature_name="Basic data manipulation" sub_feature_id="03" sub_feature_name="Searched UPDATE statement" is_supported="YES" comments="" />
  <feature feature_id="E101" feature_name="Basic data manipulation" sub_feature_id="04" sub_feature_name="Searched DELETE statement" is_supported="YES" comments="" />
  <feature feature_id="E111" feature_name="Single row SELECT statement" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="01" sub_feature_name="DECLARE CURSOR" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="02" sub_feature_name="ORDER BY columns need not be in select list" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="03" sub_feature_name="Value expressions in ORDER BY clause" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="04" sub_feature_name="OPEN statement" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="06" sub_feature_name="Positioned UPDATE statement" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="07" sub_feature_name="Positioned DELETE statement" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="08" sub_feature_name="CLOSE statement" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="10" sub_feature_name="FETCH statement implicit NEXT" is_supported="YES" comments="" />
  <feature feature_id="E121" feature_name="Basic cursor support" sub_feature_id="17" sub_feature_name="WITH HOLD cursors" is_supported="YES" comments="" />
  <feature feature_id="E131" feature_name="Null value support (nulls in lieu of values)" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="01" sub_feature_name="NOT NULL constraints" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="02" sub_feature_name="UNIQUE constraints of NOT NULL columns" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="03" sub_feature_name="PRIMARY KEY constraints" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="04" sub_feature_name="Basic FOREIGN KEY constraint with the NO ACTION default for both referential delete action and referential update action" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="06" sub_feature_name="CHECK constraints" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="07" sub_feature_name="Column defaults" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="08" sub_feature_name="NOT NULL inferred on PRIMARY KEY" is_supported="YES" comments="" />
  <feature feature_id="E141" feature_name="Basic integrity constraints" sub_feature_id="10" sub_feature_name="Names in a foreign key can be specified in any order" is_supported="YES" comments="" />
  <feature feature_id="E151" feature_name="Transaction support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E151" feature_name="Transaction support" sub_feature_id="01" sub_feature_name="COMMIT statement" is_supported="YES" comments="" />
  <feature feature_id="E151" feature_name="Transaction support" sub_feature_id="02" sub_feature_name="ROLLBACK statement" is_supported="YES" comments="" />
  <feature feature_id="E152" feature_name="Basic SET TRANSACTION statement" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E152" feature_name="Basic SET TRANSACTION statement" sub_feature_id="01" sub_feature_name="SET TRANSACTION statement: ISOLATION LEVEL SERIALIZABLE clause" is_supported="YES" comments="" />
  <feature feature_id="E152" feature_name="Basic SET TRANSACTION statement" sub_feature_id="02" sub_feature_name="SET TRANSACTION statement: READ ONLY and READ WRITE clauses" is_supported="YES" comments="" />
  <feature feature_id="E153" feature_name="Updatable queries with subqueries" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E161" feature_name="SQL comments using leading double minus" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E171" feature_name="SQLSTATE support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="E182" feature_name="Module language" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F021" feature_name="Basic information schema" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F021" feature_name="Basic information schema" sub_feature_id="01" sub_feature_name="COLUMNS view" is_supported="YES" comments="" />
  <feature feature_id="F021" feature_name="Basic information schema" sub_feature_id="02" sub_feature_name="TABLES view" is_supported="YES" comments="" />
  <feature feature_id="F021" feature_name="Basic information schema" sub_feature_id="03" sub_feature_name="VIEWS view" is_supported="YES" comments="" />
  <feature feature_id="F021" feature_name="Basic information schema" sub_feature_id="04" sub_feature_name="TABLE_CONSTRAINTS view" is_supported="YES" comments="" />
  <feature feature_id="F021" feature_name="Basic information schema" sub_feature_id="05" sub_feature_name="REFERENTIAL_CONSTRAINTS view" is_supported="YES" comments="" />
  <feature feature_id="F021" feature_name="Basic information schema" sub_feature_id="06" sub_feature_name="CHECK_CONSTRAINTS view" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="01" sub_feature_name="CREATE TABLE statement to create persistent base tables" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="02" sub_feature_name="CREATE VIEW statement" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="03" sub_feature_name="GRANT statement" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="04" sub_feature_name="ALTER TABLE statement: ADD COLUMN clause" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="13" sub_feature_name="DROP TABLE statement: RESTRICT clause" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="16" sub_feature_name="DROP VIEW statement: RESTRICT clause" is_supported="YES" comments="" />
  <feature feature_id="F031" feature_name="Basic schema manipulation" sub_feature_id="19" sub_feature_name="REVOKE statement: RESTRICT clause" is_supported="YES" comments="" />
  <feature feature_id="F032" feature_name="CASCADE drop behavior" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F033" feature_name="ALTER TABLE statement: DROP COLUMN clause" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F034" feature_name="Extended REVOKE statement" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F034" feature_name="Extended REVOKE statement" sub_feature_id="01" sub_feature_name="REVOKE statement performed by other than the owner of a schema object" is_supported="YES" comments="" />
  <feature feature_id="F034" feature_name="Extended REVOKE statement" sub_feature_id="02" sub_feature_name="REVOKE statement: GRANT OPTION FOR clause" is_supported="YES" comments="" />
  <feature feature_id="F034" feature_name="Extended REVOKE statement" sub_feature_id="03" sub_feature_name="REVOKE statement to revoke a privilege that the grantee has WITH GRANT OPTION" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="01" sub_feature_name="Inner join (but not necessarily the INNER keyword)" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="02" sub_feature_name="INNER keyword" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="03" sub_feature_name="LEFT OUTER JOIN" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="04" sub_feature_name="RIGHT OUTER JOIN" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="05" sub_feature_name="Outer joins can be nested" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="07" sub_feature_name="The inner table in a left or right outer join can also be used in an inner join" is_supported="YES" comments="" />
  <feature feature_id="F041" feature_name="Basic joined table" sub_feature_id="08" sub_feature_name="All comparison operators are supported (rather than just =)" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="01" sub_feature_name="DATE data type (including support of DATE literal)" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="02" sub_feature_name="TIME data type (including support of TIME literal) with fractional seconds precision of at least 0" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="03" sub_feature_name="TIMESTAMP data type (including support of TIMESTAMP literal) with fractional seconds precision of at least 0 and 6" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="04" sub_feature_name="Comparison predicate on DATE, TIME, and TIMESTAMP data types" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="05" sub_feature_name="Explicit CAST between datetime types and character string types" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="06" sub_feature_name="CURRENT_DATE" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="07" sub_feature_name="LOCALTIME" is_supported="YES" comments="" />
  <feature feature_id="F051" feature_name="Basic date and time" sub_feature_id="08" sub_feature_name="LOCALTIMESTAMP" is_supported="YES" comments="" />
  <feature feature_id="F052" feature_name="Intervals and datetime arithmetic" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F053" feature_name="OVERLAPS predicate" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F054" feature_name="TIMESTAMP in DATE type precedence list" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F081" feature_name="UNION and EXCEPT in views" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F111" feature_name="Isolation levels other than SERIALIZABLE" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F521" feature_name="Assertions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F111" feature_name="Isolation levels other than SERIALIZABLE" sub_feature_id="01" sub_feature_name="READ UNCOMMITTED isolation level" is_supported="YES" comments="" />
  <feature feature_id="F111" feature_name="Isolation levels other than SERIALIZABLE" sub_feature_id="02" sub_feature_name="READ COMMITTED isolation level" is_supported="YES" comments="" />
  <feature feature_id="F111" feature_name="Isolation levels other than SERIALIZABLE" sub_feature_id="03" sub_feature_name="REPEATABLE READ isolation level" is_supported="YES" comments="" />
  <feature feature_id="F121" feature_name="Basic diagnostics management" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F121" feature_name="Basic diagnostics management" sub_feature_id="01" sub_feature_name="GET DIAGNOSTICS statement" is_supported="NO" comments="" />
  <feature feature_id="F121" feature_name="Basic diagnostics management" sub_feature_id="02" sub_feature_name="SET TRANSACTION statement: DIAGNOSTICS SIZE clause" is_supported="NO" comments="" />
  <feature feature_id="F122" feature_name="Enhanced diagnostics management" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F123" feature_name="All diagnostics" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F131" feature_name="Grouped operations" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F131" feature_name="Grouped operations" sub_feature_id="01" sub_feature_name="WHERE, GROUP BY, and HAVING clauses supported in queries with grouped views" is_supported="YES" comments="" />
  <feature feature_id="F131" feature_name="Grouped operations" sub_feature_id="02" sub_feature_name="Multiple tables supported in queries with grouped views" is_supported="YES" comments="" />
  <feature feature_id="F131" feature_name="Grouped operations" sub_feature_id="03" sub_feature_name="Set functions supported in queries with grouped views" is_supported="YES" comments="" />
  <feature feature_id="F131" feature_name="Grouped operations" sub_feature_id="04" sub_feature_name="Subqueries with GROUP BY and HAVING clauses and grouped views" is_supported="YES" comments="" />
  <feature feature_id="F131" feature_name="Grouped operations" sub_feature_id="05" sub_feature_name="Single row SELECT with GROUP BY and HAVING clauses and grouped views" is_supported="YES" comments="" />
  <feature feature_id="F171" feature_name="Multiple schemas per user" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F181" feature_name="Multiple module support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F191" feature_name="Referential delete actions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F200" feature_name="TRUNCATE TABLE statement" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F201" feature_name="CAST function" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F202" feature_name="TRUNCATE TABLE: identity column restart option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F221" feature_name="Explicit defaults" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F222" feature_name="INSERT statement: DEFAULT VALUES clause" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F231" feature_name="Privilege tables" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F231" feature_name="Privilege tables" sub_feature_id="01" sub_feature_name="TABLE_PRIVILEGES view" is_supported="YES" comments="" />
  <feature feature_id="F231" feature_name="Privilege tables" sub_feature_id="02" sub_feature_name="COLUMN_PRIVILEGES view" is_supported="YES" comments="" />
  <feature feature_id="F231" feature_name="Privilege tables" sub_feature_id="03" sub_feature_name="USAGE_PRIVILEGES view" is_supported="YES" comments="" />
  <feature feature_id="F251" feature_name="Domain support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F261" feature_name="CASE expression" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F261" feature_name="CASE expression" sub_feature_id="01" sub_feature_name="Simple CASE" is_supported="YES" comments="" />
  <feature feature_id="F261" feature_name="CASE expression" sub_feature_id="02" sub_feature_name="Searched CASE" is_supported="YES" comments="" />
  <feature feature_id="F261" feature_name="CASE expression" sub_feature_id="03" sub_feature_name="NULLIF" is_supported="YES" comments="" />
  <feature feature_id="F261" feature_name="CASE expression" sub_feature_id="04" sub_feature_name="COALESCE" is_supported="YES" comments="" />
  <feature feature_id="F262" feature_name="Extended CASE expression" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F263" feature_name="Comma-separated predicates in simple CASE expression" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F271" feature_name="Compound character literals" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F281" feature_name="LIKE enhancements" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F291" feature_name="UNIQUE predicate" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F301" feature_name="CORRESPONDING in query expressions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F302" feature_name="INTERSECT table operator" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F302" feature_name="INTERSECT table operator" sub_feature_id="01" sub_feature_name="INTERSECT DISTINCT table operator" is_supported="YES" comments="" />
  <feature feature_id="F302" feature_name="INTERSECT table operator" sub_feature_id="02" sub_feature_name="INTERSECT ALL table operator" is_supported="YES" comments="" />
  <feature feature_id="F304" feature_name="EXCEPT ALL table operator" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F311" feature_name="Schema definition statement" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F311" feature_name="Schema definition statement" sub_feature_id="01" sub_feature_name="CREATE SCHEMA" is_supported="YES" comments="" />
  <feature feature_id="F311" feature_name="Schema definition statement" sub_feature_id="02" sub_feature_name="CREATE TABLE for persistent base tables" is_supported="YES" comments="" />
  <feature feature_id="F311" feature_name="Schema definition statement" sub_feature_id="03" sub_feature_name="CREATE VIEW" is_supported="YES" comments="" />
  <feature feature_id="F311" feature_name="Schema definition statement" sub_feature_id="04" sub_feature_name="CREATE VIEW: WITH CHECK OPTION" is_supported="YES" comments="" />
  <feature feature_id="F311" feature_name="Schema definition statement" sub_feature_id="05" sub_feature_name="GRANT statement" is_supported="YES" comments="" />
  <feature feature_id="F312" feature_name="MERGE statement" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="consider INSERT ... ON CONFLICT DO UPDATE" />
  <feature feature_id="F313" feature_name="Enhanced MERGE statement" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F314" feature_name="MERGE statement with DELETE branch" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F321" feature_name="User authorization" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F341" feature_name="Usage tables" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="no ROUTINE_*_USAGE tables" />
  <feature feature_id="F361" feature_name="Subprogram support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F381" feature_name="Extended schema manipulation" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F381" feature_name="Extended schema manipulation" sub_feature_id="01" sub_feature_name="ALTER TABLE statement: ALTER COLUMN clause" is_supported="YES" comments="" />
  <feature feature_id="F381" feature_name="Extended schema manipulation" sub_feature_id="02" sub_feature_name="ALTER TABLE statement: ADD CONSTRAINT clause" is_supported="YES" comments="" />
  <feature feature_id="F381" feature_name="Extended schema manipulation" sub_feature_id="03" sub_feature_name="ALTER TABLE statement: DROP CONSTRAINT clause" is_supported="YES" comments="" />
  <feature feature_id="F382" feature_name="Alter column data type" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F383" feature_name="Set column not null clause" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F384" feature_name="Drop identity property clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F385" feature_name="Drop column generation expression clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F386" feature_name="Set identity column generation clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F391" feature_name="Long identifiers" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F392" feature_name="Unicode escapes in identifiers" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F393" feature_name="Unicode escapes in literals" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F394" feature_name="Optional normal form specification" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F401" feature_name="Extended joined table" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F401" feature_name="Extended joined table" sub_feature_id="01" sub_feature_name="NATURAL JOIN" is_supported="YES" comments="" />
  <feature feature_id="F401" feature_name="Extended joined table" sub_feature_id="02" sub_feature_name="FULL OUTER JOIN" is_supported="YES" comments="" />
  <feature feature_id="F401" feature_name="Extended joined table" sub_feature_id="04" sub_feature_name="CROSS JOIN" is_supported="YES" comments="" />
  <feature feature_id="F402" feature_name="Named column joins for LOBs, arrays, and multisets" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F403" feature_name="Partitioned joined tables" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F411" feature_name="Time zone specification" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="differences regarding literal interpretation" />
  <feature feature_id="F421" feature_name="National character" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F431" feature_name="Read-only scrollable cursors" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F431" feature_name="Read-only scrollable cursors" sub_feature_id="01" sub_feature_name="FETCH with explicit NEXT" is_supported="YES" comments="" />
  <feature feature_id="F431" feature_name="Read-only scrollable cursors" sub_feature_id="02" sub_feature_name="FETCH FIRST" is_supported="YES" comments="" />
  <feature feature_id="F431" feature_name="Read-only scrollable cursors" sub_feature_id="03" sub_feature_name="FETCH LAST" is_supported="YES" comments="" />
  <feature feature_id="F431" feature_name="Read-only scrollable cursors" sub_feature_id="04" sub_feature_name="FETCH PRIOR" is_supported="YES" comments="" />
  <feature feature_id="F431" feature_name="Read-only scrollable cursors" sub_feature_id="05" sub_feature_name="FETCH ABSOLUTE" is_supported="YES" comments="" />
  <feature feature_id="F431" feature_name="Read-only scrollable cursors" sub_feature_id="06" sub_feature_name="FETCH RELATIVE" is_supported="YES" comments="" />
  <feature feature_id="F441" feature_name="Extended set function support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F442" feature_name="Mixed column references in set functions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F451" feature_name="Character set definition" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F461" feature_name="Named character sets" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F471" feature_name="Scalar subquery values" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F481" feature_name="Expanded NULL predicate" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F491" feature_name="Constraint management" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F492" feature_name="Optional table constraint enforcement" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F501" feature_name="Features and conformance views" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F501" feature_name="Features and conformance views" sub_feature_id="01" sub_feature_name="SQL_FEATURES view" is_supported="YES" comments="" />
  <feature feature_id="F501" feature_name="Features and conformance views" sub_feature_id="02" sub_feature_name="SQL_SIZING view" is_supported="YES" comments="" />
  <feature feature_id="F501" feature_name="Features and conformance views" sub_feature_id="03" sub_feature_name="SQL_LANGUAGES view" is_supported="YES" comments="" />
  <feature feature_id="F502" feature_name="Enhanced documentation tables" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F502" feature_name="Enhanced documentation tables" sub_feature_id="01" sub_feature_name="SQL_SIZING_PROFILES view" is_supported="YES" comments="" />
  <feature feature_id="F502" feature_name="Enhanced documentation tables" sub_feature_id="02" sub_feature_name="SQL_IMPLEMENTATION_INFO view" is_supported="YES" comments="" />
  <feature feature_id="F502" feature_name="Enhanced documentation tables" sub_feature_id="03" sub_feature_name="SQL_PACKAGES view" is_supported="YES" comments="" />
  <feature feature_id="F531" feature_name="Temporary tables" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F555" feature_name="Enhanced seconds precision" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F561" feature_name="Full value expressions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F571" feature_name="Truth value tests" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F591" feature_name="Derived tables" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F611" feature_name="Indicator data types" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F641" feature_name="Row and table constructors" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F651" feature_name="Catalog name qualifiers" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F661" feature_name="Simple tables" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F671" feature_name="Subqueries in CHECK" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="intentionally omitted" />
  <feature feature_id="F672" feature_name="Retrospective check constraints" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F690" feature_name="Collation support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="but no character set support" />
  <feature feature_id="F692" feature_name="Extended collation support" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F693" feature_name="SQL-session and client module collations" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F695" feature_name="Translation support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F696" feature_name="Additional translation documentation" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F701" feature_name="Referential update actions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F711" feature_name="ALTER domain" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F721" feature_name="Deferrable constraints" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="foreign and unique keys only" />
  <feature feature_id="F731" feature_name="INSERT column privileges" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F741" feature_name="Referential MATCH types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="no partial match yet" />
  <feature feature_id="F751" feature_name="View CHECK enhancements" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F761" feature_name="Session management" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F762" feature_name="CURRENT_CATALOG" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F763" feature_name="CURRENT_SCHEMA" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F771" feature_name="Connection management" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F781" feature_name="Self-referencing operations" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F791" feature_name="Insensitive cursors" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F801" feature_name="Full set function" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F812" feature_name="Basic flagging" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F813" feature_name="Extended flagging" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F821" feature_name="Local table references" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F831" feature_name="Full cursor update" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F831" feature_name="Full cursor update" sub_feature_id="01" sub_feature_name="Updatable scrollable cursors" is_supported="NO" comments="" />
  <feature feature_id="F831" feature_name="Full cursor update" sub_feature_id="02" sub_feature_name="Updatable ordered cursors" is_supported="NO" comments="" />
  <feature feature_id="F841" feature_name="LIKE_REGEX predicate" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F842" feature_name="OCCURRENCES_REGEX function" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F843" feature_name="POSITION_REGEX function" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F844" feature_name="SUBSTRING_REGEX function" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F845" feature_name="TRANSLATE_REGEX function" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F846" feature_name="Octet support in regular expression operators" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F847" feature_name="Nonconstant regular expressions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F850" feature_name="Top-level &lt;order by clause&gt; in &lt;query expression&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F851" feature_name="&lt;order by clause&gt; in subqueries" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F852" feature_name="Top-level &lt;order by clause&gt; in views" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F855" feature_name="Nested &lt;order by clause&gt; in &lt;query expression&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F856" feature_name="Nested &lt;fetch first clause&gt; in &lt;query expression&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F857" feature_name="Top-level &lt;fetch first clause&gt; in &lt;query expression&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F858" feature_name="&lt;fetch first clause&gt; in subqueries" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F859" feature_name="Top-level &lt;fetch first clause&gt; in views" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F860" feature_name="&lt;fetch first row count&gt; in &lt;fetch first clause&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F861" feature_name="Top-level &lt;result offset clause&gt; in &lt;query expression&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F862" feature_name="&lt;result offset clause&gt; in subqueries" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F863" feature_name="Nested &lt;result offset clause&gt; in &lt;query expression&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F864" feature_name="Top-level &lt;result offset clause&gt; in views" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F865" feature_name="&lt;offset row count&gt; in &lt;result offset clause&gt;" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="F866" feature_name="FETCH FIRST clause: PERCENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="F867" feature_name="FETCH FIRST clause: WITH TIES option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S011" feature_name="Distinct data types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S011" feature_name="Distinct data types" sub_feature_id="01" sub_feature_name="USER_DEFINED_TYPES view" is_supported="NO" comments="" />
  <feature feature_id="S023" feature_name="Basic structured types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S024" feature_name="Enhanced structured types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S025" feature_name="Final structured types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S026" feature_name="Self-referencing structured types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S027" feature_name="Create method by specific method name" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S028" feature_name="Permutable UDT options list" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S041" feature_name="Basic reference types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S043" feature_name="Enhanced reference types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S051" feature_name="Create table of type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="partially supported" />
  <feature feature_id="S071" feature_name="SQL paths in function and type name resolution" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S081" feature_name="Subtables" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S091" feature_name="Basic array support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="partially supported" />
  <feature feature_id="S091" feature_name="Basic array support" sub_feature_id="01" sub_feature_name="Arrays of built-in data types" is_supported="NO" comments="" />
  <feature feature_id="S091" feature_name="Basic array support" sub_feature_id="02" sub_feature_name="Arrays of distinct types" is_supported="NO" comments="" />
  <feature feature_id="S091" feature_name="Basic array support" sub_feature_id="03" sub_feature_name="Array expressions" is_supported="NO" comments="" />
  <feature feature_id="S092" feature_name="Arrays of user-defined types" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S094" feature_name="Arrays of reference types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S095" feature_name="Array constructors by query" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S096" feature_name="Optional array bounds" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S097" feature_name="Array element assignment" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S098" feature_name="ARRAY_AGG" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S111" feature_name="ONLY in query expressions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S151" feature_name="Type predicate" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S161" feature_name="Subtype treatment" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S162" feature_name="Subtype treatment for references" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S201" feature_name="SQL-invoked routines on arrays" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S201" feature_name="SQL-invoked routines on arrays" sub_feature_id="01" sub_feature_name="Array parameters" is_supported="YES" comments="" />
  <feature feature_id="S201" feature_name="SQL-invoked routines on arrays" sub_feature_id="02" sub_feature_name="Array as result type of functions" is_supported="YES" comments="" />
  <feature feature_id="S202" feature_name="SQL-invoked routines on multisets" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S211" feature_name="User-defined cast functions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S231" feature_name="Structured type locators" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S232" feature_name="Array locators" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S233" feature_name="Multiset locators" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S241" feature_name="Transform functions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S242" feature_name="Alter transform statement" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S251" feature_name="User-defined orderings" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S261" feature_name="Specific type method" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S271" feature_name="Basic multiset support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S272" feature_name="Multisets of user-defined types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S274" feature_name="Multisets of reference types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S275" feature_name="Advanced multiset support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S281" feature_name="Nested collection types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S291" feature_name="Unique constraint on entire row" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S301" feature_name="Enhanced UNNEST" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="S401" feature_name="Distinct types based on array types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S402" feature_name="Distinct types based on distinct types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S403" feature_name="ARRAY_MAX_CARDINALITY" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="S404" feature_name="TRIM_ARRAY" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T011" feature_name="Timestamp in Information Schema" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T021" feature_name="BINARY and VARBINARY data types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T022" feature_name="Advanced support for BINARY and VARBINARY data types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T023" feature_name="Compound binary literal" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T024" feature_name="Spaces in binary literals" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T031" feature_name="BOOLEAN data type" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T041" feature_name="Basic LOB data type support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T041" feature_name="Basic LOB data type support" sub_feature_id="01" sub_feature_name="BLOB data type" is_supported="NO" comments="" />
  <feature feature_id="T041" feature_name="Basic LOB data type support" sub_feature_id="02" sub_feature_name="CLOB data type" is_supported="NO" comments="" />
  <feature feature_id="T041" feature_name="Basic LOB data type support" sub_feature_id="03" sub_feature_name="POSITION, LENGTH, LOWER, TRIM, UPPER, and SUBSTRING functions for LOB data types" is_supported="NO" comments="" />
  <feature feature_id="T041" feature_name="Basic LOB data type support" sub_feature_id="04" sub_feature_name="Concatenation of LOB data types" is_supported="NO" comments="" />
  <feature feature_id="T041" feature_name="Basic LOB data type support" sub_feature_id="05" sub_feature_name="LOB locator: non-holdable" is_supported="NO" comments="" />
  <feature feature_id="T042" feature_name="Extended LOB data type support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T043" feature_name="Multiplier T" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T044" feature_name="Multiplier P" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T051" feature_name="Row types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T052" feature_name="MAX and MIN for row types" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T053" feature_name="Explicit aliases for all-fields reference" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T061" feature_name="UCS support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T071" feature_name="BIGINT data type" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T101" feature_name="Enhanced nullability determination" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T111" feature_name="Updatable joins, unions, and columns" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T121" feature_name="WITH (excluding RECURSIVE) in query expression" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T122" feature_name="WITH (excluding RECURSIVE) in subquery" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T131" feature_name="Recursive query" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T132" feature_name="Recursive query in subquery" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T141" feature_name="SIMILAR predicate" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T151" feature_name="DISTINCT predicate" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T152" feature_name="DISTINCT predicate with negation" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T171" feature_name="LIKE clause in table definition" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T172" feature_name="AS subquery clause in table definition" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T173" feature_name="Extended LIKE clause in table definition" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T174" feature_name="Identity columns" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T175" feature_name="Generated columns" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T176" feature_name="Sequence generator support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T177" feature_name="Sequence generator support: simple restart option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T178" feature_name="Identity columns:  simple restart option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T180" feature_name="System-versioned tables" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T181" feature_name="Application-time period tables" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T191" feature_name="Referential action RESTRICT" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T201" feature_name="Comparable data types for referential constraints" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="01" sub_feature_name="Triggers activated on UPDATE, INSERT, or DELETE of one base table" is_supported="YES" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="02" sub_feature_name="BEFORE triggers" is_supported="YES" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="03" sub_feature_name="AFTER triggers" is_supported="YES" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="04" sub_feature_name="FOR EACH ROW triggers" is_supported="YES" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="05" sub_feature_name="Ability to specify a search condition that must be true before the trigger is invoked" is_supported="YES" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="06" sub_feature_name="Support for run-time rules for the interaction of triggers and constraints" is_supported="NO" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="07" sub_feature_name="TRIGGER privilege" is_supported="YES" comments="" />
  <feature feature_id="T211" feature_name="Basic trigger capability" sub_feature_id="08" sub_feature_name="Multiple triggers for the same event are executed in the order in which they were created in the catalog" is_supported="NO" comments="intentionally omitted" />
  <feature feature_id="T212" feature_name="Enhanced trigger capability" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T213" feature_name="INSTEAD OF triggers" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T231" feature_name="Sensitive cursors" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T241" feature_name="START TRANSACTION statement" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T251" feature_name="SET TRANSACTION statement: LOCAL option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T261" feature_name="Chained transactions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T271" feature_name="Savepoints" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T272" feature_name="Enhanced savepoint management" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T281" feature_name="SELECT privilege with column granularity" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T285" feature_name="Enhanced derived column names" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T301" feature_name="Functional dependencies" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="partially supported" />
  <feature feature_id="T312" feature_name="OVERLAY function" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="01" sub_feature_name="User-defined functions with no overloading" is_supported="YES" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="02" sub_feature_name="User-defined stored procedures with no overloading" is_supported="NO" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="03" sub_feature_name="Function invocation" is_supported="YES" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="04" sub_feature_name="CALL statement" is_supported="NO" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="05" sub_feature_name="RETURN statement" is_supported="NO" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="06" sub_feature_name="ROUTINES view" is_supported="YES" comments="" />
  <feature feature_id="T321" feature_name="Basic SQL-invoked routines" sub_feature_id="07" sub_feature_name="PARAMETERS view" is_supported="YES" comments="" />
  <feature feature_id="T322" feature_name="Declared data type attributes" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T323" feature_name="Explicit security for external routines" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T324" feature_name="Explicit security for SQL routines" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T325" feature_name="Qualified SQL parameter references" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T326" feature_name="Table functions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T331" feature_name="Basic roles" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T332" feature_name="Extended roles" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="mostly supported" />
  <feature feature_id="T341" feature_name="Overloading of SQL-invoked functions and procedures" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T351" feature_name="Bracketed SQL comments (/*...*/ comments)" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T431" feature_name="Extended grouping capabilities" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T432" feature_name="Nested and concatenated GROUPING SETS" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T433" feature_name="Multiargument GROUPING function" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T434" feature_name="GROUP BY DISTINCT" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T441" feature_name="ABS and MOD functions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T461" feature_name="Symmetric BETWEEN predicate" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T471" feature_name="Result sets return value" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T472" feature_name="DESCRIBE CURSOR" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T491" feature_name="LATERAL derived table" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T495" feature_name="Combined data change and retrieval" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="different syntax" />
  <feature feature_id="T501" feature_name="Enhanced EXISTS predicate" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T502" feature_name="Period predicates" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T511" feature_name="Transaction counts" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T521" feature_name="Named arguments in CALL statement" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T522" feature_name="Default values for IN parameters of SQL-invoked procedures" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="supported except DEFAULT key word in invocation" />
  <feature feature_id="T551" feature_name="Optional key words for default syntax" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T561" feature_name="Holdable locators" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T571" feature_name="Array-returning external SQL-invoked functions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T572" feature_name="Multiset-returning external SQL-invoked functions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T581" feature_name="Regular expression substring function" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T591" feature_name="UNIQUE constraints of possibly null columns" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T601" feature_name="Local cursor references" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T611" feature_name="Elementary OLAP operations" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T612" feature_name="Advanced OLAP operations" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="some forms supported" />
  <feature feature_id="T613" feature_name="Sampling" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T614" feature_name="NTILE function" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T615" feature_name="LEAD and LAG functions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T616" feature_name="Null treatment option for LEAD and LAG functions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T617" feature_name="FIRST_VALUE and LAST_VALUE function" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T618" feature_name="NTH_VALUE function" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="function exists, but some options missing" />
  <feature feature_id="T619" feature_name="Nested window functions" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T620" feature_name="WINDOW clause: GROUPS option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T621" feature_name="Enhanced numeric functions" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T631" feature_name="IN predicate with one list element" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T641" feature_name="Multiple column assignment" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="only some syntax variants supported" />
  <feature feature_id="T651" feature_name="SQL-schema statements in SQL routines" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="T652" feature_name="SQL-dynamic statements in SQL routines" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T653" feature_name="SQL-schema statements in external routines" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T654" feature_name="SQL-dynamic statements in external routines" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="T655" feature_name="Cyclically dependent routines" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="M001" feature_name="Datalinks" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M002" feature_name="Datalinks via SQL/CLI" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M003" feature_name="Datalinks via Embedded SQL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M004" feature_name="Foreign data support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="partially supported" />
  <feature feature_id="M005" feature_name="Foreign schema support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M006" feature_name="GetSQLString routine" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M007" feature_name="TransmitRequest" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M009" feature_name="GetOpts and GetStatistics routines" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M010" feature_name="Foreign data wrapper support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="different API" />
  <feature feature_id="M011" feature_name="Datalinks via Ada" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M012" feature_name="Datalinks via C" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M013" feature_name="Datalinks via COBOL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M014" feature_name="Datalinks via Fortran" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M015" feature_name="Datalinks via M" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M016" feature_name="Datalinks via Pascal" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M017" feature_name="Datalinks via PL/I" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M018" feature_name="Foreign data wrapper interface routines in Ada" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M019" feature_name="Foreign data wrapper interface routines in C" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="different API" />
  <feature feature_id="M020" feature_name="Foreign data wrapper interface routines in COBOL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M021" feature_name="Foreign data wrapper interface routines in Fortran" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M022" feature_name="Foreign data wrapper interface routines in MUMPS" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M023" feature_name="Foreign data wrapper interface routines in Pascal" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M024" feature_name="Foreign data wrapper interface routines in PL/I" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M030" feature_name="SQL-server foreign data support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="M031" feature_name="Foreign data wrapper general routines" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X010" feature_name="XML type" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X011" feature_name="Arrays of XML type" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X012" feature_name="Multisets of XML type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X013" feature_name="Distinct types of XML type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X014" feature_name="Attributes of XML type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X015" feature_name="Fields of XML type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X016" feature_name="Persistent XML values" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X020" feature_name="XMLConcat" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X025" feature_name="XMLCast" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X030" feature_name="XMLDocument" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X031" feature_name="XMLElement" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X032" feature_name="XMLForest" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X034" feature_name="XMLAgg" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X035" feature_name="XMLAgg: ORDER BY option" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X036" feature_name="XMLComment" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X037" feature_name="XMLPI" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X038" feature_name="XMLText" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X040" feature_name="Basic table mapping" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X041" feature_name="Basic table mapping: nulls absent" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X042" feature_name="Basic table mapping: null as nil" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X043" feature_name="Basic table mapping: table as forest" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X044" feature_name="Basic table mapping: table as element" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X045" feature_name="Basic table mapping: with target namespace" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X046" feature_name="Basic table mapping: data mapping" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X047" feature_name="Basic table mapping: metadata mapping" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X048" feature_name="Basic table mapping: base64 encoding of binary strings" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X049" feature_name="Basic table mapping: hex encoding of binary strings" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X050" feature_name="Advanced table mapping" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X051" feature_name="Advanced table mapping: nulls absent" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X052" feature_name="Advanced table mapping: null as nil" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X053" feature_name="Advanced table mapping: table as forest" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X054" feature_name="Advanced table mapping: table as element" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X055" feature_name="Advanced table mapping: with target namespace" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X056" feature_name="Advanced table mapping: data mapping" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X057" feature_name="Advanced table mapping: metadata mapping" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X058" feature_name="Advanced table mapping: base64 encoding of binary strings" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X059" feature_name="Advanced table mapping: hex encoding of binary strings" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X060" feature_name="XMLParse: character string input and CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X061" feature_name="XMLParse: character string input and DOCUMENT option" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X065" feature_name="XMLParse: BLOB input and CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X066" feature_name="XMLParse: BLOB input and DOCUMENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X068" feature_name="XMLSerialize: BOM" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X069" feature_name="XMLSerialize: INDENT" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X070" feature_name="XMLSerialize: character string serialization and CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X071" feature_name="XMLSerialize: character string serialization and DOCUMENT option" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X072" feature_name="XMLSerialize: character string serialization" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X073" feature_name="XMLSerialize: BLOB serialization and CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X074" feature_name="XMLSerialize: BLOB serialization and DOCUMENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X075" feature_name="XMLSerialize: BLOB serialization" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X076" feature_name="XMLSerialize: VERSION" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X077" feature_name="XMLSerialize: explicit ENCODING option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X078" feature_name="XMLSerialize: explicit XML declaration" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X080" feature_name="Namespaces in XML publishing" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X081" feature_name="Query-level XML namespace declarations" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X082" feature_name="XML namespace declarations in DML" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X083" feature_name="XML namespace declarations in DDL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X084" feature_name="XML namespace declarations in compound statements" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X085" feature_name="Predefined namespace prefixes" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X086" feature_name="XML namespace declarations in XMLTable" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X090" feature_name="XML document predicate" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X091" feature_name="XML content predicate" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X096" feature_name="XMLExists" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X100" feature_name="Host language support for XML: CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X101" feature_name="Host language support for XML: DOCUMENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X110" feature_name="Host language support for XML: VARCHAR mapping" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X111" feature_name="Host language support for XML: CLOB mapping" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X112" feature_name="Host language support for XML: BLOB mapping" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X113" feature_name="Host language support for XML: STRIP WHITESPACE option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X114" feature_name="Host language support for XML: PRESERVE WHITESPACE option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X120" feature_name="XML parameters in SQL routines" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X121" feature_name="XML parameters in external routines" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X131" feature_name="Query-level XMLBINARY clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X132" feature_name="XMLBINARY clause in DML" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X133" feature_name="XMLBINARY clause in DDL" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X134" feature_name="XMLBINARY clause in compound statements" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X135" feature_name="XMLBINARY clause in subqueries" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X141" feature_name="IS VALID predicate: data-driven case" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X142" feature_name="IS VALID predicate: ACCORDING TO clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X143" feature_name="IS VALID predicate: ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X144" feature_name="IS VALID predicate: schema location" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X145" feature_name="IS VALID predicate outside check constraints" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X151" feature_name="IS VALID predicate with DOCUMENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X152" feature_name="IS VALID predicate with CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X153" feature_name="IS VALID predicate with SEQUENCE option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X155" feature_name="IS VALID predicate: NAMESPACE without ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X157" feature_name="IS VALID predicate: NO NAMESPACE with ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X160" feature_name="Basic Information Schema for registered XML Schemas" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X161" feature_name="Advanced Information Schema for registered XML Schemas" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X170" feature_name="XML null handling options" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X171" feature_name="NIL ON NO CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X181" feature_name="XML(DOCUMENT(UNTYPED)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X182" feature_name="XML(DOCUMENT(ANY)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X190" feature_name="XML(SEQUENCE) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X191" feature_name="XML(DOCUMENT(XMLSCHEMA)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X192" feature_name="XML(CONTENT(XMLSCHEMA)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X200" feature_name="XMLQuery" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X201" feature_name="XMLQuery: RETURNING CONTENT" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X202" feature_name="XMLQuery: RETURNING SEQUENCE" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X203" feature_name="XMLQuery: passing a context item" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X204" feature_name="XMLQuery: initializing an XQuery variable" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X205" feature_name="XMLQuery: EMPTY ON EMPTY option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X206" feature_name="XMLQuery: NULL ON EMPTY option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X211" feature_name="XML 1.1 support" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X221" feature_name="XML passing mechanism BY VALUE" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X222" feature_name="XML passing mechanism BY REF" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X231" feature_name="XML(CONTENT(UNTYPED)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X232" feature_name="XML(CONTENT(ANY)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X241" feature_name="RETURNING CONTENT in XML publishing" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X242" feature_name="RETURNING SEQUENCE in XML publishing" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X251" feature_name="Persistent XML values of XML(DOCUMENT(UNTYPED)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X252" feature_name="Persistent XML values of XML(DOCUMENT(ANY)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X253" feature_name="Persistent XML values of XML(CONTENT(UNTYPED)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X254" feature_name="Persistent XML values of XML(CONTENT(ANY)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X255" feature_name="Persistent XML values of XML(SEQUENCE) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X256" feature_name="Persistent XML values of XML(DOCUMENT(XMLSCHEMA)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X257" feature_name="Persistent XML values of XML(CONTENT(XMLSCHEMA)) type" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X260" feature_name="XML type: ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X261" feature_name="XML type: NAMESPACE without ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X263" feature_name="XML type: NO NAMESPACE with ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X264" feature_name="XML type: schema location" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X271" feature_name="XMLValidate: data-driven case" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X272" feature_name="XMLValidate: ACCORDING TO clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X273" feature_name="XMLValidate: ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X274" feature_name="XMLValidate: schema location" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X281" feature_name="XMLValidate with DOCUMENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X282" feature_name="XMLValidate with CONTENT option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X283" feature_name="XMLValidate with SEQUENCE option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X284" feature_name="XMLValidate: NAMESPACE without ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X286" feature_name="XMLValidate: NO NAMESPACE with ELEMENT clause" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X300" feature_name="XMLTable" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X301" feature_name="XMLTable: derived column list option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X302" feature_name="XMLTable: ordinality column option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X303" feature_name="XMLTable: column default option" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X304" feature_name="XMLTable: passing a context item" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X305" feature_name="XMLTable: initializing an XQuery variable" sub_feature_id="" sub_feature_name="" is_supported="NO" comments="" />
  <feature feature_id="X400" feature_name="Name and identifier mapping" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <feature feature_id="X410" feature_name="Alter column data type: XML type" sub_feature_id="" sub_feature_name="" is_supported="YES" comments="" />
  <language sql_language_source="ISO 9075" sql_language_year="1999" sql_language_conformance="CORE" sql_language_binding_style="DIRECT" />
  <language sql_language_source="ISO 9075" sql_language_year="1999" sql_language_conformance="CORE" sql_language_binding_style="EMBEDDED" sql_language_programming_language="C" />
  <language sql_language_source="ISO 9075" sql_language_year="2003" sql_language_conformance="CORE" sql_language_binding_style="DIRECT" />
  <language sql_language_source="ISO 9075" sql_language_year="2003" sql_language_conformance="CORE" sql_language_binding_style="EMBEDDED" sql_language_programming_language="C" />
  <table xtype="U" datasizeKB="8" name="public.attributes" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="2" pages="1" indexsizeKB="32">
    <column name="attributeid" parent="public.attributes" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" column_name="attributeid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="attributeuuid" parent="public.attributes" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" column_name="attributeuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="attributename" parent="public.attributes" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" column_name="attributename" ordinal_position="3" is_nullable="NO" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.attributes" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" column_name="createdat" ordinal_position="4" is_nullable="NO" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.attributes" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" column_name="createdby" ordinal_position="5" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedat" parent="public.attributes" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" column_name="updatedat" ordinal_position="6" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedby" parent="public.attributes" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="attributes" column_name="updatedby" ordinal_position="7" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.attributes__un" parent="public.attributes" contype="u" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="3">
      <column ordinal="3" />
    </constraint>
    <constraint name="public.attribubes_pk" parent="public.attributes" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.attribubes_pk" parent="public.attributes" indexpages="2" numrows="2" indexrelid="113403" indrelid="113242" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.attribubes_pk" relkind="i" nspname="public" typname="int4" attname="attributeid" attnum="1" />
    </index>
    <index xtype="INDEX" indexsizeKB="16" name="public.attributes__un" parent="public.attributes" indexpages="2" numrows="2" indexrelid="113405" indrelid="113242" indnatts="1" indisunique="1" indisprimary="0" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="3" indcollation="100" indclass="3126" indoption="0">
      <column index="public.attributes__un" relkind="i" nspname="public" typname="varchar" attname="attributename" attnum="1" />
    </index>
    <code>CREATE TABLE attributes (
    attributeid integer NOT NULL,
    attributeuuid uuid,
    attributename character varying(250) NOT NULL,
    createdat timestamp without time zone NOT NULL,
    createdby uuid NOT NULL,
    updatedat timestamp without time zone,
    updatedby uuid
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.components" table_catalog="MarketplaceCore" table_schema="public" table_name="components" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="13" pages="1" indexsizeKB="32">
    <column name="componentid" parent="public.components" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="componentid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="componentuuid" parent="public.components" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="componentuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="componentname" parent="public.components" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="componentname" ordinal_position="3" is_nullable="YES" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="componentparentid" parent="public.components" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="componentparentid" ordinal_position="4" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="componentdescription" parent="public.components" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="componentdescription" ordinal_position="5" is_nullable="YES" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.components" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="createdat" ordinal_position="6" is_nullable="NO" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.components" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="createdby" ordinal_position="7" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedat" parent="public.components" ordinal="8" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="updatedat" ordinal_position="8" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="8" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedby" parent="public.components" ordinal="9" table_catalog="MarketplaceCore" table_schema="public" table_name="components" column_name="updatedby" ordinal_position="9" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="9" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.components_components_fk" parent="public.components" reftable="public.components" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="4" referred_columns="1" isForeignKey="1" refTable="public.components" refColumn="componentid" colName="componentparentid">
      <column ordinal="4" refOrdinal="1" refColumn="componentid" colName="componentparentid" />
    </constraint>
    <constraint name="public.components_pk" parent="public.components" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <constraint name="public.components__un" parent="public.components" contype="u" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="3">
      <column ordinal="3" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.components__un" parent="public.components" indexpages="2" numrows="13" indexrelid="113407" indrelid="113247" indnatts="1" indisunique="1" indisprimary="0" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="3" indcollation="100" indclass="3126" indoption="0">
      <column index="public.components__un" relkind="i" nspname="public" typname="varchar" attname="componentname" attnum="1" />
    </index>
    <index xtype="INDEX" indexsizeKB="16" name="public.components_pk" parent="public.components" indexpages="2" numrows="13" indexrelid="113409" indrelid="113247" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.components_pk" relkind="i" nspname="public" typname="int4" attname="componentid" attnum="1" />
    </index>
    <code>CREATE TABLE components (
    componentid integer NOT NULL,
    componentuuid uuid,
    componentname character varying(250),
    componentparentid integer,
    componentdescription character varying(32672),
    createdat timestamp without time zone NOT NULL,
    createdby uuid NOT NULL,
    updatedat timestamp without time zone,
    updatedby uuid
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.componentsattribute" table_catalog="MarketplaceCore" table_schema="public" table_name="componentsattribute" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="13" pages="1" indexsizeKB="16">
    <column name="componentid" parent="public.componentsattribute" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="componentsattribute" column_name="componentid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="attributeid" parent="public.componentsattribute" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="componentsattribute" column_name="attributeid" ordinal_position="2" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.componentsattribute_attribubes_fk" parent="public.componentsattribute" reftable="public.attributes" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="2" referred_columns="1" isForeignKey="1" refTable="public.attributes" refColumn="attributeid" colName="attributeid">
      <column ordinal="2" refOrdinal="1" refColumn="attributeid" colName="attributeid" />
    </constraint>
    <constraint name="public.componentsattribute_components_fk" parent="public.componentsattribute" reftable="public.components" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="1" referred_columns="1" isForeignKey="1" refTable="public.components" refColumn="componentid" colName="componentid">
      <column ordinal="1" refOrdinal="1" refColumn="componentid" colName="componentid" />
    </constraint>
    <constraint name="public.componentsattribute_pk" parent="public.componentsattribute" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="2,1">
      <column ordinal="2" />
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.componentsattribute_pk" parent="public.componentsattribute" indexpages="2" numrows="13" indexrelid="113411" indrelid="113253" indnatts="2" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="2 1" indcollation="0 0" indclass="1978 1978" indoption="0 0">
      <column index="public.componentsattribute_pk" relkind="i" nspname="public" typname="int4" attname="attributeid" attnum="1" />
      <column index="public.componentsattribute_pk" relkind="i" nspname="public" typname="int4" attname="componentid" attnum="2" />
    </index>
    <code>CREATE TABLE componentsattribute (
    componentid integer NOT NULL,
    attributeid integer NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.componentstechnologies" table_catalog="MarketplaceCore" table_schema="public" table_name="componentstechnologies" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="13" pages="1" indexsizeKB="16">
    <column name="componentid" parent="public.componentstechnologies" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="componentstechnologies" column_name="componentid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologyid" parent="public.componentstechnologies" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="componentstechnologies" column_name="technologyid" ordinal_position="2" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.componentstechnologies_components_fk" parent="public.componentstechnologies" reftable="public.components" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="1" referred_columns="1" isForeignKey="1" refTable="public.components" refColumn="componentid" colName="componentid">
      <column ordinal="1" refOrdinal="1" refColumn="componentid" colName="componentid" />
    </constraint>
    <constraint name="public.componentstechnologies_technologies_fk" parent="public.componentstechnologies" reftable="public.technologies" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="2" referred_columns="1" isForeignKey="1" refTable="public.technologies" refColumn="technologyid" colName="technologyid">
      <column ordinal="2" refOrdinal="1" refColumn="technologyid" colName="technologyid" />
    </constraint>
    <constraint name="public.componentstechnologies_pk" parent="public.componentstechnologies" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1,2">
      <column ordinal="1" />
      <column ordinal="2" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.componentstechnologies_pk" parent="public.componentstechnologies" indexpages="2" numrows="13" indexrelid="113413" indrelid="113256" indnatts="2" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1 2" indcollation="0 0" indclass="1978 1978" indoption="0 0">
      <column index="public.componentstechnologies_pk" relkind="i" nspname="public" typname="int4" attname="componentid" attnum="1" />
      <column index="public.componentstechnologies_pk" relkind="i" nspname="public" typname="int4" attname="technologyid" attnum="2" />
    </index>
    <code>CREATE TABLE componentstechnologies (
    componentid integer NOT NULL,
    technologyid integer NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.functions" table_catalog="MarketplaceCore" table_schema="public" table_name="functions" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="64" pages="1" indexsizeKB="16">
    <column name="functionid" parent="public.functions" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="functions" column_name="functionid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="functionname" parent="public.functions" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="functions" column_name="functionname" ordinal_position="2" is_nullable="YES" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.functions_pk" parent="public.functions" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.functions_pk" parent="public.functions" indexpages="2" numrows="64" indexrelid="113415" indrelid="113261" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.functions_pk" relkind="i" nspname="public" typname="int4" attname="functionid" attnum="1" />
    </index>
    <code>CREATE TABLE functions (
    functionid integer NOT NULL,
    functionname character varying(250)
)</code>
  </table>
  <table xtype="U" datasizeKB="64" name="public.licenseorder" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="688" pages="8" indexsizeKB="32">
    <column name="licenseorderid" parent="public.licenseorder" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" column_name="licenseorderid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="licenseorderuuid" parent="public.licenseorder" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" column_name="licenseorderuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="ticketid" parent="public.licenseorder" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" column_name="ticketid" ordinal_position="3" is_nullable="YES" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="offerid" parent="public.licenseorder" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" column_name="offerid" ordinal_position="4" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="activatedat" parent="public.licenseorder" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" column_name="activatedat" ordinal_position="5" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.licenseorder" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" column_name="createdat" ordinal_position="6" is_nullable="NO" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.licenseorder" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="licenseorder" column_name="createdby" ordinal_position="7" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.licenseorder_offer_fk" parent="public.licenseorder" reftable="public.offer" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="4" referred_columns="1" isForeignKey="1" refTable="public.offer" refColumn="offerid" colName="offerid">
      <column ordinal="4" refOrdinal="1" refColumn="offerid" colName="offerid" />
    </constraint>
    <constraint name="public.licenseorder_pk" parent="public.licenseorder" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="32" name="public.licenseorder_pk" parent="public.licenseorder" indexpages="4" numrows="688" indexrelid="113417" indrelid="113264" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.licenseorder_pk" relkind="i" nspname="public" typname="int4" attname="licenseorderid" attnum="1" />
    </index>
    <code>CREATE TABLE licenseorder (
    licenseorderid integer NOT NULL,
    licenseorderuuid uuid,
    ticketid character varying(32672),
    offerid integer NOT NULL,
    activatedat timestamp without time zone,
    createdat timestamp without time zone NOT NULL,
    createdby uuid NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.logstatus" table_catalog="MarketplaceCore" table_schema="public" table_name="logstatus" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="3" pages="1" indexsizeKB="16">
    <column name="logstatusid" parent="public.logstatus" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="logstatus" column_name="logstatusid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="logstatus" parent="public.logstatus" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="logstatus" column_name="logstatus" ordinal_position="2" is_nullable="YES" data_type="character varying" character_maximum_length="50" character_octet_length="200" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="logstatusdescription" parent="public.logstatus" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="logstatus" column_name="logstatusdescription" ordinal_position="3" is_nullable="YES" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.logstatus_pk" parent="public.logstatus" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.logstatus_pk" parent="public.logstatus" indexpages="2" numrows="3" indexrelid="113419" indrelid="113274" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.logstatus_pk" relkind="i" nspname="public" typname="int4" attname="logstatusid" attnum="1" />
    </index>
    <code>CREATE TABLE logstatus (
    logstatusid integer NOT NULL,
    logstatus character varying(50),
    logstatusdescription character varying(250)
)</code>
  </table>
  <table xtype="U" datasizeKB="1912" name="public.logtable" table_catalog="MarketplaceCore" table_schema="public" table_name="logtable" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="5586" pages="239" indexsizeKB="144">
    <column name="logid" parent="public.logtable" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="logtable" column_name="logid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="logstatusid" parent="public.logtable" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="logtable" column_name="logstatusid" ordinal_position="2" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="logmessage" parent="public.logtable" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="logtable" column_name="logmessage" ordinal_position="3" is_nullable="NO" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="logobjectname" parent="public.logtable" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="logtable" column_name="logobjectname" ordinal_position="4" is_nullable="YES" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="parameters" parent="public.logtable" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="logtable" column_name="parameters" ordinal_position="5" is_nullable="YES" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.logtable" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="logtable" column_name="createdat" ordinal_position="6" is_nullable="NO" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.logtable_logstatus_fk" parent="public.logtable" reftable="public.logstatus" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="2" referred_columns="1" isForeignKey="1" refTable="public.logstatus" refColumn="logstatusid" colName="logstatusid">
      <column ordinal="2" refOrdinal="1" refColumn="logstatusid" colName="logstatusid" />
    </constraint>
    <constraint name="public.logtable_pk" parent="public.logtable" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="144" name="public.logtable_pk" parent="public.logtable" indexpages="18" numrows="5586" indexrelid="113421" indrelid="113277" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.logtable_pk" relkind="i" nspname="public" typname="int4" attname="logid" attnum="1" />
    </index>
    <code>CREATE TABLE logtable (
    logid integer NOT NULL,
    logstatusid integer NOT NULL,
    logmessage character varying(32672) NOT NULL,
    logobjectname character varying(250),
    parameters character varying(32672),
    createdat timestamp without time zone NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="64" name="public.offer" table_catalog="MarketplaceCore" table_schema="public" table_name="offer" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="762" pages="8" indexsizeKB="40">
    <column name="offerid" parent="public.offer" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="offer" column_name="offerid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="offeruuid" parent="public.offer" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="offer" column_name="offeruuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="paymentinvoiceid" parent="public.offer" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="offer" column_name="paymentinvoiceid" ordinal_position="3" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.offer" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="offer" column_name="createdat" ordinal_position="4" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.offer" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="offer" column_name="createdby" ordinal_position="5" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.offer_paymentinvoice_fk" parent="public.offer" reftable="public.paymentinvoice" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="3" referred_columns="1" isForeignKey="1" refTable="public.paymentinvoice" refColumn="paymentinvoiceid" colName="paymentinvoiceid">
      <column ordinal="3" refOrdinal="1" refColumn="paymentinvoiceid" colName="paymentinvoiceid" />
    </constraint>
    <constraint name="public.offer_pk" parent="public.offer" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="40" name="public.offer_pk" parent="public.offer" indexpages="5" numrows="762" indexrelid="113423" indrelid="113283" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.offer_pk" relkind="i" nspname="public" typname="int4" attname="offerid" attnum="1" />
    </index>
    <code>CREATE TABLE offer (
    offerid integer NOT NULL,
    offeruuid uuid,
    paymentinvoiceid integer NOT NULL,
    createdat timestamp without time zone,
    createdby uuid NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="64" name="public.offerrequest" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequest" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="764" pages="8" indexsizeKB="40">
    <column name="offerrequestid" parent="public.offerrequest" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequest" column_name="offerrequestid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="offerrequestuuid" parent="public.offerrequest" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequest" column_name="offerrequestuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="hsmid" parent="public.offerrequest" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequest" column_name="hsmid" ordinal_position="3" is_nullable="YES" data_type="character varying" character_octet_length="1073741824" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.offerrequest" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequest" column_name="createdat" ordinal_position="4" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="requestedby" parent="public.offerrequest" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequest" column_name="requestedby" ordinal_position="5" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.offerrequest_pk" parent="public.offerrequest" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="40" name="public.offerrequest_pk" parent="public.offerrequest" indexpages="5" numrows="764" indexrelid="113425" indrelid="113288" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.offerrequest_pk" relkind="i" nspname="public" typname="int4" attname="offerrequestid" attnum="1" />
    </index>
    <code>CREATE TABLE offerrequest (
    offerrequestid integer NOT NULL,
    offerrequestuuid uuid,
    hsmid character varying,
    createdat timestamp without time zone,
    requestedby uuid NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="40" name="public.offerrequestitems" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequestitems" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="764" pages="5" indexsizeKB="40">
    <column name="offerrequestitemid" parent="public.offerrequestitems" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequestitems" column_name="offerrequestitemid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="offerrequestid" parent="public.offerrequestitems" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequestitems" column_name="offerrequestid" ordinal_position="2" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydataid" parent="public.offerrequestitems" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequestitems" column_name="technologydataid" ordinal_position="3" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="amount" parent="public.offerrequestitems" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="offerrequestitems" column_name="amount" ordinal_position="4" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.offerrequestitems_offerrequest_fk" parent="public.offerrequestitems" reftable="public.offerrequest" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="2" referred_columns="1" isForeignKey="1" refTable="public.offerrequest" refColumn="offerrequestid" colName="offerrequestid">
      <column ordinal="2" refOrdinal="1" refColumn="offerrequestid" colName="offerrequestid" />
    </constraint>
    <constraint name="public.offerrequestitems_technologydata_fk" parent="public.offerrequestitems" reftable="public.technologydata" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="3" referred_columns="1" isForeignKey="1" refTable="public.technologydata" refColumn="technologydataid" colName="technologydataid">
      <column ordinal="3" refOrdinal="1" refColumn="technologydataid" colName="technologydataid" />
    </constraint>
    <constraint name="public.offerrequestitems_pk" parent="public.offerrequestitems" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1,2,3">
      <column ordinal="1" />
      <column ordinal="2" />
      <column ordinal="3" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="40" name="public.offerrequestitems_pk" parent="public.offerrequestitems" indexpages="5" numrows="764" indexrelid="113427" indrelid="113298" indnatts="3" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1 2 3" indcollation="0 0 0" indclass="1978 1978 1978" indoption="0 0 0">
      <column index="public.offerrequestitems_pk" relkind="i" nspname="public" typname="int4" attname="offerrequestitemid" attnum="1" />
      <column index="public.offerrequestitems_pk" relkind="i" nspname="public" typname="int4" attname="offerrequestid" attnum="2" />
      <column index="public.offerrequestitems_pk" relkind="i" nspname="public" typname="int4" attname="technologydataid" attnum="3" />
    </index>
    <code>CREATE TABLE offerrequestitems (
    offerrequestitemid integer NOT NULL,
    offerrequestid integer NOT NULL,
    technologydataid integer NOT NULL,
    amount integer NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="0" name="public.patches" table_catalog="MarketplaceCore" table_schema="public" table_name="patches" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="0" pages="0" indexsizeKB="0">
    <column name="patchname" parent="public.patches" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="patches" column_name="patchname" ordinal_position="1" is_nullable="YES" data_type="character varying" character_octet_length="1073741824" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="patchnumber" parent="public.patches" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="patches" column_name="patchnumber" ordinal_position="2" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="patchdescription" parent="public.patches" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="patches" column_name="patchdescription" ordinal_position="3" is_nullable="YES" data_type="character varying" character_octet_length="1073741824" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="startat" parent="public.patches" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="patches" column_name="startat" ordinal_position="4" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="endat" parent="public.patches" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="patches" column_name="endat" ordinal_position="5" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="status" parent="public.patches" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="patches" column_name="status" ordinal_position="6" is_nullable="YES" data_type="character varying" character_octet_length="1073741824" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <code>CREATE TABLE patches (
    patchname character varying,
    patchnumber integer,
    patchdescription character varying,
    startat timestamp without time zone,
    endat timestamp without time zone,
    status character varying
)</code>
  </table>
  <table xtype="U" datasizeKB="104" name="public.payment" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="714" pages="13" indexsizeKB="32">
    <column name="paymentid" parent="public.payment" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="paymentid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="paymentuuid" parent="public.payment" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="paymentuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="paymentinvoiceid" parent="public.payment" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="paymentinvoiceid" ordinal_position="3" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="paydate" parent="public.payment" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="paydate" ordinal_position="4" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="confidencestate" parent="public.payment" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="confidencestate" ordinal_position="5" is_nullable="YES" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="depth" parent="public.payment" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="depth" ordinal_position="6" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="bitcointransaction" parent="public.payment" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="bitcointransaction" ordinal_position="7" is_nullable="YES" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="extinvoiceid" parent="public.payment" ordinal="8" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="extinvoiceid" ordinal_position="8" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="8" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.payment" ordinal="9" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="createdat" ordinal_position="9" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="9" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.payment" ordinal="10" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="createdby" ordinal_position="10" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="10" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedby" parent="public.payment" ordinal="11" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="updatedby" ordinal_position="11" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="11" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedat" parent="public.payment" ordinal="12" table_catalog="MarketplaceCore" table_schema="public" table_name="payment" column_name="updatedat" ordinal_position="12" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="12" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.payment_paymentinvoice_fk" parent="public.payment" reftable="public.paymentinvoice" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="3" referred_columns="1" isForeignKey="1" refTable="public.paymentinvoice" refColumn="paymentinvoiceid" colName="paymentinvoiceid">
      <column ordinal="3" refOrdinal="1" refColumn="paymentinvoiceid" colName="paymentinvoiceid" />
    </constraint>
    <constraint name="public.payment_pk" parent="public.payment" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="32" name="public.payment_pk" parent="public.payment" indexpages="4" numrows="714" indexrelid="113429" indrelid="113307" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.payment_pk" relkind="i" nspname="public" typname="int4" attname="paymentid" attnum="1" />
    </index>
    <code>CREATE TABLE payment (
    paymentid integer NOT NULL,
    paymentuuid uuid,
    paymentinvoiceid integer NOT NULL,
    paydate timestamp without time zone,
    confidencestate character varying(250),
    depth integer,
    bitcointransaction character varying(32672),
    extinvoiceid uuid,
    createdat timestamp without time zone,
    createdby uuid NOT NULL,
    updatedby uuid,
    updatedat timestamp without time zone
)</code>
  </table>
  <table xtype="U" datasizeKB="248" name="public.paymentinvoice" table_catalog="MarketplaceCore" table_schema="public" table_name="paymentinvoice" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="762" pages="31" indexsizeKB="40">
    <column name="paymentinvoiceid" parent="public.paymentinvoice" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="paymentinvoice" column_name="paymentinvoiceid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="paymentinvoiceuuid" parent="public.paymentinvoice" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="paymentinvoice" column_name="paymentinvoiceuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="offerrequestid" parent="public.paymentinvoice" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="paymentinvoice" column_name="offerrequestid" ordinal_position="3" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="invoice" parent="public.paymentinvoice" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="paymentinvoice" column_name="invoice" ordinal_position="4" is_nullable="YES" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.paymentinvoice" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="paymentinvoice" column_name="createdat" ordinal_position="5" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.paymentinvoice" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="paymentinvoice" column_name="createdby" ordinal_position="6" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.paymentinvoice_offerrequest_fk" parent="public.paymentinvoice" reftable="public.offerrequest" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="3" referred_columns="1" isForeignKey="1" refTable="public.offerrequest" refColumn="offerrequestid" colName="offerrequestid">
      <column ordinal="3" refOrdinal="1" refColumn="offerrequestid" colName="offerrequestid" />
    </constraint>
    <constraint name="public.paymentinvoice_pk" parent="public.paymentinvoice" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="40" name="public.paymentinvoice_pk" parent="public.paymentinvoice" indexpages="5" numrows="762" indexrelid="113431" indrelid="113315" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.paymentinvoice_pk" relkind="i" nspname="public" typname="int4" attname="paymentinvoiceid" attnum="1" />
    </index>
    <code>CREATE TABLE paymentinvoice (
    paymentinvoiceid integer NOT NULL,
    paymentinvoiceuuid uuid,
    offerrequestid integer NOT NULL,
    invoice character varying(32672),
    createdat timestamp without time zone,
    createdby uuid NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.roles" table_catalog="MarketplaceCore" table_schema="public" table_name="roles" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="7" pages="1" indexsizeKB="16">
    <column name="roleid" parent="public.roles" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="roles" column_name="roleid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="rolename" parent="public.roles" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="roles" column_name="rolename" ordinal_position="2" is_nullable="YES" data_type="character varying" character_octet_length="1073741824" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="roledescription" parent="public.roles" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="roles" column_name="roledescription" ordinal_position="3" is_nullable="YES" data_type="character varying" character_octet_length="1073741824" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.roles_pk" parent="public.roles" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.roles_pk" parent="public.roles" indexpages="2" numrows="7" indexrelid="113433" indrelid="113327" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.roles_pk" relkind="i" nspname="public" typname="int4" attname="roleid" attnum="1" />
    </index>
    <code>CREATE TABLE roles (
    roleid integer NOT NULL,
    rolename character varying,
    roledescription character varying
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.rolespermissions" table_catalog="MarketplaceCore" table_schema="public" table_name="rolespermissions" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="128" pages="1" indexsizeKB="16">
    <column name="roleid" parent="public.rolespermissions" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="rolespermissions" column_name="roleid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="functionid" parent="public.rolespermissions" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="rolespermissions" column_name="functionid" ordinal_position="2" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.rolespermissions_functions_fk" parent="public.rolespermissions" reftable="public.functions" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="2" referred_columns="1" isForeignKey="1" refTable="public.functions" refColumn="functionid" colName="functionid">
      <column ordinal="2" refOrdinal="1" refColumn="functionid" colName="functionid" />
    </constraint>
    <constraint name="public.rolespermissions_roles_fk" parent="public.rolespermissions" reftable="public.roles" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="1" referred_columns="1" isForeignKey="1" refTable="public.roles" refColumn="roleid" colName="roleid">
      <column ordinal="1" refOrdinal="1" refColumn="roleid" colName="roleid" />
    </constraint>
    <constraint name="public.rolespermissions_pk" parent="public.rolespermissions" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1,2">
      <column ordinal="1" />
      <column ordinal="2" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.rolespermissions_pk" parent="public.rolespermissions" indexpages="2" numrows="128" indexrelid="113435" indrelid="113333" indnatts="2" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1 2" indcollation="0 0" indclass="1978 1978" indoption="0 0">
      <column index="public.rolespermissions_pk" relkind="i" nspname="public" typname="int4" attname="roleid" attnum="1" />
      <column index="public.rolespermissions_pk" relkind="i" nspname="public" typname="int4" attname="functionid" attnum="2" />
    </index>
    <code>CREATE TABLE rolespermissions (
    roleid integer NOT NULL,
    functionid integer NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="0" name="public.tags" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="0" pages="0" indexsizeKB="8">
    <column name="tagid" parent="public.tags" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" column_name="tagid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="taguuid" parent="public.tags" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" column_name="taguuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="tagname" parent="public.tags" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" column_name="tagname" ordinal_position="3" is_nullable="NO" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.tags" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" column_name="createdat" ordinal_position="4" is_nullable="NO" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.tags" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" column_name="createdby" ordinal_position="5" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedat" parent="public.tags" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" column_name="updatedat" ordinal_position="6" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedby" parent="public.tags" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="tags" column_name="updatedby" ordinal_position="7" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.tags_pk" parent="public.tags" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="8" name="public.tags_pk" parent="public.tags" indexpages="1" numrows="0" indexrelid="113437" indrelid="113338" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.tags_pk" relkind="i" nspname="public" typname="int4" attname="tagid" attnum="1" />
    </index>
    <code>CREATE TABLE tags (
    tagid integer NOT NULL,
    taguuid uuid,
    tagname character varying(250) NOT NULL,
    createdat timestamp without time zone NOT NULL,
    createdby uuid NOT NULL,
    updatedat timestamp without time zone,
    updatedby uuid
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.technologies" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="1" pages="1" indexsizeKB="32">
    <column name="technologyid" parent="public.technologies" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="technologyid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologyuuid" parent="public.technologies" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="technologyuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologyname" parent="public.technologies" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="technologyname" ordinal_position="3" is_nullable="NO" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydescription" parent="public.technologies" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="technologydescription" ordinal_position="4" is_nullable="YES" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.technologies" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="createdat" ordinal_position="5" is_nullable="NO" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.technologies" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="createdby" ordinal_position="6" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedat" parent="public.technologies" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="updatedat" ordinal_position="7" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedby" parent="public.technologies" ordinal="8" table_catalog="MarketplaceCore" table_schema="public" table_name="technologies" column_name="updatedby" ordinal_position="8" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="8" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.technologies_pk" parent="public.technologies" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <constraint name="public.technologies__un" parent="public.technologies" contype="u" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="3">
      <column ordinal="3" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.technologies__un" parent="public.technologies" indexpages="2" numrows="1" indexrelid="113439" indrelid="113341" indnatts="1" indisunique="1" indisprimary="0" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="3" indcollation="100" indclass="3126" indoption="0">
      <column index="public.technologies__un" relkind="i" nspname="public" typname="varchar" attname="technologyname" attnum="1" />
    </index>
    <index xtype="INDEX" indexsizeKB="16" name="public.technologies_pk" parent="public.technologies" indexpages="2" numrows="1" indexrelid="113441" indrelid="113341" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.technologies_pk" relkind="i" nspname="public" typname="int4" attname="technologyid" attnum="1" />
    </index>
    <code>CREATE TABLE componentstechnologies (
    componentid integer NOT NULL,
    technologyid integer NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="72" name="public.technologydata" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="60" pages="9" indexsizeKB="16">
    <column name="technologydataid" parent="public.technologydata" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologydataid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydatauuid" parent="public.technologydata" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologydatauuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydataname" parent="public.technologydata" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologydataname" ordinal_position="3" is_nullable="NO" data_type="character varying" character_maximum_length="250" character_octet_length="1000" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologyid" parent="public.technologydata" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologyid" ordinal_position="4" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydata" parent="public.technologydata" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologydata" ordinal_position="5" is_nullable="NO" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="productcode" parent="public.technologydata" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="productcode" ordinal_position="7" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydatadescription" parent="public.technologydata" ordinal="8" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologydatadescription" ordinal_position="8" is_nullable="YES" data_type="character varying" character_maximum_length="32672" character_octet_length="130688" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="8" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydatathumbnail" parent="public.technologydata" ordinal="9" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologydatathumbnail" ordinal_position="9" is_nullable="YES" data_type="bytea" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="bytea" dtd_identifier="9" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="technologydataimgref" parent="public.technologydata" ordinal="10" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="technologydataimgref" ordinal_position="10" is_nullable="YES" data_type="character varying" character_octet_length="1073741824" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="varchar" dtd_identifier="10" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.technologydata" ordinal="11" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="createdat" ordinal_position="11" is_nullable="NO" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="11" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.technologydata" ordinal="12" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="createdby" ordinal_position="12" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="12" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedat" parent="public.technologydata" ordinal="13" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="updatedat" ordinal_position="13" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="13" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedby" parent="public.technologydata" ordinal="14" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="updatedby" ordinal_position="14" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="14" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="deleted" parent="public.technologydata" ordinal="15" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="deleted" ordinal_position="15" is_nullable="YES" data_type="boolean" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="bool" dtd_identifier="15" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="licensefee" parent="public.technologydata" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydata" column_name="licensefee" ordinal_position="6" is_nullable="NO" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int8" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.technologydata_technologies_fk" parent="public.technologydata" reftable="public.technologies" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="4" referred_columns="1" isForeignKey="1" refTable="public.technologies" refColumn="technologyid" colName="technologyid">
      <column ordinal="4" refOrdinal="1" refColumn="technologyid" colName="technologyid" />
    </constraint>
    <constraint name="public.technologydata_pk" parent="public.technologydata" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.technologydata_pk" parent="public.technologydata" indexpages="2" numrows="60" indexrelid="113443" indrelid="113347" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.technologydata_pk" relkind="i" nspname="public" typname="int4" attname="technologydataid" attnum="1" />
    </index>
    <code>CREATE TABLE technologydata (
    technologydataid integer NOT NULL,
    technologydatauuid uuid,
    technologydataname character varying(250) NOT NULL,
    technologyid integer NOT NULL,
    technologydata character varying(32672) NOT NULL,
    licensefee bigint NOT NULL,
    productcode integer,
    technologydatadescription character varying(32672),
    technologydatathumbnail bytea,
    technologydataimgref character varying,
    createdat timestamp without time zone NOT NULL,
    createdby uuid NOT NULL,
    updatedat timestamp without time zone,
    updatedby uuid,
    deleted boolean
)</code>
  </table>
  <table xtype="U" datasizeKB="8" name="public.technologydatacomponents" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydatacomponents" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="182" pages="1" indexsizeKB="16">
    <column name="technologydataid" parent="public.technologydatacomponents" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydatacomponents" column_name="technologydataid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="componentid" parent="public.technologydatacomponents" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydatacomponents" column_name="componentid" ordinal_position="2" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.technologydatacomponents_technologydata_fk" parent="public.technologydatacomponents" reftable="public.technologydata" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="1" referred_columns="1" isForeignKey="1" refTable="public.technologydata" refColumn="technologydataid" colName="technologydataid">
      <column ordinal="1" refOrdinal="1" refColumn="technologydataid" colName="technologydataid" />
    </constraint>
    <constraint name="public.technologydatacomponents_components_fk" parent="public.technologydatacomponents" reftable="public.components" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="2" referred_columns="1" isForeignKey="1" refTable="public.components" refColumn="componentid" colName="componentid">
      <column ordinal="2" refOrdinal="1" refColumn="componentid" colName="componentid" />
    </constraint>
    <constraint name="public.technologydatacomponents_pk" parent="public.technologydatacomponents" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1,2">
      <column ordinal="1" />
      <column ordinal="2" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="16" name="public.technologydatacomponents_pk" parent="public.technologydatacomponents" indexpages="2" numrows="182" indexrelid="113445" indrelid="113353" indnatts="2" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1 2" indcollation="0 0" indclass="1978 1978" indoption="0 0">
      <column index="public.technologydatacomponents_pk" relkind="i" nspname="public" typname="int4" attname="technologydataid" attnum="1" />
      <column index="public.technologydatacomponents_pk" relkind="i" nspname="public" typname="int4" attname="componentid" attnum="2" />
    </index>
    <code>CREATE TABLE technologydatacomponents (
    technologydataid integer NOT NULL,
    componentid integer NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="0" name="public.technologydatatags" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydatatags" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="0" pages="0" indexsizeKB="8">
    <column name="technologydataid" parent="public.technologydatatags" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydatatags" column_name="technologydataid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="tagid" parent="public.technologydatatags" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="technologydatatags" column_name="tagid" ordinal_position="2" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.technologydatatags_tags_fk" parent="public.technologydatatags" reftable="public.tags" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="2" referred_columns="1" isForeignKey="1" refTable="public.tags" refColumn="tagid" colName="tagid">
      <column ordinal="2" refOrdinal="1" refColumn="tagid" colName="tagid" />
    </constraint>
    <constraint name="public.technologydatatags_technologydata_fk" parent="public.technologydatatags" reftable="public.technologydata" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="1" referred_columns="1" isForeignKey="1" refTable="public.technologydata" refColumn="technologydataid" colName="technologydataid">
      <column ordinal="1" refOrdinal="1" refColumn="technologydataid" colName="technologydataid" />
    </constraint>
    <constraint name="public.technologydatatag_pk" parent="public.technologydatatags" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1,2">
      <column ordinal="1" />
      <column ordinal="2" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="8" name="public.technologydatatag_pk" parent="public.technologydatatags" indexpages="1" numrows="0" indexrelid="113447" indrelid="113358" indnatts="2" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1 2" indcollation="0 0" indclass="1978 1978" indoption="0 0">
      <column index="public.technologydatatag_pk" relkind="i" nspname="public" typname="int4" attname="technologydataid" attnum="1" />
      <column index="public.technologydatatag_pk" relkind="i" nspname="public" typname="int4" attname="tagid" attnum="2" />
    </index>
    <code>CREATE TABLE technologydatatags (
    technologydataid integer NOT NULL,
    tagid integer NOT NULL
)</code>
  </table>
  <table xtype="U" datasizeKB="104" name="public.transactions" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" table_type="BASE TABLE" is_insertable_into="YES" is_typed="NO" rowcount="764" pages="13" indexsizeKB="40">
    <column name="transactionid" parent="public.transactions" ordinal="1" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="transactionid" ordinal_position="1" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="1" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="transactionuuid" parent="public.transactions" ordinal="2" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="transactionuuid" ordinal_position="2" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="2" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="buyerid" parent="public.transactions" ordinal="3" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="buyerid" ordinal_position="3" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="3" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="offerid" parent="public.transactions" ordinal="4" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="offerid" ordinal_position="4" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="4" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="offerrequestid" parent="public.transactions" ordinal="5" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="offerrequestid" ordinal_position="5" is_nullable="NO" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="5" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="paymentid" parent="public.transactions" ordinal="6" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="paymentid" ordinal_position="6" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="6" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="paymentinvoiceid" parent="public.transactions" ordinal="7" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="paymentinvoiceid" ordinal_position="7" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="7" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="licenseorderid" parent="public.transactions" ordinal="8" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="licenseorderid" ordinal_position="8" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="int4" dtd_identifier="8" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdat" parent="public.transactions" ordinal="9" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="createdat" ordinal_position="9" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="9" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="createdby" parent="public.transactions" ordinal="10" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="createdby" ordinal_position="10" is_nullable="NO" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="10" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedat" parent="public.transactions" ordinal="11" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="updatedat" ordinal_position="11" is_nullable="YES" data_type="timestamp without time zone" datetime_precision="6" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="timestamp" dtd_identifier="11" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <column name="updatedby" parent="public.transactions" ordinal="12" table_catalog="MarketplaceCore" table_schema="public" table_name="transactions" column_name="updatedby" ordinal_position="12" is_nullable="YES" data_type="uuid" udt_catalog="MarketplaceCore" udt_schema="pg_catalog" udt_name="uuid" dtd_identifier="12" is_self_referencing="NO" is_identity="NO" is_generated="NEVER" is_updatable="YES" />
    <constraint name="public.transactions_payment_fk" parent="public.transactions" reftable="public.payment" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="6" referred_columns="1" isForeignKey="1" refTable="public.payment" refColumn="paymentid" colName="paymentid">
      <column ordinal="6" refOrdinal="1" refColumn="paymentid" colName="paymentid" />
    </constraint>
    <constraint name="public.transactions_offer_fk" parent="public.transactions" reftable="public.offer" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="4" referred_columns="1" isForeignKey="1" refTable="public.offer" refColumn="offerid" colName="offerid">
      <column ordinal="4" refOrdinal="1" refColumn="offerid" colName="offerid" />
    </constraint>
    <constraint name="public.transactions_offerrequest_fk" parent="public.transactions" reftable="public.offerrequest" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="5" referred_columns="1" isForeignKey="1" refTable="public.offerrequest" refColumn="offerrequestid" colName="offerrequestid">
      <column ordinal="5" refOrdinal="1" refColumn="offerrequestid" colName="offerrequestid" />
    </constraint>
    <constraint name="public.transactions_paymentinvoice_fk" parent="public.transactions" reftable="public.paymentinvoice" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="7" referred_columns="1" isForeignKey="1" refTable="public.paymentinvoice" refColumn="paymentinvoiceid" colName="paymentinvoiceid">
      <column ordinal="7" refOrdinal="1" refColumn="paymentinvoiceid" colName="paymentinvoiceid" />
    </constraint>
    <constraint name="public.transactions_licenseorder_fk" parent="public.transactions" reftable="public.licenseorder" contype="f" condeferrable="0" condeferred="0" confupdtype="a" confdeltype="a" confmatchtype="s" constrained_columns="8" referred_columns="1" isForeignKey="1" refTable="public.licenseorder" refColumn="licenseorderid" colName="licenseorderid">
      <column ordinal="8" refOrdinal="1" refColumn="licenseorderid" colName="licenseorderid" />
    </constraint>
    <constraint name="public.transactions_pk" parent="public.transactions" contype="p" condeferrable="0" condeferred="0" confupdtype="" confdeltype="" confmatchtype="" constrained_columns="1">
      <column ordinal="1" />
    </constraint>
    <index xtype="INDEX" indexsizeKB="40" name="public.transactions_pk" parent="public.transactions" indexpages="5" numrows="764" indexrelid="113449" indrelid="113365" indnatts="1" indisunique="1" indisprimary="1" indisexclusion="0" indimmediate="1" indisclustered="0" indisvalid="1" indcheckxmin="0" indisready="1" indislive="1" indisreplident="0" indkey="1" indcollation="0" indclass="1978" indoption="0">
      <column index="public.transactions_pk" relkind="i" nspname="public" typname="int4" attname="transactionid" attnum="1" />
    </index>
    <code>CREATE TABLE transactions (
    transactionid integer NOT NULL,
    transactionuuid uuid,
    buyerid uuid,
    offerid integer,
    offerrequestid integer NOT NULL,
    paymentid integer,
    paymentinvoiceid integer,
    licenseorderid integer,
    createdat timestamp without time zone,
    createdby uuid NOT NULL,
    updatedat timestamp without time zone,
    updatedby uuid
)</code>
  </table>
  <schema xtype="SCHEMA" name="pg_toast_temp_1" owner="postgres" database="MarketplaceCore" />
  <schema xtype="SCHEMA" name="public" owner="postgres" database="MarketplaceCore" />
  <userDefinedType xtype="UDT" name="public._attributes" shortname="_attributes" schema="public" length="-1" typnotnull="0" elementtype="attributes" />
  <userDefinedType xtype="UDT" name="public._components" shortname="_components" schema="public" length="-1" typnotnull="0" elementtype="components" />
  <userDefinedType xtype="UDT" name="public._componentsattribute" shortname="_componentsattribute" schema="public" length="-1" typnotnull="0" elementtype="componentsattribute" />
  <userDefinedType xtype="UDT" name="public._componentstechnologies" shortname="_componentstechnologies" schema="public" length="-1" typnotnull="0" elementtype="componentstechnologies" />
  <userDefinedType xtype="UDT" name="public._dblink_pkey_results" shortname="_dblink_pkey_results" schema="public" length="-1" typnotnull="0" elementtype="dblink_pkey_results" />
  <userDefinedType xtype="UDT" name="public._functions" shortname="_functions" schema="public" length="-1" typnotnull="0" elementtype="functions" />
  <userDefinedType xtype="UDT" name="public._licenseorder" shortname="_licenseorder" schema="public" length="-1" typnotnull="0" elementtype="licenseorder" />
  <userDefinedType xtype="UDT" name="public._logstatus" shortname="_logstatus" schema="public" length="-1" typnotnull="0" elementtype="logstatus" />
  <userDefinedType xtype="UDT" name="public._logtable" shortname="_logtable" schema="public" length="-1" typnotnull="0" elementtype="logtable" />
  <userDefinedType xtype="UDT" name="public._offer" shortname="_offer" schema="public" length="-1" typnotnull="0" elementtype="offer" />
  <userDefinedType xtype="UDT" name="public._offerrequest" shortname="_offerrequest" schema="public" length="-1" typnotnull="0" elementtype="offerrequest" />
  <userDefinedType xtype="UDT" name="public._offerrequestitems" shortname="_offerrequestitems" schema="public" length="-1" typnotnull="0" elementtype="offerrequestitems" />
  <userDefinedType xtype="UDT" name="public._patches" shortname="_patches" schema="public" length="-1" typnotnull="0" elementtype="patches" />
  <userDefinedType xtype="UDT" name="public._payment" shortname="_payment" schema="public" length="-1" typnotnull="0" elementtype="payment" />
  <userDefinedType xtype="UDT" name="public._paymentinvoice" shortname="_paymentinvoice" schema="public" length="-1" typnotnull="0" elementtype="paymentinvoice" />
  <userDefinedType xtype="UDT" name="public._roles" shortname="_roles" schema="public" length="-1" typnotnull="0" elementtype="roles" />
  <userDefinedType xtype="UDT" name="public._rolespermissions" shortname="_rolespermissions" schema="public" length="-1" typnotnull="0" elementtype="rolespermissions" />
  <userDefinedType xtype="UDT" name="public._tags" shortname="_tags" schema="public" length="-1" typnotnull="0" elementtype="tags" />
  <userDefinedType xtype="UDT" name="public._technologies" shortname="_technologies" schema="public" length="-1" typnotnull="0" elementtype="technologies" />
  <userDefinedType xtype="UDT" name="public._technologydata" shortname="_technologydata" schema="public" length="-1" typnotnull="0" elementtype="technologydata" />
  <userDefinedType xtype="UDT" name="public._technologydatacomponents" shortname="_technologydatacomponents" schema="public" length="-1" typnotnull="0" elementtype="technologydatacomponents" />
  <userDefinedType xtype="UDT" name="public._technologydatatags" shortname="_technologydatatags" schema="public" length="-1" typnotnull="0" elementtype="technologydatatags" />
  <userDefinedType xtype="UDT" name="public._transactions" shortname="_transactions" schema="public" length="-1" typnotnull="0" elementtype="transactions" />
  <userDefinedType xtype="UDT" name="public.dblink_pkey_results" shortname="dblink_pkey_results" schema="public" length="-1" typnotnull="0" relationname="dblink_pkey_results" relkind="c">
    <attribute parent="public.dblink_pkey_results" name="position" udt_catalog="MarketplaceCore" udt_schema="public" udt_name="dblink_pkey_results" attribute_name="position" ordinal_position="1" is_nullable="YES" data_type="integer" numeric_precision="32" numeric_precision_radix="2" numeric_scale="0" attribute_udt_catalog="MarketplaceCore" attribute_udt_schema="pg_catalog" attribute_udt_name="int4" dtd_identifier="1" is_derived_reference_attribute="NO" />
    <attribute parent="public.dblink_pkey_results" name="colname" udt_catalog="MarketplaceCore" udt_schema="public" udt_name="dblink_pkey_results" attribute_name="colname" ordinal_position="2" is_nullable="YES" data_type="text" character_octet_length="1073741824" attribute_udt_catalog="MarketplaceCore" attribute_udt_schema="pg_catalog" attribute_udt_name="text" dtd_identifier="2" is_derived_reference_attribute="NO" />
  </userDefinedType>
  <procedure xtype="FN" name="public.checkpermissions" routine_type="FUNCTION" return_type="pg_catalog.bool" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;	DECLARE	vIsAllowed boolean;&#xD;&#xA;		vFunctionId integer := (select functionId from functions where functionname = vFunctionName);&#xD;&#xA;	BEGIN&#xD;&#xA;		vIsAllowed := (select exists(select 1 from rolespermissions rp&#xD;&#xA;									 join roles ro on ro.roleid = ro.roleid&#xD;&#xA;									 where ro.rolename = ANY(vRoles)&#xD;&#xA;									 and functionId = vFunctionId));&#xD;&#xA;		if(vIsAllowed) then&#xD;&#xA;			return true;&#xD;&#xA;		else&#xD;&#xA;			return false;&#xD;&#xA;		end if;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="0" provolatile="v">
    <param parent="public.checkpermissions" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfunctionname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.checkpermissions" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION checkpermissions(vroles text[], vfunctionname character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
	DECLARE	vIsAllowed boolean;
		vFunctionId integer := (select functionId from functions where functionname = vFunctionName);
	BEGIN
		vIsAllowed := (select exists(select 1 from rolespermissions rp
									 join roles ro on ro.roleid = ro.roleid
									 where ro.rolename = ANY(vRoles)
									 and functionId = vFunctionId));
		if(vIsAllowed) then
			return true;
		else
			return false;
		end if;
	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createattribute" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vAttributeID integer := (select nextval('AttributeID'));&#xD;&#xA;		vAttributeUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vFunctionName varchar := 'CreateAttribute';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;      BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		INSERT INTO public.Attributes(AttributeID, AttributeUUID, AttributeName, CreatedBy, CreatedAt)&#xD;&#xA;		VALUES(vAttributeID, vAttributeUUID, vAttributeName, vCreatedBy, now());&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created Attribute sucessfully', 'CreateAttribute',&#xD;&#xA;                                'AttributeID: ' || cast(vAttributeID as varchar)&#xD;&#xA;				|| ', AttributeName: ' || vAttributeName&#xD;&#xA;				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select	AttributeUUID,&#xD;&#xA;			AttributeName,&#xD;&#xA;			CreatedAt at time zone 'utc',&#xD;&#xA;			vCreatedby&#xD;&#xA;		from attributes&#xD;&#xA;		where attributeuuid = vAttributeUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'CreateAttribute',&#xD;&#xA;                                'AttributeID: ' || cast(vAttributeID as varchar)&#xD;&#xA;				|| ', AttributeName: ' || vAttributeName&#xD;&#xA;				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        -- Return Error Code * -1&#xD;&#xA;		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateAttribute';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createattribute" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createattribute" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createattribute" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vattributename" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createattribute" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createattribute" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributeuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createattribute" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributename" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createattribute" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION createattribute(vattributename character varying, vcreatedby uuid, vroles text[]) RETURNS TABLE(attributeuuid uuid, attributename character varying, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vAttributeID integer := (select nextval('AttributeID'));
		vAttributeUUID uuid := (select uuid_generate_v4());
		vFunctionName varchar := 'CreateAttribute';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
      BEGIN

	IF(vIsAllowed) THEN
		INSERT INTO public.Attributes(AttributeID, AttributeUUID, AttributeName, CreatedBy, CreatedAt)
		VALUES(vAttributeID, vAttributeUUID, vAttributeName, vCreatedBy, now());
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created Attribute sucessfully', 'CreateAttribute',
                                'AttributeID: ' || cast(vAttributeID as varchar)
				|| ', AttributeName: ' || vAttributeName
				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select	AttributeUUID,
			AttributeName,
			CreatedAt at time zone 'utc',
			vCreatedby
		from attributes
		where attributeuuid = vAttributeUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'CreateAttribute',
                                'AttributeID: ' || cast(vAttributeID as varchar)
				|| ', AttributeName: ' || vAttributeName
				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));
        -- End Log if error
        -- Return Error Code * -1
		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateAttribute';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createcomponent" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vComponentID integer := (select nextval('ComponentID'));&#xD;&#xA;		vComponentUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vComponentParentID integer := (select componentid from components where componentuuid = vComponentParentUUID);&#xD;&#xA;		vFunctionName varchar := 'CreateComponent';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;      BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;        INSERT INTO components(ComponentID, ComponentUUID, ComponentParentID, ComponentName, ComponentDescription, CreatedBy, CreatedAt)&#xD;&#xA;        VALUES(vComponentID, vComponentUUID, vComponentParentID, vComponentName, vComponentDescription, vCreatedBy, now());&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created Component sucessfully', 'CreateComponent',&#xD;&#xA;                                'ComponentID: ' || cast(vComponentID as varchar) || ', '&#xD;&#xA;                                || 'ComponentParentID: ' || cast(vComponentParentID as varchar)&#xD;&#xA;                                || ', ComponentName: '&#xD;&#xA;                                || vComponentName&#xD;&#xA;                                || ', ComponentDescription: '&#xD;&#xA;                                || vComponentDescription&#xD;&#xA;                                || ', CreatedBy: '&#xD;&#xA;                                || cast(vCreatedBy as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	co.ComponentUUID,&#xD;&#xA;			co.ComponentName,&#xD;&#xA;			cs.ComponentName as componentParentName,&#xD;&#xA;			cs.ComponentUUID as componentParentUUID,&#xD;&#xA;			co.ComponentDescription,&#xD;&#xA;			co.CreatedAt at time zone 'utc',&#xD;&#xA;			vCreatedBy&#xD;&#xA;		from components co&#xD;&#xA;		left outer join components cs&#xD;&#xA;		on co.componentparentid = cs.componentid&#xD;&#xA;		where co.componentuuid = vComponentUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateComponent',&#xD;&#xA;                                'ComponentID: ' || cast(vComponentID as varchar) || ', '&#xD;&#xA;                                || 'ComponentParentID: ' || cast(vComponentParentID as varchar)&#xD;&#xA;                                || ', ComponentName: '&#xD;&#xA;                                || vComponentName&#xD;&#xA;                                || ', ComponentDescription: '&#xD;&#xA;                                || vComponentDescription&#xD;&#xA;                                || ', CreatedBy: '&#xD;&#xA;                                || cast(vCreatedBy as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateComponent';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createcomponent" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createcomponent" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentparentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createcomponent" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createcomponent" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createcomponent" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createcomponent" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createcomponent" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createcomponent" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createcomponent" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentdecription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createcomponent" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createcomponent" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createcomponent" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION createcomponent(vcomponentparentuuid uuid, vcomponentname character varying, vcomponentdescription character varying, vcreatedby uuid, vroles text[]) RETURNS TABLE(componentuuid uuid, componentname character varying, componentparentname character varying, componentparentuuid uuid, componentdecription character varying, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vComponentID integer := (select nextval('ComponentID'));
		vComponentUUID uuid := (select uuid_generate_v4());
		vComponentParentID integer := (select componentid from components where componentuuid = vComponentParentUUID);
		vFunctionName varchar := 'CreateComponent';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
      BEGIN

	IF(vIsAllowed) THEN

        INSERT INTO components(ComponentID, ComponentUUID, ComponentParentID, ComponentName, ComponentDescription, CreatedBy, CreatedAt)
        VALUES(vComponentID, vComponentUUID, vComponentParentID, vComponentName, vComponentDescription, vCreatedBy, now());

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created Component sucessfully', 'CreateComponent',
                                'ComponentID: ' || cast(vComponentID as varchar) || ', '
                                || 'ComponentParentID: ' || cast(vComponentParentID as varchar)
                                || ', ComponentName: '
                                || vComponentName
                                || ', ComponentDescription: '
                                || vComponentDescription
                                || ', CreatedBy: '
                                || cast(vCreatedBy as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	co.ComponentUUID,
			co.ComponentName,
			cs.ComponentName as componentParentName,
			cs.ComponentUUID as componentParentUUID,
			co.ComponentDescription,
			co.CreatedAt at time zone 'utc',
			vCreatedBy
		from components co
		left outer join components cs
		on co.componentparentid = cs.componentid
		where co.componentuuid = vComponentUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateComponent',
                                'ComponentID: ' || cast(vComponentID as varchar) || ', '
                                || 'ComponentParentID: ' || cast(vComponentParentID as varchar)
                                || ', ComponentName: '
                                || vComponentName
                                || ', ComponentDescription: '
                                || vComponentDescription
                                || ', CreatedBy: '
                                || cast(vCreatedBy as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateComponent';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createcomponentsattribute" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;  	DECLARE vAttributeName text;&#xD;&#xA;		vAttrID int;&#xD;&#xA;		vComponentID integer := (select componentid from components where componentuuid = vComponentUUID);&#xD;&#xA;		vFunctionName varchar := 'CreateComponentsAttribute';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;        FOREACH vAttributeName in array vAttributeList&#xD;&#xA;        LOOP&#xD;&#xA;        	 vAttrID := (select attributes.attributeID from public.attributes where attributename = vAttributeName);&#xD;&#xA;         	 INSERT INTO ComponentsAttribute(ComponentID, AttributeID)&#xD;&#xA;             VALUES (vComponentID, vAttrID);&#xD;&#xA;        END LOOP;&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created relation from component to attributes sucessfully', 'CreateComponentsAttribute',&#xD;&#xA;                                'ComponentID: ' || cast(vComponentID as varchar)&#xD;&#xA;                                || ', AttributeList: '&#xD;&#xA;                                || cast(vAttributeList as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	vComponentUUId,&#xD;&#xA;				array_agg(att.AttributeUUID)&#xD;&#xA;		from componentsattribute ca&#xD;&#xA;		join attributes att&#xD;&#xA;		on ca.attributeid = att.attributeid&#xD;&#xA;		where componentid = vComponentID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateComponentsAttribute',&#xD;&#xA;                                'ComponentID: ' || cast(vComponentID as varchar)&#xD;&#xA;                                || ', AttributeList: '&#xD;&#xA;                                || cast(vAttributeList as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateComponentsAttribute';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createcomponentsattribute" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributelist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.createcomponentsattribute" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createcomponentsattribute" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vattributelist" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createcomponentsattribute" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createcomponentsattribute" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION createcomponentsattribute(vcomponentuuid uuid, vattributelist text[], vroles text[]) RETURNS TABLE(componentuuid uuid, attributelist uuid[])
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
  	DECLARE vAttributeName text;
		vAttrID int;
		vComponentID integer := (select componentid from components where componentuuid = vComponentUUID);
		vFunctionName varchar := 'CreateComponentsAttribute';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
        FOREACH vAttributeName in array vAttributeList
        LOOP
        	 vAttrID := (select attributes.attributeID from public.attributes where attributename = vAttributeName);
         	 INSERT INTO ComponentsAttribute(ComponentID, AttributeID)
             VALUES (vComponentID, vAttrID);
        END LOOP;

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created relation from component to attributes sucessfully', 'CreateComponentsAttribute',
                                'ComponentID: ' || cast(vComponentID as varchar)
                                || ', AttributeList: '
                                || cast(vAttributeList as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	vComponentUUId,
				array_agg(att.AttributeUUID)
		from componentsattribute ca
		join attributes att
		on ca.attributeid = att.attributeid
		where componentid = vComponentID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateComponentsAttribute',
                                'ComponentID: ' || cast(vComponentID as varchar)
                                || ', AttributeList: '
                                || cast(vAttributeList as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateComponentsAttribute';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createcomponentstechnologies" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;    DECLARE 	vTechName text;&#xD;&#xA;		vTechID integer;&#xD;&#xA;		vComponentID integer := (select componentid from components where componentuuid = vComponentUUID);&#xD;&#xA;		vFunctionName varchar := 'CreateComponentsTechnologies';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		FOREACH vTechName in array vTechnologyList&#xD;&#xA;		LOOP&#xD;&#xA;			vTechID := (select technologyid from technologies where technologyname = vTechName);&#xD;&#xA;			 INSERT INTO ComponentsTechnologies(ComponentID, TechnologyID)&#xD;&#xA;		     VALUES (vComponentID, vTechID);&#xD;&#xA;		END LOOP;&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created relation from component to attributes sucessfully', 'CreateComponentsTechnologies',&#xD;&#xA;                                'ComponentID: ' || cast(vComponentID as varchar)&#xD;&#xA;                                || ', TechnologyList: '&#xD;&#xA;                                || cast(vTechnologyList as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	vComponentUUID,&#xD;&#xA;			array_agg(technologyUUID)&#xD;&#xA;		from componentstechnologies ct&#xD;&#xA;		join technologies th on ct.technologyid = th.technologyid&#xD;&#xA;		where componentid = vComponentID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateComponentsTechnologies',&#xD;&#xA;                                'ComponentID: ' || cast(vComponentID as varchar)&#xD;&#xA;                                || ', TechnologyList: '&#xD;&#xA;                                || cast(vTechnologyList as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateComponentsTechnologies';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createcomponentstechnologies" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologylist" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createcomponentstechnologies" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologylist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.createcomponentstechnologies" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createcomponentstechnologies" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createcomponentstechnologies" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION createcomponentstechnologies(vcomponentuuid uuid, vtechnologylist text[], vroles text[]) RETURNS TABLE(componentuuid uuid, technologylist uuid[])
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
    DECLARE 	vTechName text;
		vTechID integer;
		vComponentID integer := (select componentid from components where componentuuid = vComponentUUID);
		vFunctionName varchar := 'CreateComponentsTechnologies';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
		FOREACH vTechName in array vTechnologyList
		LOOP
			vTechID := (select technologyid from technologies where technologyname = vTechName);
			 INSERT INTO ComponentsTechnologies(ComponentID, TechnologyID)
		     VALUES (vComponentID, vTechID);
		END LOOP;

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created relation from component to attributes sucessfully', 'CreateComponentsTechnologies',
                                'ComponentID: ' || cast(vComponentID as varchar)
                                || ', TechnologyList: '
                                || cast(vTechnologyList as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	vComponentUUID,
			array_agg(technologyUUID)
		from componentstechnologies ct
		join technologies th on ct.technologyid = th.technologyid
		where componentid = vComponentID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateComponentsTechnologies',
                                'ComponentID: ' || cast(vComponentID as varchar)
                                || ', TechnologyList: '
                                || cast(vTechnologyList as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateComponentsTechnologies';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createlicenseorder" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 			vLicenseOrderID integer := (select nextval('LicenseOrderID'));&#xD;&#xA;				vLicenseOrderUUID uuid := (select uuid_generate_v4());&#xD;&#xA;				vOfferID integer := (select offerid from offer where offeruuid = vOfferUUID);&#xD;&#xA;				vTransactionID integer := (select transactionid from transactions where offerid = vOfferID);&#xD;&#xA;				vFunctionName varchar := 'CreateLicenseOrder';&#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		INSERT INTO LicenseOrder(LicenseOrderID, LicenseOrderUUID, TicketID, OfferID, ActivatedAt, CreatedBy, CreatedAt)&#xD;&#xA;		VALUES(vLicenseOrderID, vLicenseOrderUUID, vTicketID, vOfferID, now(), vUserUUID, now());&#xD;&#xA;&#xD;&#xA;		-- Update Transactions table&#xD;&#xA;		UPDATE Transactions SET LicenseOrderID = vLicenseOrderID, UpdatedAt = now(), UpdatedBy = vUserUUID&#xD;&#xA;		WHERE TransactionID = vTransactionID;&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created CreateLicenseOrder sucessfully', 'CreateLicenseOrder',&#xD;&#xA;                                'PaymentInvoiceID: ' || cast(vLicenseOrderID as varchar)&#xD;&#xA;				|| ', TicketID: ' || vTicketID&#xD;&#xA;				|| ', OfferID: ' || cast(vOfferID as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vUserUUID as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	LicenseOrderUUID,&#xD;&#xA;			TicketID,&#xD;&#xA;			vOfferUUID,&#xD;&#xA;			ActivatedAt at time zone 'utc',&#xD;&#xA;			CreatedAt at time zone 'utc',&#xD;&#xA;			vUserUUID&#xD;&#xA;		from licenseorder&#xD;&#xA;		where licenseorderuuid = vLicenseOrderUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateLicenseOrder',&#xD;&#xA;                                'PaymentInvoiceID: ' || cast(vLicenseOrderID as varchar)&#xD;&#xA;				|| ', TicketID: ' || vTicketID&#xD;&#xA;				|| ', OfferID: ' || cast(vOfferID as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vUserUUID as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateLicenseOrder';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createlicenseorder" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="activatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createlicenseorder" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createlicenseorder" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createlicenseorder" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licenseorderuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createlicenseorder" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createlicenseorder" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="ticketid" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createlicenseorder" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vticketid" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createlicenseorder" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createlicenseorder" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createlicenseorder" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION createlicenseorder(vticketid character varying, vofferuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(licenseorderuuid uuid, ticketid character varying, offeruuid uuid, activatedat timestamp with time zone, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 			vLicenseOrderID integer := (select nextval('LicenseOrderID'));
				vLicenseOrderUUID uuid := (select uuid_generate_v4());
				vOfferID integer := (select offerid from offer where offeruuid = vOfferUUID);
				vTransactionID integer := (select transactionid from transactions where offerid = vOfferID);
				vFunctionName varchar := 'CreateLicenseOrder';
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
		INSERT INTO LicenseOrder(LicenseOrderID, LicenseOrderUUID, TicketID, OfferID, ActivatedAt, CreatedBy, CreatedAt)
		VALUES(vLicenseOrderID, vLicenseOrderUUID, vTicketID, vOfferID, now(), vUserUUID, now());

		-- Update Transactions table
		UPDATE Transactions SET LicenseOrderID = vLicenseOrderID, UpdatedAt = now(), UpdatedBy = vUserUUID
		WHERE TransactionID = vTransactionID;

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created CreateLicenseOrder sucessfully', 'CreateLicenseOrder',
                                'PaymentInvoiceID: ' || cast(vLicenseOrderID as varchar)
				|| ', TicketID: ' || vTicketID
				|| ', OfferID: ' || cast(vOfferID as varchar)
				|| ', CreatedBy: ' || cast(vUserUUID as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	LicenseOrderUUID,
			TicketID,
			vOfferUUID,
			ActivatedAt at time zone 'utc',
			CreatedAt at time zone 'utc',
			vUserUUID
		from licenseorder
		where licenseorderuuid = vLicenseOrderUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateLicenseOrder',
                                'PaymentInvoiceID: ' || cast(vLicenseOrderID as varchar)
				|| ', TicketID: ' || vTicketID
				|| ', OfferID: ' || cast(vOfferID as varchar)
				|| ', CreatedBy: ' || cast(vUserUUID as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateLicenseOrder';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createlog" routine_type="FUNCTION" return_type="pg_catalog.void" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="BEGIN&#xD;&#xA;&#xD;&#xA;          END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="0" provolatile="v">
    <param parent="public.createlog" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vlogobjectname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createlog" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vlogmessage" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createlog" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vlogstatusid" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.createlog" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vparameters" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION createlog(vlogstatusid integer, vlogmessage character varying, vlogobjectname character varying, vparameters character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
          BEGIN

          END;

    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createoffer" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vOfferID integer := (select nextval('OfferID'));&#xD;&#xA;		vOfferUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vPaymentInvoiceID integer := (select paymentinvoiceid from paymentinvoice where paymentinvoiceuuid = vPaymentInvoiceUUID);&#xD;&#xA;		vTransactionID integer := (select transactionid from transactions where paymentinvoiceid = vPaymentInvoiceID);&#xD;&#xA;		vFunctionName varchar := 'CreateOffer';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;		INSERT INTO Offer(OfferID, OfferUUID, PaymentInvoiceID, CreatedBy, CreatedAt)&#xD;&#xA;		VALUES(vOfferID, vOfferUUID, vPaymentInvoiceID, vUserUUID, now());&#xD;&#xA;&#xD;&#xA;		-- Update Transactions table&#xD;&#xA;		UPDATE Transactions SET OfferId = vOfferID, UpdatedAt = now(), UpdatedBy = vUserUUID&#xD;&#xA;		WHERE TransactionID = vTransactionID;&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created Offer sucessfully', 'CreateOffer',&#xD;&#xA;                                'OfferID: ' || cast(vOfferID as varchar)&#xD;&#xA;				|| ', PaymentInvoiceUUID: ' || cast(vPaymentInvoiceUUID as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vUserUUID as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return vOfferUUID&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	OfferUUID,&#xD;&#xA;			vPaymentInvoiceUUID,&#xD;&#xA;			CreatedAt at time zone 'utc',&#xD;&#xA;			vUserUUID&#xD;&#xA;		from offer where offeruuid = vOfferUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateOffer',&#xD;&#xA;                                'OfferID: ' || cast(vOfferID as varchar)&#xD;&#xA;				|| ', PaymentInvoiceUUID: ' || cast(vPaymentInvoiceUUID as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vUserUUID as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateOffer';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createoffer" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createoffer" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createoffer" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createoffer" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vpaymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createoffer" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createoffer" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createoffer" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION createoffer(vpaymentinvoiceuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(offeruuid uuid, paymentinvoiceuuid uuid, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vOfferID integer := (select nextval('OfferID'));
		vOfferUUID uuid := (select uuid_generate_v4());
		vPaymentInvoiceID integer := (select paymentinvoiceid from paymentinvoice where paymentinvoiceuuid = vPaymentInvoiceUUID);
		vTransactionID integer := (select transactionid from transactions where paymentinvoiceid = vPaymentInvoiceID);
		vFunctionName varchar := 'CreateOffer';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

		INSERT INTO Offer(OfferID, OfferUUID, PaymentInvoiceID, CreatedBy, CreatedAt)
		VALUES(vOfferID, vOfferUUID, vPaymentInvoiceID, vUserUUID, now());

		-- Update Transactions table
		UPDATE Transactions SET OfferId = vOfferID, UpdatedAt = now(), UpdatedBy = vUserUUID
		WHERE TransactionID = vTransactionID;

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created Offer sucessfully', 'CreateOffer',
                                'OfferID: ' || cast(vOfferID as varchar)
				|| ', PaymentInvoiceUUID: ' || cast(vPaymentInvoiceUUID as varchar)
				|| ', CreatedBy: ' || cast(vUserUUID as varchar));

        -- End Log if success
        -- Return vOfferUUID
        RETURN QUERY (
		select 	OfferUUID,
			vPaymentInvoiceUUID,
			CreatedAt at time zone 'utc',
			vUserUUID
		from offer where offeruuid = vOfferUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateOffer',
                                'OfferID: ' || cast(vOfferID as varchar)
				|| ', PaymentInvoiceUUID: ' || cast(vPaymentInvoiceUUID as varchar)
				|| ', CreatedBy: ' || cast(vUserUUID as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateOffer';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createofferrequest" routine_type="FUNCTION" return_type="pg_catalog.json" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vOfferRequestItemID integer := (select nextval('OfferRequestItemID'));&#xD;&#xA;		vOfferRequestID integer := (select nextval('OfferRequestID'));&#xD;&#xA;		vOfferRequestUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vTransactionID integer := (select nextval('TransactionID'));&#xD;&#xA;		vTransactionUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vFunctionName varchar := 'CreateOfferRequest';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		INSERT INTO OfferRequest(OfferRequestID, OfferRequestUUID, HSMID, RequestedBy, CreatedAt)&#xD;&#xA;		VALUES(vOfferRequestID, vOfferRequestUUID, vHSMID, vbuyeruuid, now());&#xD;&#xA;&#xD;&#xA;		INSERT INTO Transactions(TransactionID, TransactionUUID, OfferRequestID, BuyerID, CreatedBy, CreatedAt)&#xD;&#xA;		VALUES (vTransactionID, vTransactionUUID, vOfferRequestID, vbuyeruuid, vbuyeruuid, now());&#xD;&#xA;&#xD;&#xA;		with items as (&#xD;&#xA;			select 	vOfferRequestItemID as OfferRequestItemID, vOfferRequestID as offerrequestid,&#xD;&#xA;				(json_array_elements_text(vitems::json-&gt;'items')::json-&gt;&gt;'dataId')::text as dataId,&#xD;&#xA;				(json_array_elements_text(vitems::json-&gt;'items')::json-&gt;'amount')::text as amount&#xD;&#xA;			)&#xD;&#xA;		insert into offerrequestitems(offerrequestitemid, offerrequestid,technologydataId,amount)&#xD;&#xA;		select OfferRequestItemID, offerrequestid, td.technologydataid, amount::integer from items it&#xD;&#xA;		join technologydata td on it.dataid::uuid = td.technologydatauuid;&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created OfferRequest sucessfully', 'CreateOfferRequest',&#xD;&#xA;                                'OfferRequestID: ' || cast(vOfferRequestID as varchar)&#xD;&#xA;				|| ', Items: ' || cast(vItems as varchar)&#xD;&#xA;				|| ', HSMID: ' || vHSMID);&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return OfferRequestUUID&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;				select row_to_json (t) as result from (&#xD;&#xA;					select offerrequestuuid,&#xD;&#xA;						(&#xD;&#xA;						select	 array_to_json(array_agg(row_to_json(d)))&#xD;&#xA;						from (select   td.TechnologyDataUUID::uuid,   oi.Amount&#xD;&#xA;							from offerrequest ofr&#xD;&#xA;							join offerrequestitems oi on oi.offerrequestid = ofr.offerrequestid&#xD;&#xA;							join technologydata td&#xD;&#xA;							on oi.technologydataid = td.technologydataid&#xD;&#xA;							where offerrequestuuid = vOfferRequestUUID&#xD;&#xA;							) d&#xD;&#xA;						 ) as items, HSMID, CreatedAt at time zone 'utc' as CreatedAt, RequestedBy&#xD;&#xA;					 from offerrequest where offerrequestuuid = vOfferRequestUUID) t&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateOfferRequest',&#xD;&#xA;                                'OfferRequestID: ' || cast(vOfferRequestID as varchar)&#xD;&#xA;				|| ', Items: ' || cast(vItems as varchar)&#xD;&#xA;				|| ', HSMID: ' || vHSMID);&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateOfferRequest';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createofferrequest" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vhsmid" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createofferrequest" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vitems" data_type="jsonb" udt="pg_catalog.jsonb" />
    <param parent="public.createofferrequest" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createofferrequest" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="result" data_type="json" udt="pg_catalog.json" />
    <param parent="public.createofferrequest" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vbuyeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createofferrequest" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION createofferrequest(vitems jsonb, vhsmid character varying, vuseruuid uuid, vbuyeruuid uuid, vroles text[]) RETURNS TABLE(result json)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vOfferRequestItemID integer := (select nextval('OfferRequestItemID'));
		vOfferRequestID integer := (select nextval('OfferRequestID'));
		vOfferRequestUUID uuid := (select uuid_generate_v4());
		vTransactionID integer := (select nextval('TransactionID'));
		vTransactionUUID uuid := (select uuid_generate_v4());
		vFunctionName varchar := 'CreateOfferRequest';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
		INSERT INTO OfferRequest(OfferRequestID, OfferRequestUUID, HSMID, RequestedBy, CreatedAt)
		VALUES(vOfferRequestID, vOfferRequestUUID, vHSMID, vbuyeruuid, now());

		INSERT INTO Transactions(TransactionID, TransactionUUID, OfferRequestID, BuyerID, CreatedBy, CreatedAt)
		VALUES (vTransactionID, vTransactionUUID, vOfferRequestID, vbuyeruuid, vbuyeruuid, now());

		with items as (
			select 	vOfferRequestItemID as OfferRequestItemID, vOfferRequestID as offerrequestid,
				(json_array_elements_text(vitems::json-&gt;'items')::json-&gt;&gt;'dataId')::text as dataId,
				(json_array_elements_text(vitems::json-&gt;'items')::json-&gt;'amount')::text as amount
			)
		insert into offerrequestitems(offerrequestitemid, offerrequestid,technologydataId,amount)
		select OfferRequestItemID, offerrequestid, td.technologydataid, amount::integer from items it
		join technologydata td on it.dataid::uuid = td.technologydatauuid;

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created OfferRequest sucessfully', 'CreateOfferRequest',
                                'OfferRequestID: ' || cast(vOfferRequestID as varchar)
				|| ', Items: ' || cast(vItems as varchar)
				|| ', HSMID: ' || vHSMID);

        -- End Log if success
        -- Return OfferRequestUUID
        RETURN QUERY (
				select row_to_json (t) as result from (
					select offerrequestuuid,
						(
						select	 array_to_json(array_agg(row_to_json(d)))
						from (select   td.TechnologyDataUUID::uuid,   oi.Amount
							from offerrequest ofr
							join offerrequestitems oi on oi.offerrequestid = ofr.offerrequestid
							join technologydata td
							on oi.technologydataid = td.technologydataid
							where offerrequestuuid = vOfferRequestUUID
							) d
						 ) as items, HSMID, CreatedAt at time zone 'utc' as CreatedAt, RequestedBy
					 from offerrequest where offerrequestuuid = vOfferRequestUUID) t
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateOfferRequest',
                                'OfferRequestID: ' || cast(vOfferRequestID as varchar)
				|| ', Items: ' || cast(vItems as varchar)
				|| ', HSMID: ' || vHSMID);
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateOfferRequest';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createpaymentinvoice" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;	DECLARE vPaymentInvoiceID integer := (select nextval('PaymentInvoiceID'));&#xD;&#xA;		vPaymentInvoiceUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vOfferReqID integer := (select offerrequestid from offerrequest where offerrequestuuid = vOfferRequestUUID);&#xD;&#xA;		vTransactionID integer := (select transactionid from transactions where offerrequestid = vOfferReqID);&#xD;&#xA;		vFunctionName varchar := 'CreatePaymentInvoice';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		INSERT INTO PaymentInvoice(PaymentInvoiceID, PaymentInvoiceUUID, OfferRequestID, Invoice, CreatedBy, CreatedAt)&#xD;&#xA;		VALUES(vPaymentInvoiceID, vPaymentInvoiceUUID, vOfferReqID, vInvoice, vUserUUID, now());&#xD;&#xA;&#xD;&#xA;		-- Update Transactions table&#xD;&#xA;		UPDATE Transactions SET PaymentInvoiceID = vPaymentInvoiceID, UpdatedAt = now(), UpdatedBy = vUserUUID&#xD;&#xA;		WHERE TransactionID = vTransactionID;&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created PaymentInvoice sucessfully', 'CreatePaymentInvoice',&#xD;&#xA;                                'PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)&#xD;&#xA;				|| ', OfferRequestID: ' || cast(vOfferReqID as varchar)&#xD;&#xA;				|| ', Invoice: ' || coalesce(vInvoice, 'Empty')&#xD;&#xA;				|| ', CreatedBy: ' || cast(vuseruuid as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select	pi.PaymentInvoiceUUID,&#xD;&#xA;			oq.OfferRequestUUID,&#xD;&#xA;			pi.Invoice,&#xD;&#xA;			pi.CreatedAt at time zone 'utc',&#xD;&#xA;			pi.CreatedBy&#xD;&#xA;		from paymentinvoice pi&#xD;&#xA;		join offerrequest oq&#xD;&#xA;		on pi.offerrequestid = oq.offerrequestid&#xD;&#xA;		where pi.paymentinvoiceuuid = vPaymentInvoiceUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'CreatePaymentInvoice',&#xD;&#xA;                                'PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)&#xD;&#xA;				|| ', OfferRequestID: ' || cast(vOfferReqID as varchar)&#xD;&#xA;				|| ', Invoice: ' || coalesce(vInvoice, 'Empty')&#xD;&#xA;				|| ', CreatedBy: ' || cast(vuseruuid as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreatePaymentInvoice';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createpaymentinvoice" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vinvoice" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createpaymentinvoice" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createpaymentinvoice" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createpaymentinvoice" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createpaymentinvoice" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createpaymentinvoice" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offerrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createpaymentinvoice" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="invoice" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createpaymentinvoice" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createpaymentinvoice" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION createpaymentinvoice(vinvoice character varying, vofferrequestuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(paymentinvoiceuuid uuid, offerrequestuuid uuid, invoice character varying, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
	DECLARE vPaymentInvoiceID integer := (select nextval('PaymentInvoiceID'));
		vPaymentInvoiceUUID uuid := (select uuid_generate_v4());
		vOfferReqID integer := (select offerrequestid from offerrequest where offerrequestuuid = vOfferRequestUUID);
		vTransactionID integer := (select transactionid from transactions where offerrequestid = vOfferReqID);
		vFunctionName varchar := 'CreatePaymentInvoice';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
		INSERT INTO PaymentInvoice(PaymentInvoiceID, PaymentInvoiceUUID, OfferRequestID, Invoice, CreatedBy, CreatedAt)
		VALUES(vPaymentInvoiceID, vPaymentInvoiceUUID, vOfferReqID, vInvoice, vUserUUID, now());

		-- Update Transactions table
		UPDATE Transactions SET PaymentInvoiceID = vPaymentInvoiceID, UpdatedAt = now(), UpdatedBy = vUserUUID
		WHERE TransactionID = vTransactionID;

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created PaymentInvoice sucessfully', 'CreatePaymentInvoice',
                                'PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)
				|| ', OfferRequestID: ' || cast(vOfferReqID as varchar)
				|| ', Invoice: ' || coalesce(vInvoice, 'Empty')
				|| ', CreatedBy: ' || cast(vuseruuid as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select	pi.PaymentInvoiceUUID,
			oq.OfferRequestUUID,
			pi.Invoice,
			pi.CreatedAt at time zone 'utc',
			pi.CreatedBy
		from paymentinvoice pi
		join offerrequest oq
		on pi.offerrequestid = oq.offerrequestid
		where pi.paymentinvoiceuuid = vPaymentInvoiceUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'CreatePaymentInvoice',
                                'PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)
				|| ', OfferRequestID: ' || cast(vOfferReqID as varchar)
				|| ', Invoice: ' || coalesce(vInvoice, 'Empty')
				|| ', CreatedBy: ' || cast(vuseruuid as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreatePaymentInvoice';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createrole" routine_type="FUNCTION" return_type="pg_catalog.void" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="Declare vRoleID integer;&#xD;&#xA;		vFunctionName varchar := 'CreateRole';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRolesUser, vFunctionName));&#xD;&#xA;		vRoleName varchar;&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;		if(vIsAllowed) then&#xD;&#xA;			FOREACH vRoleName in array vRoles LOOP&#xD;&#xA;				vRoleID := (select nextval('RoleID'));&#xD;&#xA;				insert into roles (RoleID, RoleName, RoleDescription)&#xD;&#xA;				values (vRoleID, vRoleName, vRoleDescription);&#xD;&#xA;			END LOOP;&#xD;&#xA;		else&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;		end if;&#xD;&#xA;&#xD;&#xA;	 -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created Role sucessfully', 'CreateRole',&#xD;&#xA;                                'RoleID: ' || cast(vRoleID as varchar)&#xD;&#xA;                                || ', vRoles: ' || cast(vRoles as varchar)&#xD;&#xA;                                || ', RoleDescription: '&#xD;&#xA;                                || vRoleDescription);&#xD;&#xA;&#xD;&#xA;	 exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'CreateRole',&#xD;&#xA;                                'RoleID: ' || cast(vRoleID as varchar)&#xD;&#xA;                                || ', vRoles: ' || cast(vRoles as varchar)&#xD;&#xA;                                || ', RoleDescription: '&#xD;&#xA;                                || vRoleDescription);&#xD;&#xA;        -- End Log if error&#xD;&#xA;		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateRole';&#xD;&#xA;		RETURN;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="0" provolatile="v">
    <param parent="public.createrole" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroledescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createrole" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createrole" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vrolesuser" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createrole" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION createrole(vroles text[], vroledescription character varying, vuseruuid uuid, vrolesuser text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
	Declare vRoleID integer;
		vFunctionName varchar := 'CreateRole';
		vIsAllowed boolean := (select public.checkPermissions(vRolesUser, vFunctionName));
		vRoleName varchar;

	BEGIN
		if(vIsAllowed) then
			FOREACH vRoleName in array vRoles LOOP
				vRoleID := (select nextval('RoleID'));
				insert into roles (RoleID, RoleName, RoleDescription)
				values (vRoleID, vRoleName, vRoleDescription);
			END LOOP;
		else
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
		end if;

	 -- Begin Log if success
        perform public.createlog(0,'Created Role sucessfully', 'CreateRole',
                                'RoleID: ' || cast(vRoleID as varchar)
                                || ', vRoles: ' || cast(vRoles as varchar)
                                || ', RoleDescription: '
                                || vRoleDescription);

	 exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'CreateRole',
                                'RoleID: ' || cast(vRoleID as varchar)
                                || ', vRoles: ' || cast(vRoles as varchar)
                                || ', RoleDescription: '
                                || vRoleDescription);
        -- End Log if error
		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateRole';
		RETURN;
	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createtag" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vTagID integer := (select nextval('TagID'));&#xD;&#xA;		vTagUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vFunctionName varchar := 'CreateTag';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;      BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		INSERT INTO Tags(TagID, TagUUID, TagName, CreatedBy, CreatedAt)&#xD;&#xA;		VALUES(vTagID, vTagUUID, vTagName, vCreatedBy, now());&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created Tag sucessfully', 'CreateTag',&#xD;&#xA;                                'TagID: ' || cast(vTagID as varchar)&#xD;&#xA;				|| ', TagName: ' || vTagName&#xD;&#xA;				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	TagUUID,&#xD;&#xA;			TagName,&#xD;&#xA;			CreatedAt at time zone 'utc',&#xD;&#xA;			vCreatedBy&#xD;&#xA;		from tags tg&#xD;&#xA;		where taguuid = vTagUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'CreateTag',&#xD;&#xA;                                'TagID: ' || cast(vTagID as varchar)&#xD;&#xA;				|| ', TagName: ' || vTagName&#xD;&#xA;				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTag';&#xD;&#xA;       RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createtag" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtag" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createtag" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="taguuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtag" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="tagname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtag" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createtag" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtag" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtagname" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION createtag(vtagname character varying, vcreatedby uuid, vroles text[]) RETURNS TABLE(taguuid uuid, tagname character varying, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vTagID integer := (select nextval('TagID'));
		vTagUUID uuid := (select uuid_generate_v4());
		vFunctionName varchar := 'CreateTag';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
      BEGIN

	IF(vIsAllowed) THEN
		INSERT INTO Tags(TagID, TagUUID, TagName, CreatedBy, CreatedAt)
		VALUES(vTagID, vTagUUID, vTagName, vCreatedBy, now());
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

        -- Begin Log if success
        perform public.createlog(0,'Created Tag sucessfully', 'CreateTag',
                                'TagID: ' || cast(vTagID as varchar)
				|| ', TagName: ' || vTagName
				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	TagUUID,
			TagName,
			CreatedAt at time zone 'utc',
			vCreatedBy
		from tags tg
		where taguuid = vTagUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'CreateTag',
                                'TagID: ' || cast(vTagID as varchar)
				|| ', TagName: ' || vTagName
				|| ', CreatedBy: ' || cast(vCreatedBy as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTag';
       RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createtechnology" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vTechnologyID integer := (select nextval('TechnologyID'));&#xD;&#xA;		vTechnologyUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vFunctionName varchar := 'CreateTechnology';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;      BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		INSERT INTO Technologies(TechnologyID, TechnologyUUID, TechnologyName, TechnologyDescription, CreatedBy, CreatedAt)&#xD;&#xA;		VALUES(vTechnologyID, vTechnologyUUID, vTechnologyName, vTechnologyDescription, vCreatedby, now());&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created Technology sucessfully', 'CreateTechnology',&#xD;&#xA;                                'TechnologyID: ' || cast(vTechnologyID as varchar)&#xD;&#xA;                                || ', TechnologyName: '&#xD;&#xA;                                || vTechnologyName&#xD;&#xA;                                || ', TechnologyDescription: '&#xD;&#xA;                                || vTechnologyDescription&#xD;&#xA;                                || ', CreatedBy: '&#xD;&#xA;                                || cast(vCreatedby as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	TechnologyUUID,&#xD;&#xA;			TechnologyName,&#xD;&#xA;			TechnologyDescription,&#xD;&#xA;			CreatedAt at time zone 'utc',&#xD;&#xA;			vCreatedBy&#xD;&#xA;		from technologies&#xD;&#xA;		where technologyuuid = vTechnologyUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateTechnology',&#xD;&#xA;                                'TechnologyID: ' || cast(vTechnologyID as varchar)&#xD;&#xA;                                || ', TechnologyName: '&#xD;&#xA;                                || vTechnologyName&#xD;&#xA;                                || ', TechnologyDescription: '&#xD;&#xA;                                || vTechnologyDescription&#xD;&#xA;                                || ', CreatedBy: '&#xD;&#xA;                                || cast(vCreatedby as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnology';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createtechnology" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnology" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnology" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createtechnology" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnology" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnology" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnology" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createtechnology" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnology" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologyname" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION createtechnology(vtechnologyname character varying, vtechnologydescription character varying, vcreatedby uuid, vroles text[]) RETURNS TABLE(technologyuuid uuid, technologyname character varying, technologydescription character varying, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vTechnologyID integer := (select nextval('TechnologyID'));
		vTechnologyUUID uuid := (select uuid_generate_v4());
		vFunctionName varchar := 'CreateTechnology';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

      BEGIN

	IF(vIsAllowed) THEN
		INSERT INTO Technologies(TechnologyID, TechnologyUUID, TechnologyName, TechnologyDescription, CreatedBy, CreatedAt)
		VALUES(vTechnologyID, vTechnologyUUID, vTechnologyName, vTechnologyDescription, vCreatedby, now());

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created Technology sucessfully', 'CreateTechnology',
                                'TechnologyID: ' || cast(vTechnologyID as varchar)
                                || ', TechnologyName: '
                                || vTechnologyName
                                || ', TechnologyDescription: '
                                || vTechnologyDescription
                                || ', CreatedBy: '
                                || cast(vCreatedby as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	TechnologyUUID,
			TechnologyName,
			TechnologyDescription,
			CreatedAt at time zone 'utc',
			vCreatedBy
		from technologies
		where technologyuuid = vTechnologyUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateTechnology',
                                'TechnologyID: ' || cast(vTechnologyID as varchar)
                                || ', TechnologyName: '
                                || vTechnologyName
                                || ', TechnologyDescription: '
                                || vTechnologyDescription
                                || ', CreatedBy: '
                                || cast(vCreatedby as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnology';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createtechnologydata" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vTechnologyDataID integer := (select nextval('TechnologyDataID'));&#xD;&#xA;		vTechnologyDataUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vTechnologyID integer := (select technologyid from technologies where technologyuuid = vTechnologyUUID);&#xD;&#xA;		vFunctionName varchar := 'CreateTechnologyData';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;      BEGIN&#xD;&#xA;	IF(vIsAllowed) then&#xD;&#xA;		INSERT INTO TechnologyData(TechnologyDataID, TechnologyDataUUID, TechnologyDataName, TechnologyData, TechnologyDataDescription, LicenseFee, ProductCode, TechnologyID, technologydataimgref, CreatedBy, CreatedAt)&#xD;&#xA;        VALUES(vTechnologyDataID, vTechnologyDataUUID, vTechnologyDataName, vTechnologyData, vTechnologyDataDescription, vLicenseFee, vProductCode, vTechnologyID, vtechnologydataimgref, vCreatedBy, now());&#xD;&#xA;	else&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	end if;&#xD;&#xA;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created TechnologyData sucessfully', 'CreateTechnologyData',&#xD;&#xA;                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '&#xD;&#xA;                                || replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData&#xD;&#xA;                                || ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')&#xD;&#xA;				-- || ', vTechnologyDataAuthor: ' || cast(vTechAuthor as varchar)&#xD;&#xA;                                || ', TechnologyID: ' || cast(vTechnologyID as varchar)&#xD;&#xA;                                || ', LicenseFee: ' || cast(vLicenseFee as varchar)&#xD;&#xA;                                || ', ProductCode: ' || cast(vProductCode as varchar)&#xD;&#xA;                                || ', CreatedBy: ' || vCreatedBy);&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	td.TechnologyDataUUID,&#xD;&#xA;			td.TechnologyDataName,&#xD;&#xA;			tc.TechnologyUUID,&#xD;&#xA;			td.TechnologyData,&#xD;&#xA;			td.ProductCode,&#xD;&#xA;			td.LicenseFee,&#xD;&#xA;			td.TechnologyDataDescription,&#xD;&#xA;			td.TechnologyDataThumbnail,&#xD;&#xA;			td.TechnologyDataImgRef,&#xD;&#xA;			td.CreatedAt at time zone 'utc',&#xD;&#xA;			vCreatedby as CreateBy&#xD;&#xA;		from technologydata td&#xD;&#xA;		join technologies tc on&#xD;&#xA;		td.technologyid = tc.technologyid&#xD;&#xA;		where td.technologydatauuid = vTechnologyDataUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateTechnologyData',&#xD;&#xA;                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '&#xD;&#xA;                                || replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData&#xD;&#xA;                                || ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')&#xD;&#xA;				-- || ', vTechnologyDataAuthor: ' || cast(vTechAuthor as varchar)&#xD;&#xA;                                || ', TechnologyID: ' || cast(vTechnologyID as varchar)&#xD;&#xA;                                || ', LicenseFee: ' || cast(vLicenseFee as varchar)&#xD;&#xA;                                || ', ProductCode: ' || cast(vProductCode as varchar)&#xD;&#xA;                                || ', CreatedBy: ' || vCreatedBy);&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyData';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createtechnologydata" ordinal_position="6" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydata" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vlicensefee" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.createtechnologydata" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnologydata" ordinal_position="18" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataimgref" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnologydata" ordinal_position="19" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.createtechnologydata" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnologydata" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnologydata" ordinal_position="16" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnologydata" ordinal_position="17" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatathumbnail" data_type="bytea" udt="pg_catalog.bytea" />
    <param parent="public.createtechnologydata" ordinal_position="20" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydata" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.createtechnologydata" ordinal_position="7" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydataimgref" data_type="text" udt="pg_catalog.text" />
    <param parent="public.createtechnologydata" ordinal_position="8" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydata" ordinal_position="9" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createtechnologydata" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydata" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnologydata" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydata" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.createtechnologydata" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="productcode" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.createtechnologydata" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vproductcode" data_type="integer" udt="pg_catalog.int4" />
    <code>CREATE FUNCTION createtechnologydata(vtechnologydataname character varying, vtechnologydata character varying, vtechnologydatadescription character varying, vlicensefee integer, vproductcode integer, vtechnologyuuid uuid, vtechnologydataimgref text, vcreatedby uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, technologydataname character varying, technologyuuid uuid, technologydata character varying, productcode integer, licensefee bigint, technologydatadescription character varying, technologydatathumbnail bytea, technologydataimgref character varying, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vTechnologyDataID integer := (select nextval('TechnologyDataID'));
		vTechnologyDataUUID uuid := (select uuid_generate_v4());
		vTechnologyID integer := (select technologyid from technologies where technologyuuid = vTechnologyUUID);
		vFunctionName varchar := 'CreateTechnologyData';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

      BEGIN
	IF(vIsAllowed) then
		INSERT INTO TechnologyData(TechnologyDataID, TechnologyDataUUID, TechnologyDataName, TechnologyData, TechnologyDataDescription, LicenseFee, ProductCode, TechnologyID, technologydataimgref, CreatedBy, CreatedAt)
        VALUES(vTechnologyDataID, vTechnologyDataUUID, vTechnologyDataName, vTechnologyData, vTechnologyDataDescription, vLicenseFee, vProductCode, vTechnologyID, vtechnologydataimgref, vCreatedBy, now());
	else
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	end if;

        -- Begin Log if success
        perform public.createlog(0,'Created TechnologyData sucessfully', 'CreateTechnologyData',
                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '
                                || replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData
                                || ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')
				-- || ', vTechnologyDataAuthor: ' || cast(vTechAuthor as varchar)
                                || ', TechnologyID: ' || cast(vTechnologyID as varchar)
                                || ', LicenseFee: ' || cast(vLicenseFee as varchar)
                                || ', ProductCode: ' || cast(vProductCode as varchar)
                                || ', CreatedBy: ' || vCreatedBy);

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	td.TechnologyDataUUID,
			td.TechnologyDataName,
			tc.TechnologyUUID,
			td.TechnologyData,
			td.ProductCode,
			td.LicenseFee,
			td.TechnologyDataDescription,
			td.TechnologyDataThumbnail,
			td.TechnologyDataImgRef,
			td.CreatedAt at time zone 'utc',
			vCreatedby as CreateBy
		from technologydata td
		join technologies tc on
		td.technologyid = tc.technologyid
		where td.technologydatauuid = vTechnologyDataUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'CreateTechnologyData',
                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '
                                || replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData
                                || ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')
				-- || ', vTechnologyDataAuthor: ' || cast(vTechAuthor as varchar)
                                || ', TechnologyID: ' || cast(vTechnologyID as varchar)
                                || ', LicenseFee: ' || cast(vLicenseFee as varchar)
                                || ', ProductCode: ' || cast(vProductCode as varchar)
                                || ', CreatedBy: ' || vCreatedBy);
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyData';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createtechnologydatacomponents" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;  	DECLARE vCompUUID uuid;&#xD;&#xA;		vCompID integer;&#xD;&#xA;		vTechnologyDataID integer := (select technologydataid from technologydata where technologydatauuid = vTechnologyDataUUID);&#xD;&#xA;		vFunctionName varchar := 'CreateTechnologyDataComponents';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;      BEGIN&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		FOREACH vCompUUID in array vComponentList&#xD;&#xA;		LOOP&#xD;&#xA;			vCompID := (select componentID from components where componentUUID = vCompUUID);&#xD;&#xA;&#xD;&#xA;			INSERT INTO TechnologyDataComponents(technologydataid, componentid)&#xD;&#xA;			VALUES (vTechnologyDataID, vCompID);&#xD;&#xA;		END LOOP;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created relation from Componets to TechnologyData sucessfully', 'CreateTechnologyDataComponents',&#xD;&#xA;                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)&#xD;&#xA;                                || ', ComponentList: ' || cast(vComponentList as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	vTechnologyDataUUID,&#xD;&#xA;			array_agg(ComponentUUID)&#xD;&#xA;		from technologydatacomponents tc join&#xD;&#xA;		components co on tc.componentid = co.componentid&#xD;&#xA;		where technologydataid = vTechnologyDataID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'CreateTechnologyDataComponents',&#xD;&#xA;                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)&#xD;&#xA;                                || ', ComponentList: ' || cast(vComponentList as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyDataComponents';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createtechnologydatacomponents" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentlist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.createtechnologydatacomponents" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydatacomponents" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentlist" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createtechnologydatacomponents" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createtechnologydatacomponents" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION createtechnologydatacomponents(vtechnologydatauuid uuid, vcomponentlist text[], vroles text[]) RETURNS TABLE(technologydatauuid uuid, componentlist uuid[])
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
  	DECLARE vCompUUID uuid;
		vCompID integer;
		vTechnologyDataID integer := (select technologydataid from technologydata where technologydatauuid = vTechnologyDataUUID);
		vFunctionName varchar := 'CreateTechnologyDataComponents';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

      BEGIN
	IF(vIsAllowed) THEN
		FOREACH vCompUUID in array vComponentList
		LOOP
			vCompID := (select componentID from components where componentUUID = vCompUUID);

			INSERT INTO TechnologyDataComponents(technologydataid, componentid)
			VALUES (vTechnologyDataID, vCompID);
		END LOOP;
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- Begin Log if success
        perform public.createlog(0,'Created relation from Componets to TechnologyData sucessfully', 'CreateTechnologyDataComponents',
                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)
                                || ', ComponentList: ' || cast(vComponentList as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	vTechnologyDataUUID,
			array_agg(ComponentUUID)
		from technologydatacomponents tc join
		components co on tc.componentid = co.componentid
		where technologydataid = vTechnologyDataID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'CreateTechnologyDataComponents',
                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)
                                || ', ComponentList: ' || cast(vComponentList as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyDataComponents';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.createtechnologydatatags" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;  	DECLARE vTagName text;&#xD;&#xA;		vtagID integer;&#xD;&#xA;		vTechnologyDataID integer := (select technologydataid from technologydata where technologydatauuid = vTechnologyDataUUID);&#xD;&#xA;		vFunctionName varchar := 'CreateTechnologyDataTags';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;      BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		FOREACH vTagName in array vTagList&#xD;&#xA;		LOOP&#xD;&#xA;			 vtagID := (select tags.tagID from tags where tagName = vTagName);&#xD;&#xA;			 INSERT INTO TechnologyDataTags(TechnologyDataID, tagID)&#xD;&#xA;				VALUES (vTechnologyDataID, vtagID);&#xD;&#xA;&#xD;&#xA;		END LOOP;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;        -- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created relation from Tags to TechnologyData sucessfully', 'CreateTechnologyDataTags',&#xD;&#xA;                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)&#xD;&#xA;                                || ', TagList: '&#xD;&#xA;                                || cast(vTagList as varchar));&#xD;&#xA;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select  vTechnologyDataUUID,&#xD;&#xA;			array_agg(taguuid)&#xD;&#xA;		from technologydatatags td&#xD;&#xA;		join tags tg on td.tagid = tg.tagid&#xD;&#xA;		where td.technologydataid = vTechnologyDataID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE || cast(vtagID as varchar), 'CreateTechnologyDataTags',&#xD;&#xA;                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)&#xD;&#xA;                                || ', TagList: '&#xD;&#xA;                                || cast(vTagList as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyDataTags';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.createtechnologydatatags" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydatatags" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.createtechnologydatatags" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydatatags" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.createtechnologydatatags" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="taglist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.createtechnologydatatags" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtaglist" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION createtechnologydatatags(vtechnologydatauuid uuid, vtaglist text[], vcreatedby uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, taglist uuid[])
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
  	DECLARE vTagName text;
		vtagID integer;
		vTechnologyDataID integer := (select technologydataid from technologydata where technologydatauuid = vTechnologyDataUUID);
		vFunctionName varchar := 'CreateTechnologyDataTags';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
      BEGIN

	IF(vIsAllowed) THEN
		FOREACH vTagName in array vTagList
		LOOP
			 vtagID := (select tags.tagID from tags where tagName = vTagName);
			 INSERT INTO TechnologyDataTags(TechnologyDataID, tagID)
				VALUES (vTechnologyDataID, vtagID);

		END LOOP;
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

        -- Begin Log if success
        perform public.createlog(0,'Created relation from Tags to TechnologyData sucessfully', 'CreateTechnologyDataTags',
                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)
                                || ', TagList: '
                                || cast(vTagList as varchar));

        -- End Log if success
        -- Return
        RETURN QUERY (
		select  vTechnologyDataUUID,
			array_agg(taguuid)
		from technologydatatags td
		join tags tg on td.tagid = tg.tagid
		where td.technologydataid = vTechnologyDataID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE || cast(vtagID as varchar), 'CreateTechnologyDataTags',
                                'TechnologyDataID: ' || cast(vTechnologyDataID as varchar)
                                || ', TagList: '
                                || cast(vTagList as varchar));
        -- End Log if error
		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyDataTags';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.datediff" routine_type="FUNCTION" return_type="pg_catalog.int4" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;     diff_interval INTERVAL;&#xD;&#xA;     diff INT = 0;&#xD;&#xA;     years_diff INT = 0;&#xD;&#xA;   BEGIN&#xD;&#xA;     IF units IN ('yy', 'yyyy', 'year', 'mm', 'm', 'month') THEN&#xD;&#xA;       years_diff = DATE_PART('year', end_t) - DATE_PART('year', start_t);&#xD;&#xA;&#xD;&#xA;       IF units IN ('yy', 'yyyy', 'year') THEN&#xD;&#xA;         -- SQL Server does not count full years passed (only difference between year parts)&#xD;&#xA;         RETURN years_diff;&#xD;&#xA;       ELSE&#xD;&#xA;         -- If end month is less than start month it will subtracted&#xD;&#xA;         RETURN years_diff * 12 + (DATE_PART('month', end_t) - DATE_PART('month', start_t));&#xD;&#xA;       END IF;&#xD;&#xA;     END IF;&#xD;&#xA;&#xD;&#xA;     -- Minus operator returns interval 'DDD days HH:MI:SS'&#xD;&#xA;     diff_interval = end_t - start_t;&#xD;&#xA;&#xD;&#xA;     diff = diff + DATE_PART('day', diff_interval);&#xD;&#xA;&#xD;&#xA;     IF units IN ('wk', 'ww', 'week') THEN&#xD;&#xA;       diff = diff/7;&#xD;&#xA;       RETURN diff;&#xD;&#xA;     END IF;&#xD;&#xA;&#xD;&#xA;     IF units IN ('dd', 'd', 'day') THEN&#xD;&#xA;       RETURN diff;&#xD;&#xA;     END IF;&#xD;&#xA;&#xD;&#xA;     diff = diff * 24 + DATE_PART('hour', diff_interval);&#xD;&#xA;&#xD;&#xA;     IF units IN ('hh', 'hour') THEN&#xD;&#xA;        RETURN diff;&#xD;&#xA;     END IF;&#xD;&#xA;&#xD;&#xA;     diff = diff * 60 + DATE_PART('minute', diff_interval);&#xD;&#xA;&#xD;&#xA;     IF units IN ('mi', 'n', 'minute') THEN&#xD;&#xA;        RETURN diff;&#xD;&#xA;     END IF;&#xD;&#xA;&#xD;&#xA;     diff = diff * 60 + DATE_PART('second', diff_interval);&#xD;&#xA;&#xD;&#xA;     RETURN diff;&#xD;&#xA;   END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="0" provolatile="v">
    <param parent="public.datediff" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="units" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.datediff" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="start_t" data_type="timestamp without time zone" udt="pg_catalog.timestamp" />
    <param parent="public.datediff" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="end_t" data_type="timestamp without time zone" udt="pg_catalog.timestamp" />
    <code>CREATE FUNCTION datediff(units character varying, start_t timestamp without time zone, end_t timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
   DECLARE
     diff_interval INTERVAL;
     diff INT = 0;
     years_diff INT = 0;
   BEGIN
     IF units IN ('yy', 'yyyy', 'year', 'mm', 'm', 'month') THEN
       years_diff = DATE_PART('year', end_t) - DATE_PART('year', start_t);

       IF units IN ('yy', 'yyyy', 'year') THEN
         -- SQL Server does not count full years passed (only difference between year parts)
         RETURN years_diff;
       ELSE
         -- If end month is less than start month it will subtracted
         RETURN years_diff * 12 + (DATE_PART('month', end_t) - DATE_PART('month', start_t));
       END IF;
     END IF;

     -- Minus operator returns interval 'DDD days HH:MI:SS'
     diff_interval = end_t - start_t;

     diff = diff + DATE_PART('day', diff_interval);

     IF units IN ('wk', 'ww', 'week') THEN
       diff = diff/7;
       RETURN diff;
     END IF;

     IF units IN ('dd', 'd', 'day') THEN
       RETURN diff;
     END IF;

     diff = diff * 24 + DATE_PART('hour', diff_interval);

     IF units IN ('hh', 'hour') THEN
        RETURN diff;
     END IF;

     diff = diff * 60 + DATE_PART('minute', diff_interval);

     IF units IN ('mi', 'n', 'minute') THEN
        RETURN diff;
     END IF;

     diff = diff * 60 + DATE_PART('second', diff_interval);

     RETURN diff;
   END;
   $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.deletetechnologydata" routine_type="FUNCTION" return_type="pg_catalog.bool" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;					vFunctionName varchar := 'DeleteTechnologyData';&#xD;&#xA;					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;					vOwnerUUID uuid := (select createdby from technologydata where technologydatauuid = vTechnologyDataUUID);&#xD;&#xA;&#xD;&#xA;				BEGIN&#xD;&#xA;&#xD;&#xA;				IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;					IF (vUserUUID = vOwnerUUID) THEN&#xD;&#xA;&#xD;&#xA;					 update technologydata set deleted = true&#xD;&#xA;					 where technologydatauuid = vTechnologyDataUUID&#xD;&#xA;					 and createdby = vuseruuid;&#xD;&#xA;&#xD;&#xA;					 ELSE&#xD;&#xA;&#xD;&#xA;						 RAISE EXCEPTION '%', 'You are not allowed to delete this technologydata.';&#xD;&#xA;						 RETURN false;&#xD;&#xA;&#xD;&#xA;					 END IF;&#xD;&#xA;&#xD;&#xA;				ELSE&#xD;&#xA;					 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;					 RETURN false;&#xD;&#xA;				END IF;&#xD;&#xA;&#xD;&#xA;				-- Begin Log if success&#xD;&#xA;					perform public.createlog(0,'Delete TechnologyData successfull', 'DeleteTechnologyData',&#xD;&#xA;											'TechnologyDataID: ' || cast(vtechnologydatauuid as varchar));&#xD;&#xA;&#xD;&#xA;					-- End Log if success&#xD;&#xA;					RETURN true;&#xD;&#xA;				 -- Begin Log if error&#xD;&#xA;					perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'DeleteTechnologyData',&#xD;&#xA;											'TechnologyDataID: ' || cast(vtechnologydatauuid as varchar));&#xD;&#xA;					-- End Log if error&#xD;&#xA;					RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyDataComponents';&#xD;&#xA;				RETURN false;&#xD;&#xA;&#xD;&#xA;				END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="0" provolatile="v">
    <param parent="public.deletetechnologydata" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.deletetechnologydata" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.deletetechnologydata" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION deletetechnologydata(vtechnologydatauuid uuid, vuseruuid uuid, vroles text[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

				DECLARE
					vFunctionName varchar := 'DeleteTechnologyData';
					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
					vOwnerUUID uuid := (select createdby from technologydata where technologydatauuid = vTechnologyDataUUID);

				BEGIN

				IF(vIsAllowed) THEN

					IF (vUserUUID = vOwnerUUID) THEN

					 update technologydata set deleted = true
					 where technologydatauuid = vTechnologyDataUUID
					 and createdby = vuseruuid;

					 ELSE

						 RAISE EXCEPTION '%', 'You are not allowed to delete this technologydata.';
						 RETURN false;

					 END IF;

				ELSE
					 RAISE EXCEPTION '%', 'Insufficiency rigths';
					 RETURN false;
				END IF;

				-- Begin Log if success
					perform public.createlog(0,'Delete TechnologyData successfull', 'DeleteTechnologyData',
											'TechnologyDataID: ' || cast(vtechnologydatauuid as varchar));

					-- End Log if success
					RETURN true;
				 -- Begin Log if error
					perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'DeleteTechnologyData',
											'TechnologyDataID: ' || cast(vtechnologydatauuid as varchar));
					-- End Log if error
					RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at CreateTechnologyDataComponents';
				RETURN false;

				END;
					$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getactivatedlicensescountforuser" routine_type="FUNCTION" return_type="pg_catalog.int4" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;				DECLARE vFunctionName varchar := 'GetActivatedLicensesCountForUser';&#xD;&#xA;					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;				BEGIN&#xD;&#xA;&#xD;&#xA;					IF(vIsAllowed) THEN&#xD;&#xA;						RETURN (select sum(amount) from transactions ts&#xD;&#xA;							join licenseorder lo&#xD;&#xA;							on ts.licenseorderid = lo.licenseorderid&#xD;&#xA;							join offerrequest oq&#xD;&#xA;							on oq.offerrequestid = ts.offerrequestid&#xD;&#xA;							join offerrequestitems ri&#xD;&#xA;							on ri.offerrequestid = oq.offerrequestid&#xD;&#xA;							join technologydata td			&#xD;&#xA;							on ri.technologydataid = td.technologydataid 	&#xD;&#xA;							where td.createdby = vuseruuid);&#xD;&#xA;&#xD;&#xA;					ELSE&#xD;&#xA;						 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;						 RETURN NULL;&#xD;&#xA;					END IF;&#xD;&#xA;				  &#xD;&#xA;				END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="0" provolatile="v">
    <param parent="public.getactivatedlicensescountforuser" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vinquereid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getactivatedlicensescountforuser" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getactivatedlicensescountforuser" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getactivatedlicensescountforuser(vuseruuid uuid, vinquereid uuid, vroles text[]) RETURNS integer
    LANGUAGE plpgsql
    AS $$
				#variable_conflict use_column
				DECLARE vFunctionName varchar := 'GetActivatedLicensesCountForUser';
					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

				BEGIN

					IF(vIsAllowed) THEN
						RETURN (select sum(amount) from transactions ts
							join licenseorder lo
							on ts.licenseorderid = lo.licenseorderid
							join offerrequest oq
							on oq.offerrequestid = ts.offerrequestid
							join offerrequestitems ri
							on ri.offerrequestid = oq.offerrequestid
							join technologydata td			
							on ri.technologydataid = td.technologydataid 	
							where td.createdby = vuseruuid);

					ELSE
						 RAISE EXCEPTION '%', 'Insufficiency rigths';
						 RETURN NULL;
					END IF;
				  
				END;
			  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getallattributes" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetAllAttributes';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY	(SELECT  attributeuuid,&#xD;&#xA;				attributename,&#xD;&#xA;				att.createdat at time zone 'utc',&#xD;&#xA;				att.createdby,&#xD;&#xA;				att.updatedat at time zone 'utc',&#xD;&#xA;				att.updatedby&#xD;&#xA;			FROM attributes att&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getallattributes" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getallattributes" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getallattributes" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributename" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getallattributes" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallattributes" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallattributes" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallattributes" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributeuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallattributes" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <code>CREATE FUNCTION getallattributes(vuseruuid uuid, vroles text[]) RETURNS TABLE(attributeuuid uuid, attributename character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetAllAttributes';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY	(SELECT  attributeuuid,
				attributename,
				att.createdat at time zone 'utc',
				att.createdby,
				att.updatedat at time zone 'utc',
				att.updatedby
			FROM attributes att
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getallcomponents" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetAllComponents';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;		vRoot varchar := 'Root';&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  cp.componentuuid,&#xD;&#xA;			cp.componentname,&#xD;&#xA;			cp.componentparentid,&#xD;&#xA;			cp.componentdescription,&#xD;&#xA;			cp.createdat  at time zone 'utc',&#xD;&#xA;			cp.createdby,&#xD;&#xA;			cp.updatedat  at time zone 'utc',&#xD;&#xA;			cp.updatedby&#xD;&#xA;			FROM Components cp&#xD;&#xA;			WHERE cp.componentname != vRoot&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getallcomponents" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getallcomponents" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallcomponents" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getallcomponents" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getallcomponents" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentuuid" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.getallcomponents" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallcomponents" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallcomponents" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getallcomponents" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getallcomponents" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <code>CREATE FUNCTION getallcomponents(vuseruuid uuid, vroles text[]) RETURNS TABLE(componentuuid uuid, componentname character varying, componentparentuuid integer, componentdescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetAllComponents';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
		vRoot varchar := 'Root';

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  cp.componentuuid,
			cp.componentname,
			cp.componentparentid,
			cp.componentdescription,
			cp.createdat  at time zone 'utc',
			cp.createdby,
			cp.updatedat  at time zone 'utc',
			cp.updatedby
			FROM Components cp
			WHERE cp.componentname != vRoot
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getalloffers" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetAllOffers';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  offeruuid,&#xD;&#xA;				paymentinvoiceuuid,&#xD;&#xA;				offr.createdat at time zone 'utc',&#xD;&#xA;				offr.createdby&#xD;&#xA;			FROM offer offr JOIN&#xD;&#xA;			paymentinvoice pi ON offr.paymentinvoiceid = pi.paymentinvoiceid&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getalloffers" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalloffers" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getalloffers" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getalloffers" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalloffers" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getalloffers" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getalloffers(vuseruuid character varying, vroles text[]) RETURNS TABLE(offeruuid uuid, paymentinvoiceuuid uuid, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetAllOffers';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  offeruuid,
				paymentinvoiceuuid,
				offr.createdat at time zone 'utc',
				offr.createdby
			FROM offer offr JOIN
			paymentinvoice pi ON offr.paymentinvoiceid = pi.paymentinvoiceid
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getalltags" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetAllTags';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  taguuid,&#xD;&#xA;				tagname,&#xD;&#xA;				tg.createdat  at time zone 'utc',&#xD;&#xA;				tg.createdby,&#xD;&#xA;				tg.updatedat  at time zone 'utc',&#xD;&#xA;				tg.updatedby&#xD;&#xA;		    FROM tags tg&#xD;&#xA;		  );&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getalltags" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getalltags" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltags" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltags" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getalltags" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="taguuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltags" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="tagname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getalltags" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getalltags" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getalltags(vuseruuid uuid, vroles text[]) RETURNS TABLE(taguuid uuid, tagname character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetAllTags';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  taguuid,
				tagname,
				tg.createdat  at time zone 'utc',
				tg.createdby,
				tg.updatedat  at time zone 'utc',
				tg.updatedby
		    FROM tags tg
		  );

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getalltechnologies" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetAllTechnologies';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  technologyuuid,&#xD;&#xA;				technologyname,&#xD;&#xA;				technologydescription,&#xD;&#xA;				tg.createdat at time zone 'utc',&#xD;&#xA;				tg.createdby,&#xD;&#xA;				tg.updatedat at time zone 'utc',&#xD;&#xA;				tg.updatedby&#xD;&#xA;		    FROM Technologies tg&#xD;&#xA;		 );&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getalltechnologies" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologies" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getalltechnologies" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getalltechnologies" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologies" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologies" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getalltechnologies" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologies" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getalltechnologies" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydescription" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION getalltechnologies(vuseruuid uuid, vroles text[]) RETURNS TABLE(technologyuuid uuid, technologyname character varying, technologydescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetAllTechnologies';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  technologyuuid,
				technologyname,
				technologydescription,
				tg.createdat at time zone 'utc',
				tg.createdby,
				tg.updatedat at time zone 'utc',
				tg.updatedby
		    FROM Technologies tg
		 );

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getalltechnologydata" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE vFunctionName varchar := 'GetAllTechnologyData';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;		RETURN QUERY (SELECT 	technologydatauuid,&#xD;&#xA;					tc.technologyuuid,&#xD;&#xA;					td.technologydataname,&#xD;&#xA;					technologydata,&#xD;&#xA;					technologydatadescription,&#xD;&#xA;					licensefee,&#xD;&#xA;					td.productcode,&#xD;&#xA;					technologydatathumbnail,&#xD;&#xA;					technologydataimgref,&#xD;&#xA;					td.createdat  at time zone 'utc',&#xD;&#xA;					td.createdBy,&#xD;&#xA;					td.updatedat  at time zone 'utc',&#xD;&#xA;					td.UpdatedBy&#xD;&#xA;			FROM TechnologyData td&#xD;&#xA;			join technologies tc&#xD;&#xA;			on td.technologyid = tc.technologyid&#xD;&#xA;			);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getalltechnologydata" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getalltechnologydata" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getalltechnologydata" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getalltechnologydata" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="productcode" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.getalltechnologydata" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.getalltechnologydata" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatathumbnail" data_type="bytea" udt="pg_catalog.bytea" />
    <param parent="public.getalltechnologydata" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataimgref" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getalltechnologydata" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getalltechnologydata" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologydata" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="useruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologydata" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getalltechnologydata" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologydata" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getalltechnologydata" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getalltechnologydata" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getalltechnologydata(vuseruuid uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, technologyuuid uuid, technologydataname character varying, technologydata character varying, technologydatadescription character varying, productcode integer, licensefee bigint, technologydatathumbnail bytea, technologydataimgref character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, useruuid uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE vFunctionName varchar := 'GetAllTechnologyData';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

		RETURN QUERY (SELECT 	technologydatauuid,
					tc.technologyuuid,
					td.technologydataname,
					technologydata,
					technologydatadescription,
					licensefee,
					td.productcode,
					technologydatathumbnail,
					technologydataimgref,
					td.createdat  at time zone 'utc',
					td.createdBy,
					td.updatedat  at time zone 'utc',
					td.UpdatedBy
			FROM TechnologyData td
			join technologies tc
			on td.technologyid = tc.technologyid
			);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
	$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getattributebyid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetAttributeById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY	(SELECT  attributeuuid,&#xD;&#xA;				attributename,&#xD;&#xA;				att.createdat at time zone 'utc',&#xD;&#xA;				att.createdby,&#xD;&#xA;				att.updatedat at time zone 'utc',&#xD;&#xA;				att.updatedby&#xD;&#xA;			FROM attributes att&#xD;&#xA;			WHERE attributeUUID = vAttrUUID&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getattributebyid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributename" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getattributebyid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getattributebyid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getattributebyid" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getattributebyid" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getattributebyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vattruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getattributebyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getattributebyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getattributebyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributeuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getattributebyid(vattruuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(attributeuuid uuid, attributename character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetAttributeById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY	(SELECT  attributeuuid,
				attributename,
				att.createdat at time zone 'utc',
				att.createdby,
				att.updatedat at time zone 'utc',
				att.updatedby
			FROM attributes att
			WHERE attributeUUID = vAttrUUID
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getattributebyname" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetAttributeByName';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY	(SELECT  attributeuuid,&#xD;&#xA;				attributename,&#xD;&#xA;				att.createdat at time zone 'utc',&#xD;&#xA;				att.createdby,&#xD;&#xA;				att.updatedat at time zone 'utc',&#xD;&#xA;				att.updatedby&#xD;&#xA;			FROM attributes att&#xD;&#xA;			WHERE attributeName = vAttrName&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getattributebyname" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getattributebyname" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getattributebyname" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributename" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getattributebyname" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vattrname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getattributebyname" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributeuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getattributebyname" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getattributebyname" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getattributebyname" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getattributebyname" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getattributebyname(vattrname character varying, vuseruuid uuid, vroles text[]) RETURNS TABLE(attributeuuid uuid, attributename character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetAttributeByName';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY	(SELECT  attributeuuid,
				attributename,
				att.createdat at time zone 'utc',
				att.createdby,
				att.updatedat at time zone 'utc',
				att.updatedby
			FROM attributes att
			WHERE attributeName = vAttrName
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getcomponentbyid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetComponentById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  cp.componentuuid,&#xD;&#xA;				cp.componentname,&#xD;&#xA;				cs.componentuuid,&#xD;&#xA;				cp.componentdescription,&#xD;&#xA;				cp.createdat  at time zone 'utc',&#xD;&#xA;				cp.createdby,&#xD;&#xA;				cp.updatedat  at time zone 'utc',&#xD;&#xA;				cp.updatedby&#xD;&#xA;		    FROM Components cp&#xD;&#xA;		    left outer join components cs on&#xD;&#xA;		    cp.componentparentid = cs.componentid&#xD;&#xA;		    WHERE cp.componentuuid = vCompUUID&#xD;&#xA;		  );&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getcomponentbyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcompuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getcomponentbyid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentbyid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentbyid" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getcomponentbyid" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyid" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getcomponentbyid" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getcomponentbyid(vcompuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(componentuuid uuid, componentname character varying, componentparentuuid uuid, componentdescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetComponentById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  cp.componentuuid,
				cp.componentname,
				cs.componentuuid,
				cp.componentdescription,
				cp.createdat  at time zone 'utc',
				cp.createdby,
				cp.updatedat  at time zone 'utc',
				cp.updatedby
		    FROM Components cp
		    left outer join components cs on
		    cp.componentparentid = cs.componentid
		    WHERE cp.componentuuid = vCompUUID
		  );
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getcomponentbyname" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetComponentByName';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  	componentuuid,&#xD;&#xA;				cp.componentname,&#xD;&#xA;				cp.componentparentid,&#xD;&#xA;				cp.componentdescription,&#xD;&#xA;				cp.createdat  at time zone 'utc',&#xD;&#xA;				cp.createdby,&#xD;&#xA;				cp.updatedat  at time zone 'utc',&#xD;&#xA;				cp.updatedby&#xD;&#xA;		    FROM Components cp&#xD;&#xA;		    WHERE cp.componentname = vCompName&#xD;&#xA;		 );&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getcomponentbyname" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyname" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcompname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentbyname" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyname" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getcomponentbyname" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyname" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentbyname" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentuuid" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.getcomponentbyname" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentbyname" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getcomponentbyname" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentbyname" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <code>CREATE FUNCTION getcomponentbyname(vcompname character varying, vuseruuid uuid, vroles text[]) RETURNS TABLE(componentuuid uuid, componentname character varying, componentparentuuid integer, componentdescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetComponentByName';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  	componentuuid,
				cp.componentname,
				cp.componentparentid,
				cp.componentdescription,
				cp.createdat  at time zone 'utc',
				cp.createdby,
				cp.updatedat  at time zone 'utc',
				cp.updatedby
		    FROM Components cp
		    WHERE cp.componentname = vCompName
		 );

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getcomponentsbytechnology" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetComponentsByTechnology';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select 	co.componentUUID,&#xD;&#xA;			co.componentName,&#xD;&#xA;			cs.componentUUID as componentParentUUID,&#xD;&#xA;			cs.componentName as componentParentName,&#xD;&#xA;			co.componentDescription,&#xD;&#xA;			co.createdat at time zone 'utc',&#xD;&#xA;			co.createdby,&#xD;&#xA;			co.updatedat at time zone 'utc',&#xD;&#xA;			co.updatedby&#xD;&#xA;			from components co&#xD;&#xA;			join componentstechnologies ct&#xD;&#xA;			on co.componentid = ct.componentid&#xD;&#xA;			join technologies tc&#xD;&#xA;			on tc.technologyid = ct.technologyid&#xD;&#xA;			left outer join components cs&#xD;&#xA;			on co.componentparentid = cs.componentid&#xD;&#xA;			where tc.technologyuuid = vTechnologyUUID&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getcomponentsbytechnology" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="useruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsbytechnology" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getcomponentsbytechnology(vtechnologyuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(componentuuid uuid, componentname character varying, componentparentuuid uuid, componentparentname character varying, componentdescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, useruuid uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetComponentsByTechnology';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select 	co.componentUUID,
			co.componentName,
			cs.componentUUID as componentParentUUID,
			cs.componentName as componentParentName,
			co.componentDescription,
			co.createdat at time zone 'utc',
			co.createdby,
			co.updatedat at time zone 'utc',
			co.updatedby
			from components co
			join componentstechnologies ct
			on co.componentid = ct.componentid
			join technologies tc
			on tc.technologyid = ct.technologyid
			left outer join components cs
			on co.componentparentid = cs.componentid
			where tc.technologyuuid = vTechnologyUUID
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getcomponentsfortechnologydataid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetComponentsForTechnologyDataId';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select	co.componentuuid,&#xD;&#xA;				co.componentname,&#xD;&#xA;				cp.componentuuid as ComponentParentUUID,&#xD;&#xA;				cp.componentname as ComponentParentName,&#xD;&#xA;				co.componentDescription,&#xD;&#xA;				co.createdat at time zone 'utc',&#xD;&#xA;				td.CreatedBy,&#xD;&#xA;				co.updatedat at time zone 'utc',&#xD;&#xA;				td.UpdatedBy&#xD;&#xA;			from technologydata td&#xD;&#xA;			join technologydatacomponents tc&#xD;&#xA;			on td.technologydataid = tc.technologydataid&#xD;&#xA;			join components co on&#xD;&#xA;			co.componentid = tc.componentid&#xD;&#xA;			join components cp on&#xD;&#xA;			co.componentparentid = cp.componentid&#xD;&#xA;			where td.technologydatauuid = vTechnologyDataUUID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="useruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getcomponentsfortechnologydataid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getcomponentsfortechnologydataid(vtechnologydatauuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(componentuuid uuid, componentname character varying, componentparentuuid uuid, componentparentname character varying, componentdescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, useruuid uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetComponentsForTechnologyDataId';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select	co.componentuuid,
				co.componentname,
				cp.componentuuid as ComponentParentUUID,
				cp.componentname as ComponentParentName,
				co.componentDescription,
				co.createdat at time zone 'utc',
				td.CreatedBy,
				co.updatedat at time zone 'utc',
				td.UpdatedBy
			from technologydata td
			join technologydatacomponents tc
			on td.technologydataid = tc.technologydataid
			join components co on
			co.componentid = tc.componentid
			join components cp on
			co.componentparentid = cp.componentid
			where td.technologydatauuid = vTechnologyDataUUID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
	$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getlicensefeebytechnologydata" routine_type="FUNCTION" return_type="pg_catalog.int8" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetLicenseFeeByTechnologyData';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select	td.licenseFee&#xD;&#xA;			from technologydata td&#xD;&#xA;			where td.technologydatauuid = vTechnologyDataUUID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getlicensefeebytechnologydata" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.getlicensefeebytechnologydata" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getlicensefeebytechnologydata" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getlicensefeebytechnologydata" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getlicensefeebytechnologydata(vtechnologydatauuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(licensefee bigint)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetLicenseFeeByTechnologyData';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select	td.licenseFee
			from technologydata td
			where td.technologydatauuid = vTechnologyDataUUID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getlicensefeebytransaction" routine_type="FUNCTION" return_type="pg_catalog.int8" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetLicenseFeeByTransaction';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select	td.licenseFee&#xD;&#xA;			from transactions ts&#xD;&#xA;			join offerrequest oq&#xD;&#xA;			on oq.offerrequestid = ts.offerrequestid&#xD;&#xA;			join offerrequestitems ri&#xD;&#xA;			on oq.offerrequestid = ri.offerrequestid&#xD;&#xA;			join technologydata td&#xD;&#xA;			on ri.technologydataid = td.technologydataid&#xD;&#xA;			where ts.transactionuuid = vTransactionUUID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getlicensefeebytransaction" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getlicensefeebytransaction" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtransactionuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getlicensefeebytransaction" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getlicensefeebytransaction" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <code>CREATE FUNCTION getlicensefeebytransaction(vtransactionuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(licensefee bigint)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetLicenseFeeByTransaction';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select	td.licenseFee
			from transactions ts
			join offerrequest oq
			on oq.offerrequestid = ts.offerrequestid
			join offerrequestitems ri
			on oq.offerrequestid = ri.offerrequestid
			join technologydata td
			on ri.technologydataid = td.technologydataid
			where ts.transactionuuid = vTransactionUUID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getnewproductcode" routine_type="FUNCTION" return_type="pg_catalog.int4" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetNewProductCode';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;		IF(vIsAllowed) then&#xD;&#xA;			RETURN QUERY (select nextval('ProductCode')::integer);&#xD;&#xA;		else&#xD;&#xA;			RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;			RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getnewproductcode" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION getnewproductcode(vroles text[]) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetNewProductCode';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN
		IF(vIsAllowed) then
			RETURN QUERY (select nextval('ProductCode')::integer);
		else
			RAISE EXCEPTION '%', 'Insufficiency rigths';
			RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getofferbyid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetOfferById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  ofr.offeruuid,&#xD;&#xA;				pm.paymentinvoiceuuid,&#xD;&#xA;				ofr.createdat at time zone 'utc',&#xD;&#xA;				ofr.createdby&#xD;&#xA;			FROM offer ofr&#xD;&#xA;			JOIN paymentinvoice pm&#xD;&#xA;			ON ofr.paymentinvoiceid = pm.paymentinvoiceid&#xD;&#xA;			WHERE ofr.offeruuid = vOfferID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getofferbyid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getofferbyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getofferbyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getofferbyid(vofferid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(offeruuid uuid, paymentinvoiceuuid uuid, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetOfferById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  ofr.offeruuid,
				pm.paymentinvoiceuuid,
				ofr.createdat at time zone 'utc',
				ofr.createdby
			FROM offer ofr
			JOIN paymentinvoice pm
			ON ofr.paymentinvoiceid = pm.paymentinvoiceid
			WHERE ofr.offeruuid = vOfferID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getofferbyrequestid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetOfferByRequestID';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  ofr.offeruuid,&#xD;&#xA;				pm.paymentinvoiceuuid,&#xD;&#xA;				ofr.createdat at time zone 'utc',&#xD;&#xA;				ofr.createdby&#xD;&#xA;			FROM offer ofr&#xD;&#xA;			JOIN paymentinvoice pm&#xD;&#xA;			ON ofr.paymentinvoiceid = pm.paymentinvoiceid&#xD;&#xA;			WHERE pm.offerrequestid = (select offerrequest.offerrequestid from offerrequest where offerrequestuuid = vRequestID)&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getofferbyrequestid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyrequestid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getofferbyrequestid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyrequestid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vrequestid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyrequestid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferbyrequestid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getofferbyrequestid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getofferbyrequestid(vrequestid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(offeruuid uuid, paymentinvoiceuuid uuid, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetOfferByRequestID';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  ofr.offeruuid,
				pm.paymentinvoiceuuid,
				ofr.createdat at time zone 'utc',
				ofr.createdby
			FROM offer ofr
			JOIN paymentinvoice pm
			ON ofr.paymentinvoiceid = pm.paymentinvoiceid
			WHERE pm.offerrequestid = (select offerrequest.offerrequestid from offerrequest where offerrequestuuid = vRequestID)
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
   $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getofferforpaymentinvoice" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetOfferForPaymentInvoice';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select 	ofr.offerUUID,&#xD;&#xA;				pi.PaymentInvoiceUUID,&#xD;&#xA;				pi.createdat at time zone 'utc',&#xD;&#xA;				ofr.createdby&#xD;&#xA;			from Offer ofr&#xD;&#xA;			join paymentinvoice pi&#xD;&#xA;			on ofr.paymentinvoiceid = pi.paymentinvoiceid&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getofferforpaymentinvoice" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferforpaymentinvoice" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getofferforpaymentinvoice" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferforpaymentinvoice" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vpaymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferforpaymentinvoice" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferforpaymentinvoice" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getofferforpaymentinvoice" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getofferforpaymentinvoice(vpaymentinvoiceuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(offeruuid uuid, paymentinvoiceuuid uuid, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetOfferForPaymentInvoice';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select 	ofr.offerUUID,
				pi.PaymentInvoiceUUID,
				pi.createdat at time zone 'utc',
				ofr.createdby
			from Offer ofr
			join paymentinvoice pi
			on ofr.paymentinvoiceid = pi.paymentinvoiceid
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getofferforticket" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetOfferForTicket';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select 	ofr.offerUUID,&#xD;&#xA;				pi.PaymentInvoiceUUID,&#xD;&#xA;				pi.createdat at time zone 'utc',&#xD;&#xA;				ofr.createdby&#xD;&#xA;			from Offer ofr&#xD;&#xA;			join paymentinvoice pi&#xD;&#xA;			on ofr.paymentinvoiceid = pi.paymentinvoiceid&#xD;&#xA;			join licenseorder lo&#xD;&#xA;			on lo.offerid = ofr.offerid&#xD;&#xA;			and lo.ticketid = vTicketID&#xD;&#xA;&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getofferforticket" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferforticket" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getofferforticket" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferforticket" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vticketid" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getofferforticket" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferforticket" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getofferforticket" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getofferforticket(vticketid character varying, vuseruuid uuid, vroles text[]) RETURNS TABLE(offeruuid uuid, paymentinvoiceuuid uuid, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetOfferForTicket';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select 	ofr.offerUUID,
				pi.PaymentInvoiceUUID,
				pi.createdat at time zone 'utc',
				ofr.createdby
			from Offer ofr
			join paymentinvoice pi
			on ofr.paymentinvoiceid = pi.paymentinvoiceid
			join licenseorder lo
			on lo.offerid = ofr.offerid
			and lo.ticketid = vTicketID

		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getofferfortransaction" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetOfferForTransaction';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select 	ofr.offerUUID,&#xD;&#xA;				pi.PaymentInvoiceUUID,&#xD;&#xA;				pi.createdat at time zone 'utc',&#xD;&#xA;				ofr.createdby&#xD;&#xA;			from Offer ofr&#xD;&#xA;			join paymentinvoice pi&#xD;&#xA;			on ofr.paymentinvoiceid = pi.paymentinvoiceid&#xD;&#xA;			join transactions ts&#xD;&#xA;			on ts.offerid = ofr.offerid&#xD;&#xA;			and ts.transactionuuid = vTransactionUUID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getofferfortransaction" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferfortransaction" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferfortransaction" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getofferfortransaction" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferfortransaction" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferfortransaction" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getofferfortransaction" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtransactionuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION getofferfortransaction(vtransactionuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(offeruuid uuid, paymentinvoiceuuid uuid, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetOfferForTransaction';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select 	ofr.offerUUID,
				pi.PaymentInvoiceUUID,
				pi.createdat at time zone 'utc',
				ofr.createdby
			from Offer ofr
			join paymentinvoice pi
			on ofr.paymentinvoiceid = pi.paymentinvoiceid
			join transactions ts
			on ts.offerid = ofr.offerid
			and ts.transactionuuid = vTransactionUUID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getofferrequestbyid" routine_type="FUNCTION" return_type="pg_catalog.json" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="declare&#xD;&#xA;		vFunctionName varchar := 'GetOfferRequestById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;	 RETURN QUERY (select row_to_json (t) as result from (&#xD;&#xA;			select offerrequestuuid,&#xD;&#xA;			(&#xD;&#xA;			select	 array_to_json(array_agg(row_to_json(d)))&#xD;&#xA;			from (select   td.TechnologyDataUUID::uuid,   oi.Amount, td.ProductCode&#xD;&#xA;				from offerrequest ofr&#xD;&#xA;				join offerrequestitems oi&#xD;&#xA;				on oi.offerrequestid = ofr.offerrequestid&#xD;&#xA;				join technologydata td&#xD;&#xA;				on oi.technologydataid = td.technologydataid&#xD;&#xA;				where offerrequestuuid = vOfferRequestUUID&#xD;&#xA;				) d&#xD;&#xA;			 ) as items, HSMID, CreatedAt at time zone 'utc' as CreatedAt, RequestedBy&#xD;&#xA;		 from offerrequest where offerrequestuuid = vOfferRequestUUID) t&#xD;&#xA;		 );&#xD;&#xA;	ELSE&#xD;&#xA;			RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;			RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getofferrequestbyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferrequestbyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getofferrequestbyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="result" data_type="json" udt="pg_catalog.json" />
    <param parent="public.getofferrequestbyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION getofferrequestbyid(vofferrequestuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(result json)
    LANGUAGE plpgsql
    AS $$
	declare
		vFunctionName varchar := 'GetOfferRequestById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
	 RETURN QUERY (select row_to_json (t) as result from (
			select offerrequestuuid,
			(
			select	 array_to_json(array_agg(row_to_json(d)))
			from (select   td.TechnologyDataUUID::uuid,   oi.Amount, td.ProductCode
				from offerrequest ofr
				join offerrequestitems oi
				on oi.offerrequestid = ofr.offerrequestid
				join technologydata td
				on oi.technologydataid = td.technologydataid
				where offerrequestuuid = vOfferRequestUUID
				) d
			 ) as items, HSMID, CreatedAt at time zone 'utc' as CreatedAt, RequestedBy
		 from offerrequest where offerrequestuuid = vOfferRequestUUID) t
		 );
	ELSE
			RAISE EXCEPTION '%', 'Insufficiency rigths';
			RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getpaymentinvoiceforofferrequest" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetPaymentInvoiceForOfferRequest';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select 	pi.paymentinvoiceuuid,&#xD;&#xA;							oq.offerrequestuuid,&#xD;&#xA;							pi.invoice,&#xD;&#xA;							pi.createdat at time zone 'utc',&#xD;&#xA;							pi.createdby&#xD;&#xA;				from PaymentInvoice pi&#xD;&#xA;				join offerrequest oq&#xD;&#xA;				on pi.offerrequestid = oq.offerrequestid&#xD;&#xA;				where oq.offerRequestUUID = vOfferRequestUUID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="invoice" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offerrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getpaymentinvoiceforofferrequest" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <code>CREATE FUNCTION getpaymentinvoiceforofferrequest(vofferrequestuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(paymentinvoiceuuid uuid, offerrequestuuid uuid, invoice character varying, createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetPaymentInvoiceForOfferRequest';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select 	pi.paymentinvoiceuuid,
							oq.offerrequestuuid,
							pi.invoice,
							pi.createdat at time zone 'utc',
							pi.createdby
				from PaymentInvoice pi
				join offerrequest oq
				on pi.offerrequestid = oq.offerrequestid
				where oq.offerRequestUUID = vOfferRequestUUID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getrevenue" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetRevenue';&#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName)); 				&#xD;&#xA;				vPublic text := (select t from unnest(vRoles) as t limit 1);&#xD;&#xA;&#xD;&#xA;			BEGIN&#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			IF(vPublic = 'Public') THEN vCreatedBy := null; END IF;&#xD;&#xA;&#xD;&#xA;			RETURN QUERY ( with revenue as (&#xD;&#xA;				select  case when (to_char(activatedat,'YYYY') is null) then '0' else to_char(activatedat,'YYYY') end as Year,&#xD;&#xA;					case when (to_char(activatedat,'MM') is null) then '0' else to_char(activatedat,'MM') end as Month, &#xD;&#xA;					case when (to_char(activatedat,'DD') is null) then '0' else to_char(activatedat,'DD') end as Day, &#xD;&#xA;					case when (to_char(activatedat,'HH24') is null) then '0' else to_char(activatedat,'HH24') end as Hour, 					&#xD;&#xA;					coalesce(td.technologydatauuid,'00000000-0000-0000-0000-000000000000') as technologydatauuid, &#xD;&#xA;					sum(ri.amount) as amount, &#xD;&#xA;					(sum(td.licensefee*ri.amount))::bigint as revenue,&#xD;&#xA;					(AVG(td.licensefee*ri.amount))::bigint as average	&#xD;&#xA;				from transactions ts&#xD;&#xA;					join licenseorder lo&#xD;&#xA;					on ts.licenseorderid = lo.licenseorderid&#xD;&#xA;					join offerrequest oq&#xD;&#xA;					on oq.offerrequestid = ts.offerrequestid&#xD;&#xA;					join offerrequestitems ri&#xD;&#xA;					on ri.offerrequestid = oq.offerrequestid&#xD;&#xA;					join technologydata td			&#xD;&#xA;					on ri.technologydataid = td.technologydataid 	&#xD;&#xA;					where (vcreatedby is null or td.createdby = vcreatedby)&#xD;&#xA;					and (activatedat between vFrom and vTo)			&#xD;&#xA;					group by CUBE (to_char(activatedat,'YYYY'), &#xD;&#xA;							to_char(activatedat,'MM'), &#xD;&#xA;							to_char(activatedat,'DD'), &#xD;&#xA;							to_char(activatedat,'HH24'), &#xD;&#xA;							td.technologydatauuid)&#xD;&#xA;					order by to_char(activatedat,'YYYY') asc, &#xD;&#xA;							to_char(activatedat,'MM') asc, &#xD;&#xA;							to_char(activatedat,'DD') asc, &#xD;&#xA;							to_char(activatedat,'HH24') asc, &#xD;&#xA;							td.technologydatauuid asc,&#xD;&#xA;							amount desc&#xD;&#xA;				)&#xD;&#xA;				select	r.year::text, &#xD;&#xA;					r.month::text,&#xD;&#xA;					r.day::text,&#xD;&#xA;					r.hour::text,&#xD;&#xA;					r.technologydatauuid,&#xD;&#xA;					r.Amount::integer,&#xD;&#xA;					r.Revenue::bigint,&#xD;&#xA;					r.Average::bigint&#xD;&#xA;				from revenue r  &#xD;&#xA;				where (vTechnologyDataUUID is null or r.technologydatauuid = vTechnologyDataUUID)&#xD;&#xA;				);&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getrevenue" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getrevenue" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="year" data_type="text" udt="pg_catalog.text" />
    <param parent="public.getrevenue" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getrevenue" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getrevenue" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vto" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getrevenue" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfrom" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getrevenue" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="month" data_type="text" udt="pg_catalog.text" />
    <param parent="public.getrevenue" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="day" data_type="text" udt="pg_catalog.text" />
    <param parent="public.getrevenue" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="hour" data_type="text" udt="pg_catalog.text" />
    <param parent="public.getrevenue" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getrevenue" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="amount" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.getrevenue" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.getrevenue" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="average" data_type="bigint" udt="pg_catalog.int8" />
    <code>CREATE FUNCTION getrevenue(vfrom timestamp with time zone, vto timestamp with time zone, vtechnologydatauuid uuid, vcreatedby uuid, vroles text[]) RETURNS TABLE(year text, month text, day text, hour text, technologydatauuid uuid, amount integer, revenue bigint, average bigint)
    LANGUAGE plpgsql
    AS $$

			DECLARE
				vFunctionName varchar := 'GetRevenue';
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName)); 				
				vPublic text := (select t from unnest(vRoles) as t limit 1);

			BEGIN

			IF(vIsAllowed) THEN

			IF(vPublic = 'Public') THEN vCreatedBy := null; END IF;

			RETURN QUERY ( with revenue as (
				select  case when (to_char(activatedat,'YYYY') is null) then '0' else to_char(activatedat,'YYYY') end as Year,
					case when (to_char(activatedat,'MM') is null) then '0' else to_char(activatedat,'MM') end as Month, 
					case when (to_char(activatedat,'DD') is null) then '0' else to_char(activatedat,'DD') end as Day, 
					case when (to_char(activatedat,'HH24') is null) then '0' else to_char(activatedat,'HH24') end as Hour, 					
					coalesce(td.technologydatauuid,'00000000-0000-0000-0000-000000000000') as technologydatauuid, 
					sum(ri.amount) as amount, 
					(sum(td.licensefee*ri.amount))::bigint as revenue,
					(AVG(td.licensefee*ri.amount))::bigint as average	
				from transactions ts
					join licenseorder lo
					on ts.licenseorderid = lo.licenseorderid
					join offerrequest oq
					on oq.offerrequestid = ts.offerrequestid
					join offerrequestitems ri
					on ri.offerrequestid = oq.offerrequestid
					join technologydata td			
					on ri.technologydataid = td.technologydataid 	
					where (vcreatedby is null or td.createdby = vcreatedby)
					and (activatedat between vFrom and vTo)			
					group by CUBE (to_char(activatedat,'YYYY'), 
							to_char(activatedat,'MM'), 
							to_char(activatedat,'DD'), 
							to_char(activatedat,'HH24'), 
							td.technologydatauuid)
					order by to_char(activatedat,'YYYY') asc, 
							to_char(activatedat,'MM') asc, 
							to_char(activatedat,'DD') asc, 
							to_char(activatedat,'HH24') asc, 
							td.technologydatauuid asc,
							amount desc
				)
				select	r.year::text, 
					r.month::text,
					r.day::text,
					r.hour::text,
					r.technologydatauuid,
					r.Amount::integer,
					r.Revenue::bigint,
					r.Average::bigint
				from revenue r  
				where (vTechnologyDataUUID is null or r.technologydatauuid = vTechnologyDataUUID)
				);
			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
		$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getrevenuehistory" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetRevenueHistory'; &#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));		&#xD;&#xA;&#xD;&#xA;			BEGIN &#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			RETURN QUERY (with basis as (select r.year, r.month, r.day, r.hour, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue, r.average  from public.getrevenue(&#xD;&#xA;					    vfrom,&#xD;&#xA;					    vto,&#xD;&#xA;					    null,&#xD;&#xA;					    vcreatedby,&#xD;&#xA;					    vroles) r&#xD;&#xA;					join technologydata td on td.technologydatauuid = r.technologydatauuid&#xD;&#xA;					where r.year &lt;&gt; '0' and r.month &lt;&gt; '0' and r.day &lt;&gt; '0' and r.hour &lt;&gt; '0'&#xD;&#xA;					and r.technologydatauuid &lt;&gt; uuid_nil()&#xD;&#xA;					order by r.year, r.month, r.day, r.hour, td.technologydatauuid),&#xD;&#xA;					benchmark as (&#xD;&#xA;					select r.year, r.month, r.day, 'Benchmark'::text as technologydataname, (r.revenue / r.amount) as revenue from public.getrevenue(&#xD;&#xA;					    vfrom,&#xD;&#xA;					    vto,&#xD;&#xA;					    null,&#xD;&#xA;					    null,&#xD;&#xA;					    vroles) r &#xD;&#xA;					where r.year &lt;&gt; '0' and r.month &lt;&gt; '0' and r.day &lt;&gt; '0' and r.hour = '0'&#xD;&#xA;					and r.technologydatauuid = uuid_nil()&#xD;&#xA;					group by r.year, r.month, r.day, r.revenue, r.amount			 &#xD;&#xA;					),&#xD;&#xA;					techName as (select distinct a.technologydataname&#xD;&#xA;							from basis a),			&#xD;&#xA;					dates as (select distinct a.year, a.month, a.day&#xD;&#xA;							from benchmark a ),							&#xD;&#xA;					allData as (select tn.technologydataname, dt.year, dt.month, dt.day&#xD;&#xA;							from techname tn, dates dt),&#xD;&#xA;					totalData as (select ad.year, ad.month, ad.day, ad.technologydataname, case when (ba.revenue is null) then 0::bigint else ba.revenue::bigint end as revenue&#xD;&#xA;						from allData ad&#xD;&#xA;						left outer join basis ba&#xD;&#xA;						on ad.year = ba.year&#xD;&#xA;						and ad.month = ba.month&#xD;&#xA;						and ad.day = ba.day&#xD;&#xA;						and ad.technologydataname = ba.technologydataname),&#xD;&#xA;					result as (			&#xD;&#xA;					select to_date(t.year || '-' || t.month || '-' || t.day, 'YYYY-MM-DD') as date, t.technologydataname, t.revenue::bigint from totalData t			union all &#xD;&#xA;					select to_date(b.year || '-' || b.month || '-' || b.day, 'YYYY-MM-DD') as date, b.technologydataname, b.revenue::bigint from benchmark b)&#xD;&#xA;					select rs.date, rs.technologydataname, sum(rs.revenue)::bigint from result rs&#xD;&#xA;					group by rs.date, rs.technologydataname&#xD;&#xA;					order by rs.date asc&#xD;&#xA;					 &#xD;&#xA;				&#xD;&#xA;				);&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getrevenuehistory" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.getrevenuehistory" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfrom" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getrevenuehistory" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vto" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.getrevenuehistory" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getrevenuehistory" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getrevenuehistory" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="date" data_type="date" udt="pg_catalog.date" />
    <param parent="public.getrevenuehistory" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="text" udt="pg_catalog.text" />
    <code>CREATE FUNCTION getrevenuehistory(vfrom timestamp with time zone, vto timestamp with time zone, vcreatedby uuid, vroles text[]) RETURNS TABLE(date date, technologydataname text, revenue bigint)
    LANGUAGE plpgsql
    AS $$

			DECLARE
				vFunctionName varchar := 'GetRevenueHistory'; 
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));		

			BEGIN 

			IF(vIsAllowed) THEN

			RETURN QUERY (with basis as (select r.year, r.month, r.day, r.hour, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue, r.average  from public.getrevenue(
					    vfrom,
					    vto,
					    null,
					    vcreatedby,
					    vroles) r
					join technologydata td on td.technologydatauuid = r.technologydatauuid
					where r.year &lt;&gt; '0' and r.month &lt;&gt; '0' and r.day &lt;&gt; '0' and r.hour &lt;&gt; '0'
					and r.technologydatauuid &lt;&gt; uuid_nil()
					order by r.year, r.month, r.day, r.hour, td.technologydatauuid),
					benchmark as (
					select r.year, r.month, r.day, 'Benchmark'::text as technologydataname, (r.revenue / r.amount) as revenue from public.getrevenue(
					    vfrom,
					    vto,
					    null,
					    null,
					    vroles) r 
					where r.year &lt;&gt; '0' and r.month &lt;&gt; '0' and r.day &lt;&gt; '0' and r.hour = '0'
					and r.technologydatauuid = uuid_nil()
					group by r.year, r.month, r.day, r.revenue, r.amount			 
					),
					techName as (select distinct a.technologydataname
							from basis a),			
					dates as (select distinct a.year, a.month, a.day
							from benchmark a ),							
					allData as (select tn.technologydataname, dt.year, dt.month, dt.day
							from techname tn, dates dt),
					totalData as (select ad.year, ad.month, ad.day, ad.technologydataname, case when (ba.revenue is null) then 0::bigint else ba.revenue::bigint end as revenue
						from allData ad
						left outer join basis ba
						on ad.year = ba.year
						and ad.month = ba.month
						and ad.day = ba.day
						and ad.technologydataname = ba.technologydataname),
					result as (			
					select to_date(t.year || '-' || t.month || '-' || t.day, 'YYYY-MM-DD') as date, t.technologydataname, t.revenue::bigint from totalData t			union all 
					select to_date(b.year || '-' || b.month || '-' || b.day, 'YYYY-MM-DD') as date, b.technologydataname, b.revenue::bigint from benchmark b)
					select rs.date, rs.technologydataname, sum(rs.revenue)::bigint from result rs
					group by rs.date, rs.technologydataname
					order by rs.date asc
					 
				
				);
			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
		$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.getrevenueperdayforuser" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetRevenuePerForUSer';&#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;			BEGIN&#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			RETURN QUERY (select activatedat::date, (sum(td.licensefee*ri.amount))::bigint as &quot;Revenue (in IUNOs)&quot; from transactions ts&#xD;&#xA;					join licenseorder lo&#xD;&#xA;					on ts.licenseorderid = lo.licenseorderid&#xD;&#xA;					join offerrequest oq&#xD;&#xA;					on oq.offerrequestid = ts.offerrequestid&#xD;&#xA;					join offerrequestitems ri&#xD;&#xA;					on ri.offerrequestid = oq.offerrequestid&#xD;&#xA;					join technologydata td&#xD;&#xA;					on ri.technologydataid = td.technologydataid&#xD;&#xA;					where  activatedat::date = now()::date&#xD;&#xA;					and td.createdby = vUserUUID&#xD;&#xA;					and td.deleted is null&#xD;&#xA;					group by activatedat::date&#xD;&#xA;					order by activatedat::date&#xD;&#xA;				);&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.getrevenueperdayforuser" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.getrevenueperdayforuser" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="date" data_type="date" udt="pg_catalog.date" />
    <param parent="public.getrevenueperdayforuser" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.getrevenueperdayforuser" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <code>CREATE FUNCTION getrevenueperdayforuser(vuseruuid uuid, vroles text[]) RETURNS TABLE(date date, revenue bigint)
    LANGUAGE plpgsql
    AS $$
			DECLARE
				vFunctionName varchar := 'GetRevenuePerForUSer';
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

			BEGIN

			IF(vIsAllowed) THEN

			RETURN QUERY (select activatedat::date, (sum(td.licensefee*ri.amount))::bigint as "Revenue (in IUNOs)" from transactions ts
					join licenseorder lo
					on ts.licenseorderid = lo.licenseorderid
					join offerrequest oq
					on oq.offerrequestid = ts.offerrequestid
					join offerrequestitems ri
					on ri.offerrequestid = oq.offerrequestid
					join technologydata td
					on ri.technologydataid = td.technologydataid
					where  activatedat::date = now()::date
					and td.createdby = vUserUUID
					and td.deleted is null
					group by activatedat::date
					order by activatedat::date
				);
			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
			$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettagbyid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTagById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  taguuid,&#xD;&#xA;				tagname,&#xD;&#xA;				tg.createdat  at time zone 'utc',&#xD;&#xA;				tg.createdby,&#xD;&#xA;				tg.updatedat  at time zone 'utc',&#xD;&#xA;				tg.updatedby&#xD;&#xA;		    FROM tags tg&#xD;&#xA;		    WHERE tagUUID = vTagID&#xD;&#xA;		  );&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettagbyid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettagbyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="taguuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="tagname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettagbyid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettagbyid" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettagbyid" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtagid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION gettagbyid(vtagid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(taguuid uuid, tagname character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetTagById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  taguuid,
				tagname,
				tg.createdat  at time zone 'utc',
				tg.createdby,
				tg.updatedat  at time zone 'utc',
				tg.updatedby
		    FROM tags tg
		    WHERE tagUUID = vTagID
		  );

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettagbyname" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTagByName';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  taguuid,&#xD;&#xA;				tagname,&#xD;&#xA;				tg.createdat  at time zone 'utc',&#xD;&#xA;				tg.createdby,&#xD;&#xA;				tg.updatedat  at time zone 'utc',&#xD;&#xA;				tg.updatedby&#xD;&#xA;		    FROM tags tg&#xD;&#xA;		    WHERE tagName = vTagName&#xD;&#xA;		  );&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettagbyname" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyname" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettagbyname" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="taguuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyname" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="tagname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettagbyname" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettagbyname" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyname" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettagbyname" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettagbyname" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtagname" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION gettagbyname(vtagname character varying, vuseruuid uuid, vroles text[]) RETURNS TABLE(taguuid uuid, tagname character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetTagByName';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  taguuid,
				tagname,
				tg.createdat  at time zone 'utc',
				tg.createdby,
				tg.updatedat  at time zone 'utc',
				tg.updatedby
		    FROM tags tg
		    WHERE tagName = vTagName
		  );

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologybyid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTechnologyById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (SELECT  technologyuuid,&#xD;&#xA;			technologyname,&#xD;&#xA;			technologydescription,&#xD;&#xA;			tg.createdat at time zone 'utc',&#xD;&#xA;			tg.createdby,&#xD;&#xA;			tg.updatedat at time zone 'utc',&#xD;&#xA;			tg.updatedby&#xD;&#xA;		FROM Technologies tg&#xD;&#xA;		WHERE technologyuuid = vtechUUID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologybyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologybyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologybyid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologybyid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologybyid" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyid" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologybyid" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION gettechnologybyid(vtechuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(technologyuuid uuid, technologyname character varying, technologydescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTechnologyById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (SELECT  technologyuuid,
			technologyname,
			technologydescription,
			tg.createdat at time zone 'utc',
			tg.createdby,
			tg.updatedat at time zone 'utc',
			tg.updatedby
		FROM Technologies tg
		WHERE technologyuuid = vtechUUID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologybyname" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetTechnologyByName';&#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;			BEGIN&#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			RETURN QUERY (SELECT  	tg.technologyuuid,&#xD;&#xA;						tg.technologyname,&#xD;&#xA;						tg.technologydescription,&#xD;&#xA;						tg.createdat at time zone 'utc',&#xD;&#xA;						tg.createdby,&#xD;&#xA;						tg.updatedat at time zone 'utc',&#xD;&#xA;						tg.updatedby&#xD;&#xA;				    FROM Technologies tg&#xD;&#xA;				    WHERE lower(tg.technologyname) = lower(vtechName)&#xD;&#xA;				 );&#xD;&#xA;&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologybyname" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyname" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyname" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologybyname" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyname" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologybyname" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologybyname" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologybyname" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologybyname" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologybyname" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechname" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION gettechnologybyname(vtechname character varying, vuseruuid uuid, vroles text[]) RETURNS TABLE(technologyuuid uuid, technologyname character varying, technologydescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$

			DECLARE
				vFunctionName varchar := 'GetTechnologyByName';
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

			BEGIN

			IF(vIsAllowed) THEN

			RETURN QUERY (SELECT  	tg.technologyuuid,
						tg.technologyname,
						tg.technologydescription,
						tg.createdat at time zone 'utc',
						tg.createdby,
						tg.updatedat at time zone 'utc',
						tg.updatedby
				    FROM Technologies tg
				    WHERE lower(tg.technologyname) = lower(vtechName)
				 );

			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
		    $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologydatabyid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTechnologyDataById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (	SELECT 	td.technologydatauuid,&#xD;&#xA;				tc.technologyuuid,&#xD;&#xA;				td.technologydataname,&#xD;&#xA;				td.technologydata,&#xD;&#xA;				td.technologydatadescription,&#xD;&#xA;				td.productcode,&#xD;&#xA;				td.licensefee,&#xD;&#xA;				td.technologydatathumbnail,&#xD;&#xA;				td.technologydataimgref,&#xD;&#xA;				td.createdat  at time zone 'utc',&#xD;&#xA;				td.createdby,&#xD;&#xA;				td.updatedat  at time zone 'utc',&#xD;&#xA;				td.updatedby&#xD;&#xA;				FROM TechnologyData td&#xD;&#xA;				join technologies tc&#xD;&#xA;				on td.technologyid = tc.technologyid&#xD;&#xA;				where td.technologydatauuid = vtechnologydatauuid&#xD;&#xA;				and td.deleted is null&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologydatabyid" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="productcode" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettechnologydatabyid" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettechnologydatabyid" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatathumbnail" data_type="bytea" udt="pg_catalog.bytea" />
    <param parent="public.gettechnologydatabyid" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataimgref" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyid" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologydatabyid" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyid" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologydatabyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyid" ordinal_position="16" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedyby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydatabyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyid" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION gettechnologydatabyid(vtechnologydatauuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, technologyuuid uuid, technologydataname character varying, technologydata character varying, technologydatadescription character varying, productcode integer, licensefee bigint, technologydatathumbnail bytea, technologydataimgref character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedyby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTechnologyDataById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (	SELECT 	td.technologydatauuid,
				tc.technologyuuid,
				td.technologydataname,
				td.technologydata,
				td.technologydatadescription,
				td.productcode,
				td.licensefee,
				td.technologydatathumbnail,
				td.technologydataimgref,
				td.createdat  at time zone 'utc',
				td.createdby,
				td.updatedat  at time zone 'utc',
				td.updatedby
				FROM TechnologyData td
				join technologies tc
				on td.technologyid = tc.technologyid
				where td.technologydatauuid = vtechnologydatauuid
				and td.deleted is null
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologydatabyname" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTechnologyDataByName';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;    	RETURN QUERY (SELECT 	td.technologydatauuid,&#xD;&#xA;				tc.technologyuuid,&#xD;&#xA;				td.technologydataname,&#xD;&#xA;				td.technologydata,&#xD;&#xA;				td.technologydatadescription,&#xD;&#xA;				td.productcode,&#xD;&#xA;				td.licensefee,&#xD;&#xA;				td.technologydatathumbnail,&#xD;&#xA;				td.technologydataimgref,&#xD;&#xA;				td.createdat  at time zone 'utc',&#xD;&#xA;				td.createdby,&#xD;&#xA;				td.updatedat  at time zone 'utc',&#xD;&#xA;				td.updatedBy&#xD;&#xA;			FROM TechnologyData td&#xD;&#xA;			join technologies tc&#xD;&#xA;			on td.technologyid = tc.technologyid&#xD;&#xA;			where lower(td.technologydataname) = lower(vTechnologyDataName)&#xD;&#xA;			and td.deleted is null&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologydatabyname" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyname" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyname" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyname" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyname" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyname" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyname" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatathumbnail" data_type="bytea" udt="pg_catalog.bytea" />
    <param parent="public.gettechnologydatabyname" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettechnologydatabyname" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="productcode" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettechnologydatabyname" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologydatabyname" ordinal_position="16" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyname" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydatabyname" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyname" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyname" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologydatabyname" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataimgref" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION gettechnologydatabyname(vtechnologydataname character varying, vuseruuid uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, technologyuuid uuid, technologydataname character varying, technologydata character varying, technologydatadescription character varying, productcode integer, licensefee bigint, technologydatathumbnail bytea, technologydataimgref character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTechnologyDataByName';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

    	RETURN QUERY (SELECT 	td.technologydatauuid,
				tc.technologyuuid,
				td.technologydataname,
				td.technologydata,
				td.technologydatadescription,
				td.productcode,
				td.licensefee,
				td.technologydatathumbnail,
				td.technologydataimgref,
				td.createdat  at time zone 'utc',
				td.createdby,
				td.updatedat  at time zone 'utc',
				td.updatedBy
			FROM TechnologyData td
			join technologies tc
			on td.technologyid = tc.technologyid
			where lower(td.technologydataname) = lower(vTechnologyDataName)
			and td.deleted is null
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
	$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologydatabyofferrequest" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTechnologyDataByOfferRequest';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;    	RETURN QUERY (SELECT 	technologydatauuid,&#xD;&#xA;			tc.technologyuuid,&#xD;&#xA;			td.technologydataname,&#xD;&#xA;			technologydata,&#xD;&#xA;			technologydatadescription,&#xD;&#xA;			licensefee,&#xD;&#xA;			technologydatathumbnail,&#xD;&#xA;			technologydataimgref,&#xD;&#xA;			td.createdat  at time zone 'utc',&#xD;&#xA;			td.createdby,&#xD;&#xA;			td.updatedat  at time zone 'utc',&#xD;&#xA;			td.UpdatedBy&#xD;&#xA;			FROM TechnologyData td&#xD;&#xA;			join technologies tc&#xD;&#xA;			on td.technologyid = tc.technologyid&#xD;&#xA;			join offerrequest oq&#xD;&#xA;			on oq.technologydataid = td.technologydataid&#xD;&#xA;			and oq.offerrequestuuid = vOfferRequestUUID&#xD;&#xA;			and td.deleted is null&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="useruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatathumbnail" data_type="bytea" udt="pg_catalog.bytea" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataimgref" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologydatabyofferrequest" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <code>CREATE FUNCTION gettechnologydatabyofferrequest(vofferrequestuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, technologyuuid uuid, technologydataname character varying, technologydata character varying, technologydatadescription character varying, licensefee bigint, technologydatathumbnail bytea, technologydataimgref character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, useruuid uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTechnologyDataByOfferRequest';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

    	RETURN QUERY (SELECT 	technologydatauuid,
			tc.technologyuuid,
			td.technologydataname,
			technologydata,
			technologydatadescription,
			licensefee,
			technologydatathumbnail,
			technologydataimgref,
			td.createdat  at time zone 'utc',
			td.createdby,
			td.updatedat  at time zone 'utc',
			td.UpdatedBy
			FROM TechnologyData td
			join technologies tc
			on td.technologyid = tc.technologyid
			join offerrequest oq
			on oq.technologydataid = td.technologydataid
			and oq.offerrequestuuid = vOfferRequestUUID
			and td.deleted is null
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
	$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologydatabyparams" routine_type="FUNCTION" return_type="pg_catalog.json" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTechnologyDataByParams';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	 RETURN QUERY (	 with tg as (&#xD;&#xA;				select tg.tagid, tg.tagname from tags tg&#xD;&#xA;				join technologydatatags ts&#xD;&#xA;				on tg.tagid = ts.tagid&#xD;&#xA;				join technologydata td&#xD;&#xA;				on ts.technologydataid = td.technologydataid&#xD;&#xA;				join technologies tt&#xD;&#xA;				on td.technologyid = tt.technologyid&#xD;&#xA;				group by tg.tagid, tg.tagname&#xD;&#xA;			),&#xD;&#xA;			 att as (&#xD;&#xA;				select ab.attributeid, attributename from components co&#xD;&#xA;				join componentsattribute ca on&#xD;&#xA;				co.componentid = ca.componentid&#xD;&#xA;				join attributes ab on&#xD;&#xA;				ca.attributeid = ab.attributeid&#xD;&#xA;				join technologydatacomponents tc&#xD;&#xA;				on tc.componentid = co.componentid&#xD;&#xA;				group by ab.attributeid&#xD;&#xA;			),&#xD;&#xA;			comp as (&#xD;&#xA;			select co.componentuuid, co.componentid, co.componentname,&#xD;&#xA;			case when t.* is null then '[]' else array_to_json(array_agg(t.*)) end as attributes from att t&#xD;&#xA;			join componentsattribute ca on t.attributeid = ca.attributeid&#xD;&#xA;			right outer join components co on co.componentid = ca.componentid&#xD;&#xA;			group by co.componentname, co.componentid, co.componentuuid, t.*&#xD;&#xA;			),&#xD;&#xA;			techData as (&#xD;&#xA;				select td.technologydatauuid,&#xD;&#xA;					td.technologydataname,&#xD;&#xA;					tt.technologyuuid,&#xD;&#xA;					td.technologydata,&#xD;&#xA;					td.licensefee,&#xD;&#xA;					td.productcode,&#xD;&#xA;					td.technologydatadescription,&#xD;&#xA;					td.technologydatathumbnail,&#xD;&#xA;					td.technologydataimgref,&#xD;&#xA;					td.createdat at time zone 'utc',&#xD;&#xA;					td.CreatedBy,&#xD;&#xA;					td.updatedat at time zone 'utc',&#xD;&#xA;					td.UpdatedBy,&#xD;&#xA;					array_to_json(array_agg(co.*)) componentlist&#xD;&#xA;				from comp co join technologydatacomponents tc&#xD;&#xA;				on co.componentid = tc.componentid&#xD;&#xA;				join technologydata td on&#xD;&#xA;				td.technologydataid = tc.technologydataid&#xD;&#xA;				join components cm on cm.componentid = co.componentid&#xD;&#xA;				join technologies tt on&#xD;&#xA;				tt.technologyid = td.technologyid&#xD;&#xA;				where (vOwnerUUID is null OR td.createdby = vOwnerUUID)&#xD;&#xA;				and td.deleted is null&#xD;&#xA;				group by td.technologydatauuid,&#xD;&#xA;					td.technologydataname,&#xD;&#xA;					tt.technologyuuid,&#xD;&#xA;					td.technologydata,&#xD;&#xA;					td.licensefee,&#xD;&#xA;					td.productcode,&#xD;&#xA;					td.technologydatadescription,&#xD;&#xA;					td.technologydatathumbnail,&#xD;&#xA;					td.technologydataimgref,&#xD;&#xA;					td.createdat,&#xD;&#xA;					td.createdby,&#xD;&#xA;					td.updatedat,&#xD;&#xA;					td.updatedby&#xD;&#xA;			),&#xD;&#xA;			compIn as (&#xD;&#xA;				select	td.technologydataname, array_agg(componentuuid order by componentuuid asc) comp&#xD;&#xA;				from components co&#xD;&#xA;				join technologydatacomponents tc&#xD;&#xA;				on co.componentid = tc.componentid&#xD;&#xA;				join technologydata td on&#xD;&#xA;				td.technologydataid = tc.technologydataid&#xD;&#xA;				where td.deleted is null&#xD;&#xA;				group by td.technologydataname&#xD;&#xA;&#xD;&#xA;			)&#xD;&#xA;			select array_to_json(array_agg(td.*)) from techData	td&#xD;&#xA;			join compIn co on co.technologydataname = td.technologydataname&#xD;&#xA;			where (co.comp::text[] &lt;@ vComponents OR vComponents is null)&#xD;&#xA;			and (vTechnologyDataName is null OR td.technologydataname = vTechnologyDataName)&#xD;&#xA;&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologydatabyparams" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyparams" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponents" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydatabyparams" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyparams" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydatabyparams" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vowneruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatabyparams" ordinal_position="6" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydatabyparams" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="result" data_type="json" udt="pg_catalog.json" />
    <code>CREATE FUNCTION gettechnologydatabyparams(vcomponents text[], vtechnologyuuid uuid, vtechnologydataname character varying, vowneruuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(result json)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetTechnologyDataByParams';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	 RETURN QUERY (	 with tg as (
				select tg.tagid, tg.tagname from tags tg
				join technologydatatags ts
				on tg.tagid = ts.tagid
				join technologydata td
				on ts.technologydataid = td.technologydataid
				join technologies tt
				on td.technologyid = tt.technologyid
				group by tg.tagid, tg.tagname
			),
			 att as (
				select ab.attributeid, attributename from components co
				join componentsattribute ca on
				co.componentid = ca.componentid
				join attributes ab on
				ca.attributeid = ab.attributeid
				join technologydatacomponents tc
				on tc.componentid = co.componentid
				group by ab.attributeid
			),
			comp as (
			select co.componentuuid, co.componentid, co.componentname,
			case when t.* is null then '[]' else array_to_json(array_agg(t.*)) end as attributes from att t
			join componentsattribute ca on t.attributeid = ca.attributeid
			right outer join components co on co.componentid = ca.componentid
			group by co.componentname, co.componentid, co.componentuuid, t.*
			),
			techData as (
				select td.technologydatauuid,
					td.technologydataname,
					tt.technologyuuid,
					td.technologydata,
					td.licensefee,
					td.productcode,
					td.technologydatadescription,
					td.technologydatathumbnail,
					td.technologydataimgref,
					td.createdat at time zone 'utc',
					td.CreatedBy,
					td.updatedat at time zone 'utc',
					td.UpdatedBy,
					array_to_json(array_agg(co.*)) componentlist
				from comp co join technologydatacomponents tc
				on co.componentid = tc.componentid
				join technologydata td on
				td.technologydataid = tc.technologydataid
				join components cm on cm.componentid = co.componentid
				join technologies tt on
				tt.technologyid = td.technologyid
				where (vOwnerUUID is null OR td.createdby = vOwnerUUID)
				and td.deleted is null
				group by td.technologydatauuid,
					td.technologydataname,
					tt.technologyuuid,
					td.technologydata,
					td.licensefee,
					td.productcode,
					td.technologydatadescription,
					td.technologydatathumbnail,
					td.technologydataimgref,
					td.createdat,
					td.createdby,
					td.updatedat,
					td.updatedby
			),
			compIn as (
				select	td.technologydataname, array_agg(componentuuid order by componentuuid asc) comp
				from components co
				join technologydatacomponents tc
				on co.componentid = tc.componentid
				join technologydata td on
				td.technologydataid = tc.technologydataid
				where td.deleted is null
				group by td.technologydataname

			)
			select array_to_json(array_agg(td.*)) from techData	td
			join compIn co on co.technologydataname = td.technologydataname
			where (co.comp::text[] &lt;@ vComponents OR vComponents is null)
			and (vTechnologyDataName is null OR td.technologydataname = vTechnologyDataName)

		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
		$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologydataforuser" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;					vFunctionName varchar := 'GetTechnologyDataForUser';&#xD;&#xA;					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;				BEGIN&#xD;&#xA;&#xD;&#xA;				IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;				RETURN QUERY (	with revenue as (select td.technologydataname, (sum(td.licensefee*ri.amount))::bigint as revenue from transactions ts&#xD;&#xA;						join licenseorder lo&#xD;&#xA;						on ts.licenseorderid = lo.licenseorderid&#xD;&#xA;						join offerrequest oq&#xD;&#xA;						on oq.offerrequestid = ts.offerrequestid&#xD;&#xA;						join offerrequestitems ri&#xD;&#xA;						on oq.offerrequestid = ri.offerrequestid&#xD;&#xA;						join technologydata td&#xD;&#xA;						on ri.technologydataid = td.technologydataid&#xD;&#xA;						where td.createdby = vUserUUID&#xD;&#xA;						group by td.technologydataname&#xD;&#xA;					), result as (&#xD;&#xA;					select 	td.technologydatauuid,&#xD;&#xA;						td.technologydataname,&#xD;&#xA;						coalesce(rv.revenue,0)::bigint as revenue,&#xD;&#xA;						td.licensefee,&#xD;&#xA;						array_agg(co.componentname)::text[] as componentlist,&#xD;&#xA;						td.technologydatadescription&#xD;&#xA;					from technologydata td&#xD;&#xA;					left outer join revenue rv on td.technologydataname = rv.technologydataname&#xD;&#xA;					join technologydatacomponents tc&#xD;&#xA;					on tc.technologydataid = td.technologydataid&#xD;&#xA;					join components co&#xD;&#xA;					on tc.componentid = co.componentid&#xD;&#xA;					where td.createdby = vUserUUID&#xD;&#xA;					and td.deleted is null&#xD;&#xA;					group by td.technologydatauuid, td.technologydataname, td.licensefee, rv.revenue, td.technologydatadescription)&#xD;&#xA;					select  r.technologydatauuid,&#xD;&#xA;						r.technologydataname,&#xD;&#xA;						sum(r.revenue)::bigint as revenue,&#xD;&#xA;						r.licensefee::bigint,&#xD;&#xA;						r.componentlist,&#xD;&#xA;						r.technologydatadescription&#xD;&#xA;					from result r&#xD;&#xA;					group by r.technologydatauuid,&#xD;&#xA;						r.technologydataname,&#xD;&#xA;						r.licensefee,&#xD;&#xA;						r.componentlist,&#xD;&#xA;						r.technologydatadescription&#xD;&#xA;					);&#xD;&#xA;&#xD;&#xA;				ELSE&#xD;&#xA;					 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;					 RETURN;&#xD;&#xA;				END IF;&#xD;&#xA;&#xD;&#xA;				END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologydataforuser" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydataforuser" ordinal_position="3" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydataforuser" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydataforuser" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettechnologydataforuser" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettechnologydataforuser" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentlist" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydataforuser" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologydataforuser" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION gettechnologydataforuser(vuseruuid uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, technologydataname character varying, revenue bigint, licensefee bigint, componentlist text[], technologydatadescription character varying)
    LANGUAGE plpgsql
    AS $$
				DECLARE
					vFunctionName varchar := 'GetTechnologyDataForUser';
					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

				BEGIN

				IF(vIsAllowed) THEN

				RETURN QUERY (	with revenue as (select td.technologydataname, (sum(td.licensefee*ri.amount))::bigint as revenue from transactions ts
						join licenseorder lo
						on ts.licenseorderid = lo.licenseorderid
						join offerrequest oq
						on oq.offerrequestid = ts.offerrequestid
						join offerrequestitems ri
						on oq.offerrequestid = ri.offerrequestid
						join technologydata td
						on ri.technologydataid = td.technologydataid
						where td.createdby = vUserUUID
						group by td.technologydataname
					), result as (
					select 	td.technologydatauuid,
						td.technologydataname,
						coalesce(rv.revenue,0)::bigint as revenue,
						td.licensefee,
						array_agg(co.componentname)::text[] as componentlist,
						td.technologydatadescription
					from technologydata td
					left outer join revenue rv on td.technologydataname = rv.technologydataname
					join technologydatacomponents tc
					on tc.technologydataid = td.technologydataid
					join components co
					on tc.componentid = co.componentid
					where td.createdby = vUserUUID
					and td.deleted is null
					group by td.technologydatauuid, td.technologydataname, td.licensefee, rv.revenue, td.technologydatadescription)
					select  r.technologydatauuid,
						r.technologydataname,
						sum(r.revenue)::bigint as revenue,
						r.licensefee::bigint,
						r.componentlist,
						r.technologydatadescription
					from result r
					group by r.technologydatauuid,
						r.technologydataname,
						r.licensefee,
						r.componentlist,
						r.technologydatadescription
					);

				ELSE
					 RAISE EXCEPTION '%', 'Insufficiency rigths';
					 RETURN;
				END IF;

				END;
			$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologydatahistory" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetTechnologyDataHistory'; &#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;				vTechnologyDataName text := 'Total';&#xD;&#xA;&#xD;&#xA;			BEGIN &#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			RETURN QUERY (select r.year, r.month, r.day, r.hour, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from public.getrevenue(&#xD;&#xA;					    vFrom,&#xD;&#xA;					    vTo,&#xD;&#xA;					    null,&#xD;&#xA;					    null,&#xD;&#xA;					    vRoles) r&#xD;&#xA;					left outer join technologydata td&#xD;&#xA;					on td.technologydatauuid = r.technologydatauuid&#xD;&#xA;					where r.year &lt;&gt; '0' and r.month &lt;&gt; '0' and r.day &lt;&gt; '0' and r.hour &lt;&gt; '0'&#xD;&#xA;					and r.technologydatauuid &lt;&gt; uuid_nil()	&#xD;&#xA;				);&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologydatahistory" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="day" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettechnologydatahistory" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="month" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettechnologydatahistory" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="year" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettechnologydatahistory" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettechnologydatahistory" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="amount" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettechnologydatahistory" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfrom" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologydatahistory" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vto" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologydatahistory" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydatahistory" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydatahistory" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettechnologydatahistory" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="hour" data_type="text" udt="pg_catalog.text" />
    <code>CREATE FUNCTION gettechnologydatahistory(vfrom timestamp with time zone, vto timestamp with time zone, vcreatedby uuid, vroles text[]) RETURNS TABLE(year text, month text, day text, hour text, technologydataname text, amount integer, revenue bigint)
    LANGUAGE plpgsql
    AS $$

			DECLARE
				vFunctionName varchar := 'GetTechnologyDataHistory'; 
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
				vTechnologyDataName text := 'Total';

			BEGIN 

			IF(vIsAllowed) THEN

			RETURN QUERY (select r.year, r.month, r.day, r.hour, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from public.getrevenue(
					    vFrom,
					    vTo,
					    null,
					    null,
					    vRoles) r
					left outer join technologydata td
					on td.technologydatauuid = r.technologydatauuid
					where r.year &lt;&gt; '0' and r.month &lt;&gt; '0' and r.day &lt;&gt; '0' and r.hour &lt;&gt; '0'
					and r.technologydatauuid &lt;&gt; uuid_nil()	
				);
			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
		$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologydataownerbyid" routine_type="FUNCTION" return_type="pg_catalog.varchar" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTechnologyDataOwnerById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (	SELECT 	td.createdby&#xD;&#xA;				FROM TechnologyData td&#xD;&#xA;				where technologydatauuid = vtechnologydatauuid&#xD;&#xA;				and td.deleted is null&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologydataownerbyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydataownerbyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologydataownerbyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologydataownerbyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION gettechnologydataownerbyid(vtechnologydatauuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(createdby character varying)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTechnologyDataOwnerById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (	SELECT 	td.createdby
				FROM TechnologyData td
				where technologydatauuid = vtechnologydatauuid
				and td.deleted is null
		);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettechnologyforofferrequest" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTechnologyForOfferRequest';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select 	tc.technologyuuid,&#xD;&#xA;				tc.technologyName,&#xD;&#xA;				tc.technologyDescription,&#xD;&#xA;				tc.createdat at time zone 'utc',&#xD;&#xA;				td.createdby,&#xD;&#xA;				tc.updatedat at time zone 'utc',&#xD;&#xA;				td.updatedby&#xD;&#xA;			from technologydata td&#xD;&#xA;			join offerrequest oq&#xD;&#xA;			on oq.technologydataid = td.technologydataid&#xD;&#xA;			join technologies tc&#xD;&#xA;			on tc.technologyid = td.technologyid&#xD;&#xA;			where oq.offerrequestuuid = vOfferRequestUUID&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettechnologyforofferrequest" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettechnologyforofferrequest" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION gettechnologyforofferrequest(vofferrequestuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(technologyuuid uuid, technologyname character varying, technologydescription character varying, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTechnologyForOfferRequest';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select 	tc.technologyuuid,
				tc.technologyName,
				tc.technologyDescription,
				tc.createdat at time zone 'utc',
				td.createdby,
				tc.updatedat at time zone 'utc',
				td.updatedby
			from technologydata td
			join offerrequest oq
			on oq.technologydataid = td.technologydataid
			join technologies tc
			on tc.technologyid = td.technologyid
			where oq.offerrequestuuid = vOfferRequestUUID
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettopcomponents" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTopComponents';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;	RETURN QUERY (&#xD;&#xA;		with activatedLincenses as(&#xD;&#xA;				select co.componentname, activatedat from licenseorder lo&#xD;&#xA;				join offer of on lo.offerid = of.offerid&#xD;&#xA;				join paymentinvoice pi on&#xD;&#xA;				of.paymentinvoiceid = pi.paymentinvoiceid&#xD;&#xA;				join offerrequest oq on&#xD;&#xA;				pi.offerrequestid = oq.offerrequestid&#xD;&#xA;				join offerrequestitems ri on&#xD;&#xA;				oq.offerrequestid = ri.offerrequestid&#xD;&#xA;				join technologydata td on&#xD;&#xA;				ri.technologydataid = td.technologydataid&#xD;&#xA;				join technologydatacomponents tc on&#xD;&#xA;				tc.technologydataid = td.technologydataid&#xD;&#xA;				join components co on&#xD;&#xA;				co.componentid = tc.componentid				&#xD;&#xA;			),&#xD;&#xA;		rankTable as (&#xD;&#xA;		select a.componentname, count(a.componentname) as rank from activatedLincenses a &#xD;&#xA;		where activatedat between vFrom and vTo		&#xD;&#xA;		group by a.componentname)&#xD;&#xA;		select r.componentname::varchar(250), rank::integer from rankTable r&#xD;&#xA;		order by rank desc limit vLimit);&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettopcomponents" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettopcomponents" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettopcomponents" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vlimit" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettopcomponents" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vto" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettopcomponents" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfrom" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettopcomponents" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="amount" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettopcomponents" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION gettopcomponents(vfrom timestamp with time zone, vto timestamp with time zone, vlimit integer, vuseruuid uuid, vroles text[]) RETURNS TABLE(componentname character varying, amount integer)
    LANGUAGE plpgsql
    AS $$

	DECLARE
		vFunctionName varchar := 'GetTopComponents';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
	RETURN QUERY (
		with activatedLincenses as(
				select co.componentname, activatedat from licenseorder lo
				join offer of on lo.offerid = of.offerid
				join paymentinvoice pi on
				of.paymentinvoiceid = pi.paymentinvoiceid
				join offerrequest oq on
				pi.offerrequestid = oq.offerrequestid
				join offerrequestitems ri on
				oq.offerrequestid = ri.offerrequestid
				join technologydata td on
				ri.technologydataid = td.technologydataid
				join technologydatacomponents tc on
				tc.technologydataid = td.technologydataid
				join components co on
				co.componentid = tc.componentid				
			),
		rankTable as (
		select a.componentname, count(a.componentname) as rank from activatedLincenses a 
		where activatedat between vFrom and vTo		
		group by a.componentname)
		select r.componentname::varchar(250), rank::integer from rankTable r
		order by rank desc limit vLimit);

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
 $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettoptechnologydata" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetTopTechnologyData'; &#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));		&#xD;&#xA;&#xD;&#xA;			BEGIN &#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			RETURN QUERY (select r.year, r.month, r.day, r.hour, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from &#xD;&#xA;					getrevenue(vFrom,&#xD;&#xA;						   vTo,&#xD;&#xA;						   null,&#xD;&#xA;						   vCreatedBy,&#xD;&#xA;						   vRoles) r&#xD;&#xA;						   join technologydata td&#xD;&#xA;						   on td.technologydatauuid = r.technologydatauuid&#xD;&#xA;							where r.year = '0'&#xD;&#xA;							and r.month = '0'&#xD;&#xA;							and r.day = '0'&#xD;&#xA;							and r.hour = '0' &#xD;&#xA;							and td.technologydataname &lt;&gt; 'Total'&#xD;&#xA;							and td.deleted is null		&#xD;&#xA;						order by r.amount desc, td.technologydataname&#xD;&#xA;						limit vLimit		&#xD;&#xA;				);&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettoptechnologydata" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettoptechnologydata" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettoptechnologydata" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vlimit" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettoptechnologydata" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfrom" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettoptechnologydata" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettoptechnologydata" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vto" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettoptechnologydata" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="amount" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettoptechnologydata" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettoptechnologydata" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="hour" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettoptechnologydata" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="day" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettoptechnologydata" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="month" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettoptechnologydata" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="year" data_type="text" udt="pg_catalog.text" />
    <code>CREATE FUNCTION gettoptechnologydata(vfrom timestamp with time zone, vto timestamp with time zone, vlimit integer, vcreatedby uuid, vroles text[]) RETURNS TABLE(year text, month text, day text, hour text, technologydataname text, amount integer, revenue bigint)
    LANGUAGE plpgsql
    AS $$

			DECLARE
				vFunctionName varchar := 'GetTopTechnologyData'; 
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));		

			BEGIN 

			IF(vIsAllowed) THEN

			RETURN QUERY (select r.year, r.month, r.day, r.hour, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from 
					getrevenue(vFrom,
						   vTo,
						   null,
						   vCreatedBy,
						   vRoles) r
						   join technologydata td
						   on td.technologydatauuid = r.technologydatauuid
							where r.year = '0'
							and r.month = '0'
							and r.day = '0'
							and r.hour = '0' 
							and td.technologydataname &lt;&gt; 'Total'
							and td.deleted is null		
						order by r.amount desc, td.technologydataname
						limit vLimit		
				);
			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
		$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettotalrevenue" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetTotalRevenue'; &#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;				vTechnologyDataUUID uuid := (select uuid_nil())::uuid;&#xD;&#xA;&#xD;&#xA;			BEGIN &#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			RETURN QUERY (select  to_date(r.year || '-' || r.month || '-' || r.day, 'YYYY-MM-DD') as date, r.hour::text, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from public.getrevenue(&#xD;&#xA;					    vFrom,&#xD;&#xA;					    vTo,&#xD;&#xA;					    vTechnologyDataUUID,&#xD;&#xA;					    vCreatedBy,&#xD;&#xA;					    vRoles) r&#xD;&#xA;					    left outer join technologydata td on&#xD;&#xA;					    td.technologydatauuid = r.technologydatauuid&#xD;&#xA;					    where r.year &lt;&gt; '0'&#xD;&#xA;					    and r.month &lt;&gt; '0'&#xD;&#xA;					    and r.day &lt;&gt; '0'&#xD;&#xA;					    and case when (vDetail = 'hour') then r.hour &lt;&gt; '0' else r.hour = '0' end	 			    &#xD;&#xA;					    order by r.year asc, r.month asc, r.day asc&#xD;&#xA;				);&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettotalrevenue" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfrom" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettotalrevenue" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vto" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettotalrevenue" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vdetail" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettotalrevenue" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettotalrevenue" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettotalrevenue" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="date" data_type="date" udt="pg_catalog.date" />
    <param parent="public.gettotalrevenue" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="hour" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettotalrevenue" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettotalrevenue" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="amount" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettotalrevenue" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <code>CREATE FUNCTION gettotalrevenue(vfrom timestamp with time zone, vto timestamp with time zone, vdetail text, vcreatedby uuid, vroles text[]) RETURNS TABLE(date date, hour text, technologydataname text, amount integer, revenue bigint)
    LANGUAGE plpgsql
    AS $$

			DECLARE
				vFunctionName varchar := 'GetTotalRevenue'; 
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
				vTechnologyDataUUID uuid := (select uuid_nil())::uuid;

			BEGIN 

			IF(vIsAllowed) THEN

			RETURN QUERY (select  to_date(r.year || '-' || r.month || '-' || r.day, 'YYYY-MM-DD') as date, r.hour::text, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from public.getrevenue(
					    vFrom,
					    vTo,
					    vTechnologyDataUUID,
					    vCreatedBy,
					    vRoles) r
					    left outer join technologydata td on
					    td.technologydatauuid = r.technologydatauuid
					    where r.year &lt;&gt; '0'
					    and r.month &lt;&gt; '0'
					    and r.day &lt;&gt; '0'
					    and case when (vDetail = 'hour') then r.hour &lt;&gt; '0' else r.hour = '0' end	 			    
					    order by r.year asc, r.month asc, r.day asc
				);
			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
		$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettotaluserrevenue" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;				vFunctionName varchar := 'GetTotalUserRevenue'; &#xD;&#xA;				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;				vTechnologyDataUUID uuid := (select uuid_nil());&#xD;&#xA;			BEGIN &#xD;&#xA;&#xD;&#xA;			IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;			RETURN QUERY (select  to_date(r.year || '-' || r.month || '-' || r.day, 'YYYY-MM-DD') as date, r.hour::text, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from public.getrevenue(&#xD;&#xA;					    vFrom,&#xD;&#xA;					    vTo,&#xD;&#xA;					    vTechnologyDataUUID,&#xD;&#xA;					    vCreatedBy,&#xD;&#xA;					    vRoles) r&#xD;&#xA;					    left outer join technologydata td&#xD;&#xA;					    on td.technologydatauuid = r.technologydatauuid&#xD;&#xA;					    where r.year = '0'&#xD;&#xA;					    and r.month = '0'&#xD;&#xA;					    and r.day = '0'&#xD;&#xA;					    and r.hour = '0'&#xD;&#xA;					    and r.technologydatauuid = vTechnologyDataUUID			    &#xD;&#xA;					    order by r.year asc, r.month asc, r.day asc&#xD;&#xA;				);&#xD;&#xA;			ELSE&#xD;&#xA;				 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;				 RETURN;&#xD;&#xA;			END IF;&#xD;&#xA;&#xD;&#xA;			END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettotaluserrevenue" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="revenue" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.gettotaluserrevenue" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="amount" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.gettotaluserrevenue" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettotaluserrevenue" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="hour" data_type="text" udt="pg_catalog.text" />
    <param parent="public.gettotaluserrevenue" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="date" data_type="date" udt="pg_catalog.date" />
    <param parent="public.gettotaluserrevenue" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettotaluserrevenue" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettotaluserrevenue" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vto" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettotaluserrevenue" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfrom" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <code>CREATE FUNCTION gettotaluserrevenue(vfrom timestamp with time zone, vto timestamp with time zone, vcreatedby uuid, vroles text[]) RETURNS TABLE(date date, hour text, technologydataname text, amount integer, revenue bigint)
    LANGUAGE plpgsql
    AS $$

			DECLARE
				vFunctionName varchar := 'GetTotalUserRevenue'; 
				vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
				vTechnologyDataUUID uuid := (select uuid_nil());
			BEGIN 

			IF(vIsAllowed) THEN

			RETURN QUERY (select  to_date(r.year || '-' || r.month || '-' || r.day, 'YYYY-MM-DD') as date, r.hour::text, coalesce(td.technologydataname,'Total')::text as technologydataname, r.amount, r.revenue from public.getrevenue(
					    vFrom,
					    vTo,
					    vTechnologyDataUUID,
					    vCreatedBy,
					    vRoles) r
					    left outer join technologydata td
					    on td.technologydatauuid = r.technologydatauuid
					    where r.year = '0'
					    and r.month = '0'
					    and r.day = '0'
					    and r.hour = '0'
					    and r.technologydatauuid = vTechnologyDataUUID			    
					    order by r.year asc, r.month asc, r.day asc
				);
			ELSE
				 RAISE EXCEPTION '%', 'Insufficiency rigths';
				 RETURN;
			END IF;

			END;
		$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettransactionbyid" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTransactionById';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select	ts.transactionuuid,&#xD;&#xA;				ts.buyerid,&#xD;&#xA;				ofr.offeruuid,&#xD;&#xA;				oq.offerrequestuuid,&#xD;&#xA;				py.paymentuuid,&#xD;&#xA;				pi.paymentinvoiceuuid,&#xD;&#xA;				li.licenseorderuuid,&#xD;&#xA;				ts.createdat at time zone 'utc',&#xD;&#xA;				ts.createdby,&#xD;&#xA;				ts.updatedat at time zone 'utc',&#xD;&#xA;				ts.updatedby&#xD;&#xA;			from transactions ts&#xD;&#xA;			join offerrequest oq&#xD;&#xA;			on ts.offerrequestid = oq.offerrequestid&#xD;&#xA;			and ts.transactionuuid = vTransactionUUID&#xD;&#xA;			left outer join offer ofr on ofr.offerid = ts.offerid&#xD;&#xA;			left outer join payment py on py.paymentid = ts.paymentid&#xD;&#xA;			left outer join paymentinvoice pi&#xD;&#xA;			on pi.paymentinvoiceid = ts.paymentinvoiceid&#xD;&#xA;			left outer join licenseorder li&#xD;&#xA;			on li.licenseorderid = ts.licenseorderid&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettransactionbyid" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtransactionuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettransactionbyid" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="transactionuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="buyer" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offerrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licenseorderuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettransactionbyid" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyid" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettransactionbyid" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION gettransactionbyid(vtransactionuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(transactionuuid uuid, buyer uuid, offeruuid uuid, offerrequestuuid uuid, paymentuuid uuid, paymentinvoiceid uuid, licenseorderuuid uuid, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTransactionById';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select	ts.transactionuuid,
				ts.buyerid,
				ofr.offeruuid,
				oq.offerrequestuuid,
				py.paymentuuid,
				pi.paymentinvoiceuuid,
				li.licenseorderuuid,
				ts.createdat at time zone 'utc',
				ts.createdby,
				ts.updatedat at time zone 'utc',
				ts.updatedby
			from transactions ts
			join offerrequest oq
			on ts.offerrequestid = oq.offerrequestid
			and ts.transactionuuid = vTransactionUUID
			left outer join offer ofr on ofr.offerid = ts.offerid
			left outer join payment py on py.paymentid = ts.paymentid
			left outer join paymentinvoice pi
			on pi.paymentinvoiceid = ts.paymentinvoiceid
			left outer join licenseorder li
			on li.licenseorderid = ts.licenseorderid
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.gettransactionbyofferrequest" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE&#xD;&#xA;		vFunctionName varchar := 'GetTransactionByOfferRequest';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;	RETURN QUERY (select	ts.transactionuuid,&#xD;&#xA;				ts.buyerid,&#xD;&#xA;				ofr.offeruuid,&#xD;&#xA;				oq.offerrequestuuid,&#xD;&#xA;				py.paymentuuid,&#xD;&#xA;				pi.paymentinvoiceuuid,&#xD;&#xA;				li.licenseorderuuid,&#xD;&#xA;				ts.createdat at time zone 'utc',&#xD;&#xA;				ts.createdby,&#xD;&#xA;				ts.updatedat at time zone 'utc',&#xD;&#xA;				ts.updatedby&#xD;&#xA;			from transactions ts&#xD;&#xA;			join offerrequest oq&#xD;&#xA;			on ts.offerrequestid = oq.offerrequestid&#xD;&#xA;			and oq.offerrequestuuid = vOfferRequestUUID&#xD;&#xA;			left outer join offer ofr on ofr.offerid = ts.offerid&#xD;&#xA;			left outer join payment py on py.paymentid = ts.paymentid&#xD;&#xA;			left outer join paymentinvoice pi&#xD;&#xA;			on pi.paymentinvoiceid = ts.paymentinvoiceid&#xD;&#xA;			left outer join licenseorder li&#xD;&#xA;			on li.licenseorderid = ts.licenseorderid&#xD;&#xA;		);&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.gettransactionbyofferrequest" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licenseorderuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offerrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="buyer" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="4" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="transactionuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.gettransactionbyofferrequest" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION gettransactionbyofferrequest(vofferrequestuuid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(transactionuuid uuid, buyer uuid, offeruuid uuid, offerrequestuuid uuid, paymentuuid uuid, paymentinvoiceid uuid, licenseorderuuid uuid, createdat timestamp with time zone, createdby uuid, updatedat timestamp with time zone, updatedby uuid)
    LANGUAGE plpgsql
    AS $$
	DECLARE
		vFunctionName varchar := 'GetTransactionByOfferRequest';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

	RETURN QUERY (select	ts.transactionuuid,
				ts.buyerid,
				ofr.offeruuid,
				oq.offerrequestuuid,
				py.paymentuuid,
				pi.paymentinvoiceuuid,
				li.licenseorderuuid,
				ts.createdat at time zone 'utc',
				ts.createdby,
				ts.updatedat at time zone 'utc',
				ts.updatedby
			from transactions ts
			join offerrequest oq
			on ts.offerrequestid = oq.offerrequestid
			and oq.offerrequestuuid = vOfferRequestUUID
			left outer join offer ofr on ofr.offerid = ts.offerid
			left outer join payment py on py.paymentid = ts.paymentid
			left outer join paymentinvoice pi
			on pi.paymentinvoiceid = ts.paymentinvoiceid
			left outer join licenseorder li
			on li.licenseorderid = ts.licenseorderid
		);
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.setcomponent" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vAttributeName text;&#xD;&#xA;        	vTechName text;&#xD;&#xA;		vCompID integer;&#xD;&#xA;		vCompUUID uuid;&#xD;&#xA;		vCompParentUUID uuid;&#xD;&#xA;		vFunctionName varchar := 'SetComponent';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;		-- Is none ParentComponent -&gt; set Root as Parent&#xD;&#xA;		if (vcomponentparentname is null) then&#xD;&#xA;			vcomponentparentname := 'Root';&#xD;&#xA;		end if;&#xD;&#xA;		vCompParentUUID := (select case when (vComponentParentName = 'Root' and not exists (select 1 from components where componentName = 'Root')) then uuid_generate_v4() else componentuuid end from components where componentname = vComponentParentName);&#xD;&#xA;&#xD;&#xA;		-- Proof if all technologies are avaiable&#xD;&#xA;		if(vTechnologyList is not null OR array_length(vTechnologyList,1)&gt;0) then&#xD;&#xA;			FOREACH vTechName in array vTechnologyList&#xD;&#xA;			LOOP&#xD;&#xA;				 if not exists (select technologyid from technologies where technologyname = vTechName) then&#xD;&#xA;				 raise exception using&#xD;&#xA;				 errcode = 'invalid_parameter_value',&#xD;&#xA;				 message = 'There is no technology with TechnologyName: ' || vTechName;&#xD;&#xA;				 end if;&#xD;&#xA;			END LOOP;&#xD;&#xA;&#xD;&#xA;			-- Create new Component&#xD;&#xA;			perform public.createcomponent(vCompParentUUID,vComponentName, vComponentdescription, vCreatedby, vRoles);&#xD;&#xA;			vCompID := (select currval('ComponentID'));&#xD;&#xA;			vCompUUID := (select componentuuid from components where componentID = vCompID);&#xD;&#xA;&#xD;&#xA;			-- Create relation from Components to TechnologyData&#xD;&#xA;			perform public.CreateComponentsTechnologies(vCompUUID, vTechnologyList, vRoles);&#xD;&#xA;		end if;&#xD;&#xA;&#xD;&#xA;		-- Proof if all Attributes are avaiable&#xD;&#xA;		if(vAttributeList is not null OR array_length(vAttributeList,1)&gt;0) then&#xD;&#xA;			FOREACH vAttributeName in array vAttributeList&#xD;&#xA;			LOOP&#xD;&#xA;				 if not exists (select attributeid from public.attributes where attributename = vAttributeName) then&#xD;&#xA;					perform public.createattribute(vAttributeName,vCreatedBy, vRoles);&#xD;&#xA;				 end if;&#xD;&#xA;			END LOOP;&#xD;&#xA;&#xD;&#xA;			-- Create relation from Components to Attribute&#xD;&#xA;			perform public.CreateComponentsAttribute(vCompUUID, vAttributeList, vRoles);&#xD;&#xA;		end if;&#xD;&#xA;&#xD;&#xA;		-- Begin Log if success&#xD;&#xA;		perform public.createlog(0,'Set Component sucessfully','SetComponent',&#xD;&#xA;					'ComponentID: ' || cast(vCompID as varchar) || ', componentname: '&#xD;&#xA;					|| vComponentName || ', componentdescription: ' || vComponentDescription&#xD;&#xA;					|| ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;        ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return UserID&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;			select 	co.ComponentUUID,&#xD;&#xA;				co.ComponentName,&#xD;&#xA;				cs.ComponentName as componentParentName,&#xD;&#xA;				cs.ComponentUUID as componentParentUUID,&#xD;&#xA;				co.ComponentDescription,&#xD;&#xA;				array_agg(att.attributeuuid),&#xD;&#xA;				array_agg(tc.technologyuuid),&#xD;&#xA;				co.CreatedAt at time zone 'utc',&#xD;&#xA;				vCreatedBy as CreatedBy&#xD;&#xA;			from components co&#xD;&#xA;			left outer join componentsattribute ca&#xD;&#xA;			on co.componentid = ca.componentid&#xD;&#xA;			left outer join attributes att&#xD;&#xA;			on ca.attributeid = att.attributeid&#xD;&#xA;			join componentstechnologies ct&#xD;&#xA;			on co.componentid = ct.componentid&#xD;&#xA;			join technologies tc&#xD;&#xA;			on tc.technologyid = ct.technologyid&#xD;&#xA;			left outer join components cs&#xD;&#xA;			on co.componentparentid = cs.componentid&#xD;&#xA;			where co.componentid = vCompID&#xD;&#xA;			group by co.ComponentUUID, co.ComponentName, cs.ComponentName,&#xD;&#xA;				cs.ComponentUUID, co.ComponentDescription, co.createdat&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'SetComponent',&#xD;&#xA;                                'ComponentID: ' || cast(vCompID as varchar) || ', componentname: '&#xD;&#xA;                                || vComponentName || ', componentdescription: ' || vComponentDescription&#xD;&#xA;                                || ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetComponent';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.setcomponent" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vattributelist" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.setcomponent" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setcomponent" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentparentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setcomponent" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setcomponent" ordinal_position="16" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setcomponent" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.setcomponent" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologylist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.setcomponent" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="attributelist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.setcomponent" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentdescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setcomponent" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setcomponent" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentparentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setcomponent" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setcomponent" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setcomponent" ordinal_position="7" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.setcomponent" ordinal_position="6" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setcomponent" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologylist" data_type="ARRAY" udt="pg_catalog._text" />
    <code>CREATE FUNCTION setcomponent(vcomponentname character varying, vcomponentparentname character varying, vcomponentdescription character varying, vattributelist text[], vtechnologylist text[], vcreatedby uuid, vroles text[]) RETURNS TABLE(componentuuid uuid, componentname character varying, componentparentname character varying, componentparentuuid uuid, componentdescription character varying, attributelist uuid[], technologylist uuid[], createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vAttributeName text;
        	vTechName text;
		vCompID integer;
		vCompUUID uuid;
		vCompParentUUID uuid;
		vFunctionName varchar := 'SetComponent';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN

		-- Is none ParentComponent -&gt; set Root as Parent
		if (vcomponentparentname is null) then
			vcomponentparentname := 'Root';
		end if;
		vCompParentUUID := (select case when (vComponentParentName = 'Root' and not exists (select 1 from components where componentName = 'Root')) then uuid_generate_v4() else componentuuid end from components where componentname = vComponentParentName);

		-- Proof if all technologies are avaiable
		if(vTechnologyList is not null OR array_length(vTechnologyList,1)&gt;0) then
			FOREACH vTechName in array vTechnologyList
			LOOP
				 if not exists (select technologyid from technologies where technologyname = vTechName) then
				 raise exception using
				 errcode = 'invalid_parameter_value',
				 message = 'There is no technology with TechnologyName: ' || vTechName;
				 end if;
			END LOOP;

			-- Create new Component
			perform public.createcomponent(vCompParentUUID,vComponentName, vComponentdescription, vCreatedby, vRoles);
			vCompID := (select currval('ComponentID'));
			vCompUUID := (select componentuuid from components where componentID = vCompID);

			-- Create relation from Components to TechnologyData
			perform public.CreateComponentsTechnologies(vCompUUID, vTechnologyList, vRoles);
		end if;

		-- Proof if all Attributes are avaiable
		if(vAttributeList is not null OR array_length(vAttributeList,1)&gt;0) then
			FOREACH vAttributeName in array vAttributeList
			LOOP
				 if not exists (select attributeid from public.attributes where attributename = vAttributeName) then
					perform public.createattribute(vAttributeName,vCreatedBy, vRoles);
				 end if;
			END LOOP;

			-- Create relation from Components to Attribute
			perform public.CreateComponentsAttribute(vCompUUID, vAttributeList, vRoles);
		end if;

		-- Begin Log if success
		perform public.createlog(0,'Set Component sucessfully','SetComponent',
					'ComponentID: ' || cast(vCompID as varchar) || ', componentname: '
					|| vComponentName || ', componentdescription: ' || vComponentDescription
					|| ', CreatedBy: ' || cast(vCreatedBy as varchar));
        ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- End Log if success
        -- Return UserID
        RETURN QUERY (
			select 	co.ComponentUUID,
				co.ComponentName,
				cs.ComponentName as componentParentName,
				cs.ComponentUUID as componentParentUUID,
				co.ComponentDescription,
				array_agg(att.attributeuuid),
				array_agg(tc.technologyuuid),
				co.CreatedAt at time zone 'utc',
				vCreatedBy as CreatedBy
			from components co
			left outer join componentsattribute ca
			on co.componentid = ca.componentid
			left outer join attributes att
			on ca.attributeid = att.attributeid
			join componentstechnologies ct
			on co.componentid = ct.componentid
			join technologies tc
			on tc.technologyid = ct.technologyid
			left outer join components cs
			on co.componentparentid = cs.componentid
			where co.componentid = vCompID
			group by co.ComponentUUID, co.ComponentName, cs.ComponentName,
				cs.ComponentUUID, co.ComponentDescription, co.createdat
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'SetComponent',
                                'ComponentID: ' || cast(vCompID as varchar) || ', componentname: '
                                || vComponentName || ', componentdescription: ' || vComponentDescription
                                || ', CreatedBy: ' || cast(vCreatedBy as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetComponent';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.setpayment" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE 	vPaymentID integer;&#xD;&#xA;		vPaymentUUID uuid := (select uuid_generate_v4());&#xD;&#xA;		vPaymentInvoiceID integer := (select PaymentInvoiceID from transactions where transactionuuid = vTransactionUUID);&#xD;&#xA;		vPayDate timestamp without time zone := null;&#xD;&#xA;		vTransactionID integer := (select transactionid from transactions where transactionuuid = vtransactionuuid);&#xD;&#xA;		vFunctionName varchar := 'SetPayment';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;		IF exists (select extinvoiceid from payment where extinvoiceid = vExtInvoiceID) THEN&#xD;&#xA;		-- TEST&#xD;&#xA;		vPaymentID := (select paymentid from payment where ExtInvoiceID = vExtInvoiceID);&#xD;&#xA;		perform public.createlog(0,'START Updated Payment sucessfully', 'SetPayment',&#xD;&#xA;                                'PaymentID: ' || cast(vPaymentID as varchar)&#xD;&#xA;				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)&#xD;&#xA;				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')&#xD;&#xA;				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')&#xD;&#xA;				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')&#xD;&#xA;				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vuseruuid as varchar));&#xD;&#xA;		-- update&#xD;&#xA;		--Proof if ConfidenceState is Pending and PayDate is null&#xD;&#xA;		IF ((LOWER(vConfidenceState) = LOWER('Pending') or LOWER(vConfidenceState) = LOWER('building'))&#xD;&#xA;			and (select 1 from payment where extinvoiceid = vExtInvoiceID and PayDate is null)::integer=1) THEN&#xD;&#xA;			vPayDate := now();&#xD;&#xA;		ELSE vPayDate := (select paydate from payment where extinvoiceid = vExtInvoiceID);&#xD;&#xA;		END IF;&#xD;&#xA;		update payment set ConfidenceState = vConfidenceState, Depth = vDepth, bitcointransaction = vbitcointransaction,&#xD;&#xA;		PayDate = vPayDate, updatedat = now(), updatedby = vuseruuid&#xD;&#xA;		where ExtInvoiceID = vExtInvoiceID;&#xD;&#xA;&#xD;&#xA;		vPaymentID := (select paymentid from payment where ExtInvoiceID = vExtInvoiceID);&#xD;&#xA;		-- Begin Log if success&#xD;&#xA;		perform public.createlog(0,'END Updated Payment sucessfully', 'SetPayment',&#xD;&#xA;                                'PaymentID: ' || cast(vPaymentID as varchar)&#xD;&#xA;				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)&#xD;&#xA;				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')&#xD;&#xA;				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')&#xD;&#xA;				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')&#xD;&#xA;				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vuseruuid as varchar));&#xD;&#xA;&#xD;&#xA;		-- End Log if success&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		-- Insert&#xD;&#xA;		 vPaymentID := (select nextval('PaymentID'));&#xD;&#xA;		IF (LOWER(vConfidenceState) = LOWER('Pending') or LOWER(vConfidenceState) = LOWER('building')) THEN&#xD;&#xA;			vPayDate := now();&#xD;&#xA;		ELSE 	vPayDate := null;&#xD;&#xA;		END IF;&#xD;&#xA;		INSERT INTO payment(paymentid, paymentuuid, paymentinvoiceid, paydate, bitcointransaction,&#xD;&#xA;				    createdby, depth, confidencestate, extinvoiceid,&#xD;&#xA;				    createdat)&#xD;&#xA;			VALUES (vPaymentID, vPaymentUUID, vPaymentInvoiceID, vPayDate, vbitcointransaction,&#xD;&#xA;			vuseruuid, vDepth, vConfidenceState, vExtInvoiceID, now());&#xD;&#xA;&#xD;&#xA;			-- Update Transactions table&#xD;&#xA;		UPDATE Transactions SET PaymentID = vPaymentID, UpdatedAt = now(), UpdatedBy = vuseruuid&#xD;&#xA;		WHERE TransactionID = vTransactionID;&#xD;&#xA;&#xD;&#xA;		-- Begin Log if success&#xD;&#xA;		perform public.createlog(0,'Created Payment sucessfully', 'SetPayment',&#xD;&#xA;                                'PaymentID: ' || cast(vPaymentID as varchar)&#xD;&#xA;				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)&#xD;&#xA;				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')&#xD;&#xA;				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')&#xD;&#xA;				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')&#xD;&#xA;				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vuseruuid as varchar));&#xD;&#xA;&#xD;&#xA;		-- End Log if success&#xD;&#xA;&#xD;&#xA;		END IF;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;&#xD;&#xA;        -- Return PaymentID&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;			select 	PaymentUUID,&#xD;&#xA;				pi.PaymentInvoiceUUID,&#xD;&#xA;				paydate at time zone 'utc',&#xD;&#xA;				bitcointransaction,&#xD;&#xA;				confidencestate,&#xD;&#xA;				depth,&#xD;&#xA;				extinvoiceid,&#xD;&#xA;				py.CreatedBy as CreatedBy,&#xD;&#xA;				py.createdat at time zone 'utc',&#xD;&#xA;				py.UpdatedBy as UpdatedBy,&#xD;&#xA;				py.updatedat at time zone 'utc'&#xD;&#xA;			from payment py join&#xD;&#xA;			paymentinvoice pi on&#xD;&#xA;			py.paymentinvoiceid = pi.paymentinvoiceid&#xD;&#xA;			where extinvoiceid = vExtInvoiceID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'SetPayment',&#xD;&#xA;                                'PaymentID: ' || cast(vPaymentID as varchar)&#xD;&#xA;				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)&#xD;&#xA;				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')&#xD;&#xA;				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')&#xD;&#xA;				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')&#xD;&#xA;				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)&#xD;&#xA;				|| ', CreatedBy: ' || cast(vuseruuid as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetPayment';&#xD;&#xA;        RETURN ;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.setpayment" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paydate" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.setpayment" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="7" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.setpayment" ordinal_position="6" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vextinvoiceid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vdepth" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.setpayment" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vbitcointransaction" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setpayment" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="confidencestate" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setpayment" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtransactionuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="depth" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.setpayment" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="extinvoiceid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vconfidencestate" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setpayment" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="16" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.setpayment" ordinal_position="17" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpayment" ordinal_position="18" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="updatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.setpayment" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="bitcointransation" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION setpayment(vtransactionuuid uuid, vbitcointransaction character varying, vconfidencestate character varying, vdepth integer, vextinvoiceid uuid, vuseruuid uuid, vroles text[]) RETURNS TABLE(paymentuuid uuid, paymentinvoiceuuid uuid, paydate timestamp with time zone, bitcointransation character varying, confidencestate character varying, depth integer, extinvoiceid uuid, createdby uuid, createdat timestamp with time zone, updatedby uuid, updatedat timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE 	vPaymentID integer;
		vPaymentUUID uuid := (select uuid_generate_v4());
		vPaymentInvoiceID integer := (select PaymentInvoiceID from transactions where transactionuuid = vTransactionUUID);
		vPayDate timestamp without time zone := null;
		vTransactionID integer := (select transactionid from transactions where transactionuuid = vtransactionuuid);
		vFunctionName varchar := 'SetPayment';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN


		IF exists (select extinvoiceid from payment where extinvoiceid = vExtInvoiceID) THEN
		-- TEST
		vPaymentID := (select paymentid from payment where ExtInvoiceID = vExtInvoiceID);
		perform public.createlog(0,'START Updated Payment sucessfully', 'SetPayment',
                                'PaymentID: ' || cast(vPaymentID as varchar)
				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)
				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')
				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')
				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')
				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)
				|| ', CreatedBy: ' || cast(vuseruuid as varchar));
		-- update
		--Proof if ConfidenceState is Pending and PayDate is null
		IF ((LOWER(vConfidenceState) = LOWER('Pending') or LOWER(vConfidenceState) = LOWER('building'))
			and (select 1 from payment where extinvoiceid = vExtInvoiceID and PayDate is null)::integer=1) THEN
			vPayDate := now();
		ELSE vPayDate := (select paydate from payment where extinvoiceid = vExtInvoiceID);
		END IF;
		update payment set ConfidenceState = vConfidenceState, Depth = vDepth, bitcointransaction = vbitcointransaction,
		PayDate = vPayDate, updatedat = now(), updatedby = vuseruuid
		where ExtInvoiceID = vExtInvoiceID;

		vPaymentID := (select paymentid from payment where ExtInvoiceID = vExtInvoiceID);
		-- Begin Log if success
		perform public.createlog(0,'END Updated Payment sucessfully', 'SetPayment',
                                'PaymentID: ' || cast(vPaymentID as varchar)
				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)
				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')
				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')
				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')
				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)
				|| ', CreatedBy: ' || cast(vuseruuid as varchar));

		-- End Log if success

	ELSE
		-- Insert
		 vPaymentID := (select nextval('PaymentID'));
		IF (LOWER(vConfidenceState) = LOWER('Pending') or LOWER(vConfidenceState) = LOWER('building')) THEN
			vPayDate := now();
		ELSE 	vPayDate := null;
		END IF;
		INSERT INTO payment(paymentid, paymentuuid, paymentinvoiceid, paydate, bitcointransaction,
				    createdby, depth, confidencestate, extinvoiceid,
				    createdat)
			VALUES (vPaymentID, vPaymentUUID, vPaymentInvoiceID, vPayDate, vbitcointransaction,
			vuseruuid, vDepth, vConfidenceState, vExtInvoiceID, now());

			-- Update Transactions table
		UPDATE Transactions SET PaymentID = vPaymentID, UpdatedAt = now(), UpdatedBy = vuseruuid
		WHERE TransactionID = vTransactionID;

		-- Begin Log if success
		perform public.createlog(0,'Created Payment sucessfully', 'SetPayment',
                                'PaymentID: ' || cast(vPaymentID as varchar)
				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)
				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')
				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')
				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')
				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)
				|| ', CreatedBy: ' || cast(vuseruuid as varchar));

		-- End Log if success

		END IF;
	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;

        -- Return PaymentID
        RETURN QUERY (
			select 	PaymentUUID,
				pi.PaymentInvoiceUUID,
				paydate at time zone 'utc',
				bitcointransaction,
				confidencestate,
				depth,
				extinvoiceid,
				py.CreatedBy as CreatedBy,
				py.createdat at time zone 'utc',
				py.UpdatedBy as UpdatedBy,
				py.updatedat at time zone 'utc'
			from payment py join
			paymentinvoice pi on
			py.paymentinvoiceid = pi.paymentinvoiceid
			where extinvoiceid = vExtInvoiceID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'SetPayment',
                                'PaymentID: ' || cast(vPaymentID as varchar)
				|| ', PaymentInvoiceID: ' || cast(vPaymentInvoiceID as varchar)
				|| ', BitcoinTransaction: ' || coalesce(vBitcoinTransaction, 'no BitcoinTransaction')
				|| ', Confidence State: ' || coalesce(vconfidencestate, 'no value')
				|| ', Depth: ' || coalesce(cast(vDepth as varchar), 'no value')
				|| ', ExtInvoiceID: ' || cast(vExtInvoiceId as varchar)
				|| ', CreatedBy: ' || cast(vuseruuid as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetPayment';
        RETURN ;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.setpaymentinvoiceoffer" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;      DECLARE&#xD;&#xA;		vPaymentInvoiceID integer;&#xD;&#xA;		vPaymentInvoiceUUID uuid;&#xD;&#xA;		vFunctionName varchar := 'SetPaymentInvoiceOffer';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;	IF(vIsAllowed) THEN&#xD;&#xA;		-- Create PaymentInvoice&#xD;&#xA;		perform createpaymentinvoice(vInvoice,vOfferRequestUUID,vCreatedBy, vRoles);&#xD;&#xA;		vPaymentInvoiceID := (select currval('PaymentInvoiceID'));&#xD;&#xA;		vPaymentInvoiceUUID := (select paymentinvoice.paymentinvoiceuuid from paymentinvoice where paymentinvoiceid = vPaymentInvoiceID);&#xD;&#xA;&#xD;&#xA;		-- Create Offer&#xD;&#xA;		perform createoffer(vPaymentInvoiceUUID, vCreatedBy, vRoles);&#xD;&#xA;&#xD;&#xA;		-- Begin Log if success&#xD;&#xA;		perform public.createlog(0,'Set SetPaymentInvoiceOffer sucessfully', 'SetPaymentInvoiceOffer',&#xD;&#xA;					'OfferRequestID: ' || cast(vOfferRequestUUID as varchar)&#xD;&#xA;					|| ', invoice: ' || vInvoice&#xD;&#xA;					|| ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;&#xD;&#xA;	ELSE&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;	END IF;&#xD;&#xA;        -- End Log if success&#xD;&#xA;        -- Return&#xD;&#xA;        RETURN QUERY (&#xD;&#xA;		select 	pi.paymentinvoiceuuid,&#xD;&#xA;			pi.invoice,&#xD;&#xA;			ofr.offeruuid,&#xD;&#xA;			pi.createdat at time zone 'utc' as paymentCreatedAt,&#xD;&#xA;			vCreatedBy as paymentCreatedBy,&#xD;&#xA;			ofr.createdat at time zone 'utc' as offerCreatedAt,&#xD;&#xA;			vCreatedBy as offerCreatedBy&#xD;&#xA;		from paymentinvoice pi&#xD;&#xA;		join offer ofr ON pi.paymentinvoiceid = ofr.paymentinvoiceid&#xD;&#xA;		where pi.paymentinvoiceuuid = vPaymentInvoiceUUID&#xD;&#xA;        );&#xD;&#xA;&#xD;&#xA;        exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'SetPaymentInvoiceOffer',&#xD;&#xA;                                'OfferRequestID: ' || cast(vOfferRequestUUID as varchar)&#xD;&#xA;				|| ', invoice: ' || vInvoice&#xD;&#xA;                                || ', CreatedBy: ' || cast(vCreatedBy as varchar));&#xD;&#xA;        -- End Log if error&#xD;&#xA;        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetPaymentInvoiceOffer';&#xD;&#xA;        RETURN;&#xD;&#xA;      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="9" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="10" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offercreatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="11" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offercreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vofferrequestuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vinvoice" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="5" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentinvoiceuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="6" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="invoice" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="7" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="offeruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.setpaymentinvoiceoffer" ordinal_position="8" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="paymentcreatedat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <code>CREATE FUNCTION setpaymentinvoiceoffer(vofferrequestuuid uuid, vinvoice character varying, vcreatedby uuid, vroles text[]) RETURNS TABLE(paymentinvoiceuuid uuid, invoice character varying, offeruuid uuid, paymentcreatedat timestamp with time zone, paymentcreatedby uuid, offercreatedat timestamp with time zone, offercreatedby uuid)
    LANGUAGE plpgsql
    AS $$
	#variable_conflict use_column
      DECLARE
		vPaymentInvoiceID integer;
		vPaymentInvoiceUUID uuid;
		vFunctionName varchar := 'SetPaymentInvoiceOffer';
		vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));

	BEGIN

	IF(vIsAllowed) THEN
		-- Create PaymentInvoice
		perform createpaymentinvoice(vInvoice,vOfferRequestUUID,vCreatedBy, vRoles);
		vPaymentInvoiceID := (select currval('PaymentInvoiceID'));
		vPaymentInvoiceUUID := (select paymentinvoice.paymentinvoiceuuid from paymentinvoice where paymentinvoiceid = vPaymentInvoiceID);

		-- Create Offer
		perform createoffer(vPaymentInvoiceUUID, vCreatedBy, vRoles);

		-- Begin Log if success
		perform public.createlog(0,'Set SetPaymentInvoiceOffer sucessfully', 'SetPaymentInvoiceOffer',
					'OfferRequestID: ' || cast(vOfferRequestUUID as varchar)
					|| ', invoice: ' || vInvoice
					|| ', CreatedBy: ' || cast(vCreatedBy as varchar));

	ELSE
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
	END IF;
        -- End Log if success
        -- Return
        RETURN QUERY (
		select 	pi.paymentinvoiceuuid,
			pi.invoice,
			ofr.offeruuid,
			pi.createdat at time zone 'utc' as paymentCreatedAt,
			vCreatedBy as paymentCreatedBy,
			ofr.createdat at time zone 'utc' as offerCreatedAt,
			vCreatedBy as offerCreatedBy
		from paymentinvoice pi
		join offer ofr ON pi.paymentinvoiceid = ofr.paymentinvoiceid
		where pi.paymentinvoiceuuid = vPaymentInvoiceUUID
        );

        exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,'SetPaymentInvoiceOffer',
                                'OfferRequestID: ' || cast(vOfferRequestUUID as varchar)
				|| ', invoice: ' || vInvoice
                                || ', CreatedBy: ' || cast(vCreatedBy as varchar));
        -- End Log if error
        RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetPaymentInvoiceOffer';
        RETURN;
      END;
  $$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.setpermission" routine_type="FUNCTION" return_type="pg_catalog.void" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="DECLARE vFunctionID integer := (select nextval('FunctionID'));&#xD;&#xA;		vThisFunctionName varchar := 'SetPermission';&#xD;&#xA;		vIsAllowed boolean := (select public.checkPermissions(vRolesUser, vThisFunctionName));&#xD;&#xA;		vRoleId integer;&#xD;&#xA;		vRoleName varchar;&#xD;&#xA;		vFunctionExists boolean := (select exists(select 1 from functions where functionname = vfunctionname));&#xD;&#xA;	BEGIN&#xD;&#xA;&#xD;&#xA;		if(vIsAllowed) then&#xD;&#xA;&#xD;&#xA;			--Proof if the function alread exists&#xD;&#xA;			if(not vFunctionExists) then&#xD;&#xA;				insert into functions (FunctionID, FunctionName)&#xD;&#xA;				values (vFunctionID, vFunctionName);&#xD;&#xA;&#xD;&#xA;				FOREACH vRoleName in array vRoles LOOP&#xD;&#xA;					vRoleId := (select roleid from roles where rolename = vRoleName);&#xD;&#xA;					insert into rolespermissions(RoleId,FunctionId)&#xD;&#xA;					values (vRoleId, vFunctionId);&#xD;&#xA;				END LOOP;&#xD;&#xA;			else&#xD;&#xA;&#xD;&#xA;				 vFunctionID := (select functionid from functions where functionname = vFunctionName);&#xD;&#xA;&#xD;&#xA;				 FOREACH vRoleName in array vRoles LOOP&#xD;&#xA;					vRoleId := (select roleid from roles where rolename = vRoleName);&#xD;&#xA;					insert into rolespermissions(RoleId,FunctionId)&#xD;&#xA;					values (vRoleId, vFunctionId);&#xD;&#xA;				 END LOOP;&#xD;&#xA;&#xD;&#xA;			end if;&#xD;&#xA;&#xD;&#xA;		else&#xD;&#xA;		 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;		 RETURN;&#xD;&#xA;		end if;&#xD;&#xA;&#xD;&#xA;	-- Begin Log if success&#xD;&#xA;        perform public.createlog(0,'Created Permission sucessfully', 'SetPermission',&#xD;&#xA;                                'PermissionID: ' || cast(vFunctionID as varchar) || ', Roles: '&#xD;&#xA;                                || cast(vRoles as varchar) || ', FunctionName: ' || vFunctionName);&#xD;&#xA;&#xD;&#xA;	 exception when others then&#xD;&#xA;        -- Begin Log if error&#xD;&#xA;        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'SetPermission',&#xD;&#xA;                                'PermissionID: ' || cast(vFunctionID as varchar) || ', Roles: '&#xD;&#xA;                                || cast(vRoles as varchar) || ', FunctionName: ' || vFunctionName);&#xD;&#xA;        -- End Log if error&#xD;&#xA;		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetPermission';&#xD;&#xA;		RETURN;&#xD;&#xA;	END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="0" provolatile="v">
    <param parent="public.setpermission" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.setpermission" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vrolesuser" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.setpermission" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vfunctionname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.setpermission" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vuseruuid" data_type="uuid" udt="pg_catalog.uuid" />
    <code>CREATE FUNCTION setpermission(vroles text[], vfunctionname character varying, vuseruuid uuid, vrolesuser text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
	DECLARE vFunctionID integer := (select nextval('FunctionID'));
		vThisFunctionName varchar := 'SetPermission';
		vIsAllowed boolean := (select public.checkPermissions(vRolesUser, vThisFunctionName));
		vRoleId integer;
		vRoleName varchar;
		vFunctionExists boolean := (select exists(select 1 from functions where functionname = vfunctionname));
	BEGIN

		if(vIsAllowed) then

			--Proof if the function alread exists
			if(not vFunctionExists) then
				insert into functions (FunctionID, FunctionName)
				values (vFunctionID, vFunctionName);

				FOREACH vRoleName in array vRoles LOOP
					vRoleId := (select roleid from roles where rolename = vRoleName);
					insert into rolespermissions(RoleId,FunctionId)
					values (vRoleId, vFunctionId);
				END LOOP;
			else

				 vFunctionID := (select functionid from functions where functionname = vFunctionName);

				 FOREACH vRoleName in array vRoles LOOP
					vRoleId := (select roleid from roles where rolename = vRoleName);
					insert into rolespermissions(RoleId,FunctionId)
					values (vRoleId, vFunctionId);
				 END LOOP;

			end if;

		else
		 RAISE EXCEPTION '%', 'Insufficiency rigths';
		 RETURN;
		end if;

	-- Begin Log if success
        perform public.createlog(0,'Created Permission sucessfully', 'SetPermission',
                                'PermissionID: ' || cast(vFunctionID as varchar) || ', Roles: '
                                || cast(vRoles as varchar) || ', FunctionName: ' || vFunctionName);

	 exception when others then
        -- Begin Log if error
        perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE, 'SetPermission',
                                'PermissionID: ' || cast(vFunctionID as varchar) || ', Roles: '
                                || cast(vRoles as varchar) || ', FunctionName: ' || vFunctionName);
        -- End Log if error
		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetPermission';
		RETURN;
	END;
$$;


</code>
  </procedure>
  <procedure xtype="FN" name="public.settechnologydata" routine_type="FUNCTION" return_type="pg_catalog.record" dtd_identifier="0" routine_body="EXTERNAL" routine_definition="#variable_conflict use_column&#xD;&#xA;	      DECLARE 	vCompUUID uuid;&#xD;&#xA;					vTagName text;&#xD;&#xA;					vTechnologyDataID int;&#xD;&#xA;					vTechnologyDataUUID uuid;&#xD;&#xA;					vTechnologyID integer := (select technologyID from technologies where technologyUUID = vTechnologyUUID);&#xD;&#xA;					vFunctionName varchar := 'SetTechnologyData';&#xD;&#xA;					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));&#xD;&#xA;					vAlreadExists integer := (select 1 from technologydata where technologydataname = vtechnologydataname and deleted is null);&#xD;&#xA;&#xD;&#xA;		BEGIN&#xD;&#xA;&#xD;&#xA;		IF(vIsAllowed) THEN&#xD;&#xA;			-- Proof if all components are avaiable&#xD;&#xA;			FOREACH vCompUUID in array vComponentlist&#xD;&#xA;			LOOP&#xD;&#xA;				 if not exists (select componentid from components where componentuuid = vCompUUID) then&#xD;&#xA;				 raise exception using&#xD;&#xA;				 errcode = 'invalid_parameter_value',&#xD;&#xA;				 message = 'There is no component with ComponentName: ' || cast(vCompUUID as varchar);&#xD;&#xA;				 end if;&#xD;&#xA;			END LOOP;&#xD;&#xA;			-- Proof if all Tags are avaiable&#xD;&#xA;			IF (vTagList != null) THEN&#xD;&#xA;				FOREACH vTagName in array vTagList&#xD;&#xA;				LOOP&#xD;&#xA;					 if not exists (select tagID from tags where tagname = vTagName) then&#xD;&#xA;						perform public.createtag(vTagName,vCreatedby, vRoles);&#xD;&#xA;					 end if;&#xD;&#xA;				END LOOP;&#xD;&#xA;			END IF;&#xD;&#xA;			-- Proof if technology is avaiable&#xD;&#xA;			if not exists (select technologyid from technologies where technologyuuid = vTechnologyUUID) then&#xD;&#xA;				raise exception using&#xD;&#xA;			    errcode = 'invalid_parameter_value',&#xD;&#xA;			    message = 'There is no technology with TechnologyID: ' || coalesce(vTechnologyID::text,'Empty');&#xD;&#xA;			end if;&#xD;&#xA;&#xD;&#xA;			-- Create new TechnologyData&#xD;&#xA;				IF(vAlreadExists is null) THEN&#xD;&#xA;					perform public.createtechnologydata(vTechnologyDataName, vTechnologyData, vTechnologyDataDescription, vLicenseFee, vProductCode, 					vTechnologyUUID, vtechnologydataimgref, vCreatedBy, vRoles);&#xD;&#xA;					vTechnologyDataID := (select currval('TechnologyDataID'));&#xD;&#xA;					vTechnologyDataUUID := (select technologydatauuid from technologydata where technologydataid = vTechnologyDataID);&#xD;&#xA;&#xD;&#xA;					-- Create relation from Components to TechnologyData&#xD;&#xA;					perform public.CreateTechnologyDataComponents(vTechnologyDataUUID, vComponentList, vRoles);&#xD;&#xA;&#xD;&#xA;					-- Create relation from Tags to TechnologyData&#xD;&#xA;					IF (vTagList != null) THEN&#xD;&#xA;						perform public.CreateTechnologyDataTags(vTechnologyDataUUID, vTagList, CreatedBy, vRoles);&#xD;&#xA;					END IF;&#xD;&#xA;				ELSE&#xD;&#xA;					RAISE EXCEPTION '%', 'Technologydata already exists';&#xD;&#xA;					RETURN;&#xD;&#xA;&#xD;&#xA;			END IF;&#xD;&#xA;			-- Begin Log if success&#xD;&#xA;			perform public.createlog(0,'Set TechnologyData sucessfully', 'SetTechnologyData',&#xD;&#xA;						'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '&#xD;&#xA;						|| replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData&#xD;&#xA;						|| ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')&#xD;&#xA;						|| ', CreatedBy: ' || cast(vRoles as varchar));&#xD;&#xA;&#xD;&#xA;		ELSE&#xD;&#xA;			 RAISE EXCEPTION '%', 'Insufficiency rigths';&#xD;&#xA;			 RETURN;&#xD;&#xA;		END IF;&#xD;&#xA;		-- End Log if success&#xD;&#xA;		-- Return vTechnologyDataUUID&#xD;&#xA;		RETURN QUERY (&#xD;&#xA;			select 	TechnologyDataUUID,&#xD;&#xA;				td.TechnologyDataName,&#xD;&#xA;				vTechnologyUUID,&#xD;&#xA;				TechnologyData,&#xD;&#xA;				LicenseFee,&#xD;&#xA;				ProductCode,&#xD;&#xA;				TechnologyDataDescription,&#xD;&#xA;				TechnologyDataThumbnail,&#xD;&#xA;				TechnologyDataImgRef,&#xD;&#xA;				array_agg(tg.taguuid) as TagList,&#xD;&#xA;				array_agg(co.componentuuid) as ComponentList,&#xD;&#xA;				td.CreatedAt at time zone 'utc',&#xD;&#xA;				vCreatedBy as CreatedBy&#xD;&#xA;			from technologydata td&#xD;&#xA;			left outer join technologydatatags tt on&#xD;&#xA;			td.technologydataid = tt.technologydataid&#xD;&#xA;			left outer join tags tg on tt.tagid = tg.tagid&#xD;&#xA;			join technologydatacomponents tc&#xD;&#xA;			on tc.technologydataid = td.technologydataid&#xD;&#xA;			join components co&#xD;&#xA;			on co.componentid = tc.componentid&#xD;&#xA;			where td.technologydataid = vTechnologyDataID&#xD;&#xA;			group by technologydatauuid, td.technologydataname, technologydata,&#xD;&#xA;				 licensefee, productcode, technologydatadescription, technologydatathumbnail,&#xD;&#xA;				 TechnologyDataImgRef, td.createdat, td.createdby&#xD;&#xA;		);&#xD;&#xA;&#xD;&#xA;		exception when others then&#xD;&#xA;		-- Begin Log if error&#xD;&#xA;		perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'SetTechnologyData',&#xD;&#xA;					'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '&#xD;&#xA;					|| replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData&#xD;&#xA;					|| ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')&#xD;&#xA;					|| ', CreatedBy: ' || cast(vCreatedby as varchar));&#xD;&#xA;		-- End Log if error&#xD;&#xA;		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetTechnologyData';&#xD;&#xA;		RETURN;&#xD;&#xA;	      END;" external_language="PLPGSQL" is_deterministic="NO" is_null_call="NO" security_type="INVOKER" proisagg="0" prosecdef="0" proisstrict="0" proretset="1" provolatile="v">
    <param parent="public.settechnologydata" ordinal_position="9" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydataimgref" data_type="text" udt="pg_catalog.text" />
    <param parent="public.settechnologydata" ordinal_position="16" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="licensefee" data_type="bigint" udt="pg_catalog.int8" />
    <param parent="public.settechnologydata" ordinal_position="17" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="productcode" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.settechnologydata" ordinal_position="18" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.settechnologydata" ordinal_position="19" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatathumbnail" data_type="bytea" udt="pg_catalog.bytea" />
    <param parent="public.settechnologydata" ordinal_position="20" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataimgref" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.settechnologydata" ordinal_position="21" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="taglist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.settechnologydata" ordinal_position="22" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="componentlist" data_type="ARRAY" udt="pg_catalog._uuid" />
    <param parent="public.settechnologydata" ordinal_position="23" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdat" data_type="timestamp with time zone" udt="pg_catalog.timestamptz" />
    <param parent="public.settechnologydata" ordinal_position="24" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="createdby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.settechnologydata" ordinal_position="1" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.settechnologydata" ordinal_position="2" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.settechnologydata" ordinal_position="3" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologydatadescription" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.settechnologydata" ordinal_position="4" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtechnologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.settechnologydata" ordinal_position="5" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vlicensefee" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.settechnologydata" ordinal_position="6" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vproductcode" data_type="integer" udt="pg_catalog.int4" />
    <param parent="public.settechnologydata" ordinal_position="7" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vtaglist" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.settechnologydata" ordinal_position="8" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcomponentlist" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.settechnologydata" ordinal_position="10" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vcreatedby" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.settechnologydata" ordinal_position="11" parameter_mode="IN" is_result="NO" as_locator="NO" parameter_name="vroles" data_type="ARRAY" udt="pg_catalog._text" />
    <param parent="public.settechnologydata" ordinal_position="12" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydatauuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.settechnologydata" ordinal_position="13" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydataname" data_type="character varying" udt="pg_catalog.varchar" />
    <param parent="public.settechnologydata" ordinal_position="14" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologyuuid" data_type="uuid" udt="pg_catalog.uuid" />
    <param parent="public.settechnologydata" ordinal_position="15" parameter_mode="OUT" is_result="NO" as_locator="NO" parameter_name="technologydata" data_type="character varying" udt="pg_catalog.varchar" />
    <code>CREATE FUNCTION settechnologydata(vtechnologydataname character varying, vtechnologydata character varying, vtechnologydatadescription character varying, vtechnologyuuid uuid, vlicensefee integer, vproductcode integer, vtaglist text[], vcomponentlist text[], vtechnologydataimgref text, vcreatedby uuid, vroles text[]) RETURNS TABLE(technologydatauuid uuid, technologydataname character varying, technologyuuid uuid, technologydata character varying, licensefee bigint, productcode integer, technologydatadescription character varying, technologydatathumbnail bytea, technologydataimgref character varying, taglist uuid[], componentlist uuid[], createdat timestamp with time zone, createdby uuid)
    LANGUAGE plpgsql
    AS $$
		#variable_conflict use_column
	      DECLARE 	vCompUUID uuid;
					vTagName text;
					vTechnologyDataID int;
					vTechnologyDataUUID uuid;
					vTechnologyID integer := (select technologyID from technologies where technologyUUID = vTechnologyUUID);
					vFunctionName varchar := 'SetTechnologyData';
					vIsAllowed boolean := (select public.checkPermissions(vRoles, vFunctionName));
					vAlreadExists integer := (select 1 from technologydata where technologydataname = vtechnologydataname and deleted is null);

		BEGIN

		IF(vIsAllowed) THEN
			-- Proof if all components are avaiable
			FOREACH vCompUUID in array vComponentlist
			LOOP
				 if not exists (select componentid from components where componentuuid = vCompUUID) then
				 raise exception using
				 errcode = 'invalid_parameter_value',
				 message = 'There is no component with ComponentName: ' || cast(vCompUUID as varchar);
				 end if;
			END LOOP;
			-- Proof if all Tags are avaiable
			IF (vTagList != null) THEN
				FOREACH vTagName in array vTagList
				LOOP
					 if not exists (select tagID from tags where tagname = vTagName) then
						perform public.createtag(vTagName,vCreatedby, vRoles);
					 end if;
				END LOOP;
			END IF;
			-- Proof if technology is avaiable
			if not exists (select technologyid from technologies where technologyuuid = vTechnologyUUID) then
				raise exception using
			    errcode = 'invalid_parameter_value',
			    message = 'There is no technology with TechnologyID: ' || coalesce(vTechnologyID::text,'Empty');
			end if;

			-- Create new TechnologyData
				IF(vAlreadExists is null) THEN
					perform public.createtechnologydata(vTechnologyDataName, vTechnologyData, vTechnologyDataDescription, vLicenseFee, vProductCode, 					vTechnologyUUID, vtechnologydataimgref, vCreatedBy, vRoles);
					vTechnologyDataID := (select currval('TechnologyDataID'));
					vTechnologyDataUUID := (select technologydatauuid from technologydata where technologydataid = vTechnologyDataID);

					-- Create relation from Components to TechnologyData
					perform public.CreateTechnologyDataComponents(vTechnologyDataUUID, vComponentList, vRoles);

					-- Create relation from Tags to TechnologyData
					IF (vTagList != null) THEN
						perform public.CreateTechnologyDataTags(vTechnologyDataUUID, vTagList, CreatedBy, vRoles);
					END IF;
				ELSE
					RAISE EXCEPTION '%', 'Technologydata already exists';
					RETURN;

			END IF;
			-- Begin Log if success
			perform public.createlog(0,'Set TechnologyData sucessfully', 'SetTechnologyData',
						'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '
						|| replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData
						|| ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')
						|| ', CreatedBy: ' || cast(vRoles as varchar));

		ELSE
			 RAISE EXCEPTION '%', 'Insufficiency rigths';
			 RETURN;
		END IF;
		-- End Log if success
		-- Return vTechnologyDataUUID
		RETURN QUERY (
			select 	TechnologyDataUUID,
				td.TechnologyDataName,
				vTechnologyUUID,
				TechnologyData,
				LicenseFee,
				ProductCode,
				TechnologyDataDescription,
				TechnologyDataThumbnail,
				TechnologyDataImgRef,
				array_agg(tg.taguuid) as TagList,
				array_agg(co.componentuuid) as ComponentList,
				td.CreatedAt at time zone 'utc',
				vCreatedBy as CreatedBy
			from technologydata td
			left outer join technologydatatags tt on
			td.technologydataid = tt.technologydataid
			left outer join tags tg on tt.tagid = tg.tagid
			join technologydatacomponents tc
			on tc.technologydataid = td.technologydataid
			join components co
			on co.componentid = tc.componentid
			where td.technologydataid = vTechnologyDataID
			group by technologydatauuid, td.technologydataname, technologydata,
				 licensefee, productcode, technologydatadescription, technologydatathumbnail,
				 TechnologyDataImgRef, td.createdat, td.createdby
		);

		exception when others then
		-- Begin Log if error
		perform public.createlog(1,'ERROR: ' || SQLERRM || ' ' || SQLSTATE,  'SetTechnologyData',
					'TechnologyDataID: ' || cast(vTechnologyDataID as varchar) || ', TechnologyDataName: '
					|| replace(vTechnologyDataName, '''', '''''') || ', TechnologyData: ' || vTechnologyData
					|| ', TechnologyDataDescription: ' || replace(vTechnologyDataDescription, '''', '''''')
					|| ', CreatedBy: ' || cast(vCreatedby as varchar));
		-- End Log if error
		RAISE EXCEPTION '%', 'ERROR: ' || SQLERRM || ' ' || SQLSTATE || ' at SetTechnologyData';
		RETURN;
	      END;
	  $$;


</code>
  </procedure>
  <sequence xtype="SEQUENCE" name="public.attributeid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="attributeid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE attributeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.componentid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="componentid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE componentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.functionid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="functionid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="2" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE functionid
    START WITH 2
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.licenseorderid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="licenseorderid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE licenseorderid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.logid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="logid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE logid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.offerid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="offerid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE offerid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.offerrequestid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="offerrequestid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE offerrequestid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.offerrequestitemid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="offerrequestitemid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE offerrequestitemid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.paymentid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="paymentid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE paymentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.paymentinvoiceid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="paymentinvoiceid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE paymentinvoiceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.productcode" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="productcode" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1000" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE productcode
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.roleid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="roleid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE roleid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.tagid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="tagid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE tagid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.technologydataid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="technologydataid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE technologydataid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.technologyid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="technologyid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE technologyid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.transactionid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="transactionid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE transactionid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
  <sequence xtype="SEQUENCE" name="public.userid" sequence_catalog="MarketplaceCore" sequence_schema="public" sequence_name="userid" data_type="bigint" numeric_precision="64" numeric_precision_radix="2" numeric_scale="0" start_value="1" minimum_value="1" maximum_value="9223372036854775807" increment="1" cycle_option="NO">
    <code>CREATE SEQUENCE userid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;</code>
  </sequence>
</database>